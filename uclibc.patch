diff -urN uClibc-0.9.33/include/fcntl.h uClibc-0.9.33-new/include/fcntl.h
--- uClibc-0.9.33/include/fcntl.h	2013-09-23 20:39:10.206221917 -0400
+++ uClibc-0.9.33-new/include/fcntl.h	2013-09-23 20:39:32.926222859 -0400
@@ -121,20 +121,18 @@
    This function is a cancellation point and therefore not marked with
    __THROW.  */
 # ifndef __USE_FILE_OFFSET64
-extern int openat (int __fd, __const char *__file, int __oflag, ...)
-     __nonnull ((2));
+extern int openat (int __fd, __const char *__file, int __oflag, ...);
 libc_hidden_proto(openat)
 # else
 #  ifdef __REDIRECT
 extern int __REDIRECT (openat, (int __fd, __const char *__file, int __oflag,
-				...), openat64) __nonnull ((2));
+				...), openat64);
 #  else
 #   define openat openat64
 #  endif
 # endif
 
-extern int openat64 (int __fd, __const char *__file, int __oflag, ...)
-     __nonnull ((2));
+extern int openat64 (int __fd, __const char *__file, int __oflag, ...);
 libc_hidden_proto(openat64)
 #endif
 
diff -urN uClibc-0.9.33/include/libc-internal.h uClibc-0.9.33-new/include/libc-internal.h
--- uClibc-0.9.33/include/libc-internal.h	2013-09-23 20:39:09.978221909 -0400
+++ uClibc-0.9.33-new/include/libc-internal.h	2013-09-23 20:39:32.926222859 -0400
@@ -55,11 +55,21 @@
 /* #include <pthread.h> */
 #  ifndef __UCLIBC_HAS_THREADS__
 #   define __pthread_mutex_init(mutex, mutexattr)         ((void)0)
+#   define __pthread_mutex_reinit(mutex)                  ((void)0)
 #   define __pthread_mutex_lock(mutex)                    ((void)0)
 #   define __pthread_mutex_trylock(mutex)                 ((void)0)
 #   define __pthread_mutex_unlock(mutex)                  ((void)0)
 #   define _pthread_cleanup_push_defer(mutex)             ((void)0)
 #   define _pthread_cleanup_pop_restore(mutex)            ((void)0)
+#   define __sclib_futex_wake(a,b)                        ((void)0)
+#   define __sclib_futex_wait(a,b)                        ((void)0)
+#   define __sclib_schedule(a,b)					sclib_schedule_single(a,b)
+#   define __sclib_mutex_auto_init                        ((void)0)
+#   define __sclib_mutex_auto_reinit                      ((void)0)
+#   define __sclib_mutex_auto_destroy                     ((void)0)
+#   define __sclib_mutex_auto_lock                        ((void)0)
+#   define __sclib_mutex_auto_trylock                     ((void)0)
+#   define __sclib_mutex_auto_unlock                      ((void)0)
 #  endif
 
 /* internal access to program name */
diff -urN uClibc-0.9.33/include/sys/stat.h uClibc-0.9.33-new/include/sys/stat.h
--- uClibc-0.9.33/include/sys/stat.h	2013-09-23 20:39:10.002221906 -0400
+++ uClibc-0.9.33-new/include/sys/stat.h	2013-09-23 20:39:32.926222859 -0400
@@ -241,13 +241,13 @@
 # ifndef __USE_FILE_OFFSET64
 extern int fstatat (int __fd, __const char *__restrict __file,
 		    struct stat *__restrict __buf, int __flag)
-     __THROW __nonnull ((2, 3));
+     __THROW __nonnull ((3));
 # else
 #  ifdef __REDIRECT_NTH
 extern int __REDIRECT_NTH (fstatat, (int __fd, __const char *__restrict __file,
 				     struct stat *__restrict __buf,
 				     int __flag),
-			   fstatat64) __nonnull ((2, 3));
+			   fstatat64) __nonnull ((3));
 #  else
 #   define fstatat fstatat64
 #  endif
@@ -256,7 +256,7 @@
 # ifdef __USE_LARGEFILE64
 extern int fstatat64 (int __fd, __const char *__restrict __file,
 		      struct stat64 *__restrict __buf, int __flag)
-     __THROW __nonnull ((2, 3));
+     __THROW __nonnull ((3));
 # endif
 #endif
 
@@ -309,7 +309,7 @@
    the directory FD is open on.  */
 extern int fchmodat (int __fd, __const char *__file, __mode_t __mode,
 		     int __flag)
-     __THROW __nonnull ((2)) __wur;
+     __THROW __wur;
 #endif /* Use ATFILE.  */
 
 
@@ -334,7 +334,7 @@
    interpret relative PATH names relative to the directory associated
    with FD.  */
 extern int mkdirat (int __fd, __const char *__path, __mode_t __mode)
-     __THROW __nonnull ((2));
+     __THROW;
 #endif
 
 /* Create a device file named PATH, with permission and special bits MODE
@@ -350,7 +350,7 @@
    device number DEV.  But interpret relative PATH names relative to
    the directory associated with FD.  */
 extern int mknodat (int __fd, __const char *__path, __mode_t __mode,
-		    __dev_t __dev) __THROW __nonnull ((2));
+		    __dev_t __dev) __THROW;
 libc_hidden_proto(mknodat)
 # endif
 #endif
@@ -365,7 +365,7 @@
    interpret relative PATH names relative to the directory associated
    with FD.  */
 extern int mkfifoat (int __fd, __const char *__path, __mode_t __mode)
-     __THROW __nonnull ((2));
+     __THROW;
 #endif
 
 #ifdef __USE_ATFILE
@@ -374,7 +374,7 @@
 extern int utimensat (int __fd, __const char *__path,
 		      __const struct timespec __times[2],
 		      int __flags)
-     __THROW __nonnull ((2));
+     __THROW;
 libc_hidden_proto(utimensat)
 #endif
 
diff -urN uClibc-0.9.33/include/ucontext.h uClibc-0.9.33-new/include/ucontext.h
--- uClibc-0.9.33/include/ucontext.h	2013-09-23 20:39:10.170221917 -0400
+++ uClibc-0.9.33-new/include/ucontext.h	2013-09-23 20:39:32.926222859 -0400
@@ -24,9 +24,33 @@
 /* Get machine dependent definition of data structures.  */
 #include <sys/ucontext.h>
 
-/* The System V ABI user-level context switching support functions
- * are marked obsolescent by SuSv3, and are not implemented by
- * uClibc.  This header is therefore empty.  */
+__BEGIN_DECLS
 
+/* Get user context and store it in variable pointed to by UCP.  */
+extern int getcontext (ucontext_t *__ucp) __THROW;
+
+/* Set user context from information of variable pointed to by UCP.  */
+extern int setcontext (const ucontext_t *__ucp) __THROW;
+
+extern int setcontextp (const ucontext_t *__ucp, const ucontext_t *__prev_ucp) __THROW;
+
+/* Save current context in context variable pointed to by OUCP and set
+   context from variable pointed to by UCP.  */
+extern int swapcontext (ucontext_t *__restrict __oucp,
+			const ucontext_t *__restrict __ucp) __THROW;
+
+extern ucontext_t *swapcontextp (ucontext_t *__restrict __oucp,
+			const ucontext_t *__restrict __ucp) __THROW;
+
+/* Manipulate user context UCP to continue with calling functions FUNC
+   and the ARGC-1 parameters following ARGC when the context is used
+   the next time in `setcontext' or `swapcontext'.
+
+   We cannot say anything about the parameters FUNC takes; `void'
+   is as good as any other choice.  */
+extern void makecontext (ucontext_t *__ucp, void (*__func) (void),
+			 int __argc, ...) __THROW;
+
+__END_DECLS
 
 #endif /* ucontext.h */
diff -urN uClibc-0.9.33/include/unistd.h uClibc-0.9.33-new/include/unistd.h
--- uClibc-0.9.33/include/unistd.h	2013-09-23 20:39:10.202221915 -0400
+++ uClibc-0.9.33-new/include/unistd.h	2013-09-23 20:39:32.926222859 -0400
@@ -273,7 +273,7 @@
    If AT_EACCESS is set in FLAG, then use effective IDs like `eaccess',
    otherwise use real IDs like `access'.  */
 extern int faccessat (int __fd, __const char *__file, int __type, int __flag)
-     __THROW __nonnull ((2)) __wur;
+     __THROW __wur;
 #endif /* Use GNU.  */
 
 
@@ -467,7 +467,7 @@
    on.  */
 extern int fchownat (int __fd, __const char *__file, __uid_t __owner,
 		     __gid_t __group, int __flag)
-     __THROW __nonnull ((2)) __wur;
+     __THROW __wur;
 #endif /* Use GNU.  */
 
 /* Change the process's working directory to PATH.  */
@@ -815,7 +815,7 @@
    to FROMFD and TOFD respectively.  */
 extern int linkat (int __fromfd, __const char *__from, int __tofd,
 		   __const char *__to, int __flags)
-     __THROW __nonnull ((2, 4)) __wur;
+     __THROW __wur;
 #endif
 
 #if defined __USE_BSD || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K
@@ -835,12 +835,12 @@
 #ifdef __USE_ATFILE
 /* Like symlink but a relative path in TO is interpreted relative to TOFD.  */
 extern int symlinkat (__const char *__from, int __tofd,
-		      __const char *__to) __THROW __nonnull ((1, 3)) __wur;
+		      __const char *__to) __THROW __wur;
 
 /* Like readlink but a relative PATH is interpreted relative to FD.  */
 extern ssize_t readlinkat (int __fd, __const char *__restrict __path,
 			   char *__restrict __buf, size_t __len)
-     __THROW __nonnull ((2, 3)) __wur;
+     __THROW __nonnull ((3)) __wur;
 #endif
 
 /* Remove the link NAME.  */
@@ -850,7 +850,7 @@
 #ifdef __USE_ATFILE
 /* Remove the link NAME relative to FD.  */
 extern int unlinkat (int __fd, __const char *__name, int __flag)
-     __THROW __nonnull ((2));
+     __THROW;
 #endif
 
 /* Remove the directory PATH.  */
diff -urN uClibc-0.9.33/ldso/include/ldsodefs.h uClibc-0.9.33-new/ldso/include/ldsodefs.h
--- uClibc-0.9.33/ldso/include/ldsodefs.h	2013-09-23 20:39:09.850221903 -0400
+++ uClibc-0.9.33-new/ldso/include/ldsodefs.h	2013-09-23 20:39:32.930222860 -0400
@@ -74,6 +74,8 @@
    only used within rtld.c itself at startup time.  */
 extern void *_dl_allocate_tls_storage (void)
      internal_function attribute_hidden;
+extern void *_dl_allocate_ktls_storage (void)
+     internal_function attribute_hidden;
 extern void *_dl_allocate_tls_init (void *) internal_function;
 
 /* Deallocate memory allocated with _dl_allocate_tls.  */
diff -urN uClibc-0.9.33/ldso/ldso/dl-elf.c uClibc-0.9.33-new/ldso/ldso/dl-elf.c
--- uClibc-0.9.33/ldso/ldso/dl-elf.c	2013-09-23 20:39:09.830221904 -0400
+++ uClibc-0.9.33-new/ldso/ldso/dl-elf.c	2013-09-23 20:39:32.930222860 -0400
@@ -750,7 +750,7 @@
 	tpnt->n_phent = epnt->e_phnum;
 	tpnt->rtld_flags |= rtld_flags;
 #ifdef __LDSO_STANDALONE_SUPPORT__
-	tpnt->l_entry = epnt->e_entry;
+	tpnt->l_entry = epnt->e_entry + tpnt->loadaddr;
 #endif
 
 #if defined(USE_TLS) && USE_TLS
diff -urN uClibc-0.9.33/ldso/ldso/dl-tls.c uClibc-0.9.33-new/ldso/ldso/dl-tls.c
--- uClibc-0.9.33/ldso/ldso/dl-tls.c	2013-09-23 20:39:09.806221901 -0400
+++ uClibc-0.9.33-new/ldso/ldso/dl-tls.c	2013-09-23 20:39:32.930222860 -0400
@@ -3,6 +3,7 @@
  * Thread-local storage handling in the ELF dynamic linker.
  *
  * Copyright (C) 2005 by Steven J. Hill <sjhill@realitydiluted.com>
+ * Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -488,6 +489,43 @@
 
 void *
 internal_function
+_dl_allocate_ktls_storage (void)
+{
+  size_t size = 4096; /* Page size */
+  void *result = _dl_memalign (_dl_tls_static_align, size);
+  struct kpthread *kpd;
+
+  if (__builtin_expect (result != NULL, 1))
+    {
+      void *end, *mem = result;
+
+# ifdef TLS_TCB_AT_TP
+      /* The TCB follows the TLS blocks.  */
+      result = (char *) result + size - TLS_KTCB_SIZE;
+
+      /* Clear the TCB data structure.  We can't ask the caller (i.e.
+	 libpthread) to do it, because we will initialize the DTV et al.  */
+      _dl_memset (result, '\0', TLS_KTCB_SIZE);
+      end = result;
+# elif defined(TLS_DTV_AT_TP)
+      result = (char *) result + size - TLS_KTCB_SIZE;
+
+      /* Clear the TCB data structure and TLS_PRE_TCB_SIZE bytes before it.
+	 We can't ask the caller (i.e. libpthread) to do it, because we will
+	 initialize the DTV et al.  */
+      _dl_memset ((char *) result - TLS_PRE_KTCB_SIZE, '\0',
+	      TLS_PRE_KTCB_SIZE + TLS_KTCB_SIZE);
+      end = (char *) result - TLS_PRE_KTCB_SIZE;
+# endif
+      kpd = (struct kpthread *) result;
+      kpd->context.uc_stack.ss_sp = mem;
+      kpd->context.uc_stack.ss_size = (size_t) (end - mem);
+    }
+  return result;
+}
+
+void *
+internal_function
 _dl_allocate_tls_storage (void)
 {
   void *result;
@@ -524,7 +562,6 @@
       _dl_memset ((char *) result - TLS_PRE_TCB_SIZE, '\0',
 	      TLS_PRE_TCB_SIZE + TLS_TCB_SIZE);
 # endif
-
       result = allocate_dtv (result);
       if (result == NULL)
 	_dl_free (allocated);
@@ -972,7 +1009,7 @@
 	   the DTV interfaces to be set up early.  */
 	if (_dl_initial_dtv != NULL)
 		return NULL;
-
+ 
 	/* Allocate the array which contains the information about the
 	   dtv slots.  We allocate a few entries more than needed to
 	   avoid the need for reallocation.  */
@@ -1008,6 +1045,12 @@
 	/* Compute the TLS offsets for the various blocks.  */
 	_dl_determine_tlsoffset ();
 
+    void *ktcbp = _dl_allocate_ktls_storage ();
+	if (ktcbp == NULL) {
+		_dl_debug_early("\ncannot allocate TLS data structures for initial kthread");
+		_dl_exit(30);
+	}
+
 	/* Construct the static TLS block and the dtv for the initial
 	   thread.  For some platforms this will include allocating memory
 	   for the thread descriptor.  The memory for the TLS block will
@@ -1025,11 +1068,12 @@
 
 	/* And finally install it for the main thread.  If ld.so itself uses
 	   TLS we know the thread pointer was initialized earlier.  */
-	const char *lossage = (char *)TLS_INIT_TP (tcbp, USE___THREAD);
+	const char *lossage = (char *)TLS_INIT_KTP (ktcbp, USE___THREAD);
 	if(__builtin_expect (lossage != NULL, 0)) {
 		_dl_debug_early("cannot set up thread-local storage: %s\n", lossage);
 		_dl_exit(30);
 	}
+    TLS_INIT_TP (tcbp, USE___THREAD);
 	tls_init_tp_called = true;
 
 	return tcbp;
diff -urN uClibc-0.9.33/ldso/ldso/ldso.c uClibc-0.9.33-new/ldso/ldso/ldso.c
--- uClibc-0.9.33/ldso/ldso/ldso.c	2013-09-23 20:39:09.830221904 -0400
+++ uClibc-0.9.33-new/ldso/ldso/ldso.c	2013-09-23 20:39:32.930222860 -0400
@@ -525,8 +525,8 @@
 
 #ifdef __LDSO_STANDALONE_SUPPORT__
 	if (_start == (void *) auxvt[AT_ENTRY].a_un.a_val) {
-		unsigned int *aux_dat = (unsigned int *) argv;
-		int argc = aux_dat[-1];
+		unsigned long *aux_dat = (unsigned long *) argv;
+		unsigned int argc = aux_dat[-1];
 
 		tpnt->libname = argv[0];
 		while (argc > 1)
diff -urN uClibc-0.9.33/ldso/libdl/libdl.c uClibc-0.9.33-new/ldso/libdl/libdl.c
--- uClibc-0.9.33/ldso/libdl/libdl.c	2013-09-23 20:39:09.782221899 -0400
+++ uClibc-0.9.33-new/ldso/libdl/libdl.c	2013-09-23 20:39:32.930222860 -0400
@@ -47,7 +47,7 @@
 
 /* TODO: get rid of global lock and use more finegrained locking, or
  * perhaps RCU for the global structures */
-__UCLIBC_MUTEX_STATIC(_dl_mutex, PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP);
+__UCLIBC_MUTEX_STATIC(_dl_mutex, __SCLIB_MUTEX_RECURSIVE);
 
 #ifdef SHARED
 # if defined(USE_TLS) && USE_TLS
diff -urN uClibc-0.9.33/libc/inet/getnet.c uClibc-0.9.33-new/libc/inet/getnet.c
--- uClibc-0.9.33/libc/inet/getnet.c	2013-09-23 20:39:07.946221824 -0400
+++ uClibc-0.9.33-new/libc/inet/getnet.c	2013-09-23 20:39:32.934222861 -0400
@@ -25,7 +25,7 @@
 #include "internal/parse_config.h"
 
 #include <bits/uClibc_mutex.h>
-__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP);
+__UCLIBC_MUTEX_STATIC(mylock, __SCLIB_MUTEX_RECURSIVE);
 
 #define MINTOKENS	2
 #define	MAXALIASES	8
diff -urN uClibc-0.9.33/libc/inet/getproto.c uClibc-0.9.33-new/libc/inet/getproto.c
--- uClibc-0.9.33/libc/inet/getproto.c	2013-09-23 20:39:07.958221824 -0400
+++ uClibc-0.9.33-new/libc/inet/getproto.c	2013-09-23 20:39:32.934222861 -0400
@@ -25,7 +25,7 @@
 #include "internal/parse_config.h"
 
 #include <bits/uClibc_mutex.h>
-__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP);
+__UCLIBC_MUTEX_STATIC(mylock, __SCLIB_MUTEX_RECURSIVE);
 
 #define MINTOKENS	2
 #define	MAXALIASES	8 /* will probably never be more than one */
diff -urN uClibc-0.9.33/libc/inet/getservice.c uClibc-0.9.33-new/libc/inet/getservice.c
--- uClibc-0.9.33/libc/inet/getservice.c	2013-09-23 20:39:08.026221828 -0400
+++ uClibc-0.9.33-new/libc/inet/getservice.c	2013-09-23 20:39:32.934222861 -0400
@@ -26,7 +26,7 @@
 #include "internal/parse_config.h"
 
 #include <bits/uClibc_mutex.h>
-__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP);
+__UCLIBC_MUTEX_STATIC(mylock, __SCLIB_MUTEX_RECURSIVE);
 
 #define MINTOKENS	3
 #define	MAXALIASES	8	/* we seldomly need more than 1 alias */
diff -urN uClibc-0.9.33/libc/inet/resolv.c uClibc-0.9.33-new/libc/inet/resolv.c
--- uClibc-0.9.33/libc/inet/resolv.c	2013-09-23 20:39:07.962221825 -0400
+++ uClibc-0.9.33-new/libc/inet/resolv.c	2013-09-23 20:39:32.934222861 -0400
@@ -906,7 +906,7 @@
 #define NAMESERVER_PORT_N NAMESERVER_PORT
 #endif
 
-__UCLIBC_MUTEX_INIT(__resolv_lock, PTHREAD_MUTEX_INITIALIZER);
+__UCLIBC_MUTEX_INIT(__resolv_lock, __SCLIB_MUTEX_NORMAL);
 
 /* Protected by __resolv_lock */
 void (*__res_sync)(void);
@@ -2502,7 +2502,7 @@
 
 #ifdef L_gethostent_r
 
-__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);
+__UCLIBC_MUTEX_STATIC(mylock, __SCLIB_MUTEX_NORMAL);
 
 static parser_t *hostp = NULL;
 static smallint host_stayopen;
diff -urN uClibc-0.9.33/libc/inet/rpc/create_xid.c uClibc-0.9.33-new/libc/inet/rpc/create_xid.c
--- uClibc-0.9.33/libc/inet/rpc/create_xid.c	2013-09-23 20:39:08.006221826 -0400
+++ uClibc-0.9.33-new/libc/inet/rpc/create_xid.c	2013-09-23 20:39:32.938222861 -0400
@@ -29,7 +29,7 @@
 /* The RPC code is not threadsafe, but new code should be threadsafe. */
 
 #include <bits/uClibc_mutex.h>
-__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);
+__UCLIBC_MUTEX_STATIC(mylock, __SCLIB_MUTEX_NORMAL);
 
 static smallint is_initialized;
 static struct drand48_data __rpc_lrand48_data;
diff -urN uClibc-0.9.33/libc/inet/rpc/getrpcent.c uClibc-0.9.33-new/libc/inet/rpc/getrpcent.c
--- uClibc-0.9.33/libc/inet/rpc/getrpcent.c	2013-09-23 20:39:08.006221826 -0400
+++ uClibc-0.9.33-new/libc/inet/rpc/getrpcent.c	2013-09-23 20:39:32.938222861 -0400
@@ -258,7 +258,7 @@
 #if defined(__UCLIBC_HAS_REENTRANT_RPC__)
 
 #include <bits/uClibc_mutex.h>
-__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);
+__UCLIBC_MUTEX_STATIC(mylock, __SCLIB_MUTEX_NORMAL);
 
 
 static int __copy_rpcent(struct rpcent *r, struct rpcent *result_buf, char *buffer,
diff -urN uClibc-0.9.33/libc/inet/socketcalls.c uClibc-0.9.33-new/libc/inet/socketcalls.c
--- uClibc-0.9.33/libc/inet/socketcalls.c	2013-09-23 20:39:07.962221825 -0400
+++ uClibc-0.9.33-new/libc/inet/socketcalls.c	2013-09-23 20:39:32.938222861 -0400
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
@@ -9,6 +10,12 @@
 #include <errno.h>
 #include <syscall.h>
 #include <sys/socket.h>
+#include <string.h>
+
+#include <bits/sclib.h>
+#include <bits/sclib_syscalls.h>
+
+#define MAX_SOCKADDR_LEN	(1024 * 4096)
 
 #ifdef __NR_socketcall
 extern int __socketcall(int call, unsigned long *args) attribute_hidden;
@@ -44,9 +51,52 @@
 #ifdef L_accept
 extern __typeof(accept) __libc_accept;
 #ifdef __NR_accept
-#define __NR___sys_accept  __NR_accept
-static
-_syscall3(int, __sys_accept, int, call, struct sockaddr *, addr, socklen_t *,addrlen)
+static int __sys_accept(int fd, struct sockaddr *addr, socklen_t *addrlen)
+{
+	int sysid;
+	long new_fd, new_dfd, dfd;
+
+	dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+	SCLIB_ERR_RET(dfd);
+	new_fd = sclib_file_add(&sclib_file, 0);
+	SCLIB_VAL_RET(new_fd, new_dfd);
+
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		size_t len = MAX_SOCKADDR_LEN;
+		syscall_udw_t dwret;
+		void *mem = mem, *raddr = NULL;
+
+		if (addr != NULL) {
+			if ((size_t) *addrlen < len)
+				len = *addrlen;
+			mem = sclib_memory_alloc(&sclib_data[sysid], len);
+			SCLIB_MEM_RET(mem, new_dfd);
+			raddr = sclib_mem(sysid, mem);
+		}
+		/* len is both input and output (upper word) */
+		dwret = SCLIB_REMOTE_CALL_DW(sysid, accept, 3, dfd, len, raddr);
+		new_dfd = syscall_result_lower(dwret);
+		if (addr != NULL) {
+			if (!SCLIB_IS_ERR(new_dfd)) {
+				size_t retlen = syscall_result_upper(dwret);
+				memcpy(addr, mem, MIN(len, retlen));
+				*addrlen = retlen;
+			}
+			sclib_memory_free(&sclib_data[sysid], mem);
+		}
+	} else {
+		new_dfd = SCLIB_LOCAL_CALL(accept, 3, dfd, addr, addrlen);
+	}
+
+error_mem:
+	sclib_file_add_done(&sclib_file, new_fd, new_dfd, sysid, 0, 0);
+error_val:
+	sclib_file_put(&sclib_file, fd);
+
+	SCLIB_ERR_RET(new_dfd);
+	return new_fd;
+}
+
 int __libc_accept(int s, struct sockaddr *addr, socklen_t * addrlen)
 {
 	if (SINGLE_THREAD_P)
@@ -85,8 +135,58 @@
 
 #ifdef L_accept4
 #ifdef __NR_accept4
-# define __NR___sys_accept4  __NR_accept4
-static _syscall4(int, __sys_accept4, int, fd, struct sockaddr *, addr, socklen_t *, addrlen, int, flags)
+static int __sys_accept4(int fd, struct sockaddr *addr, socklen_t *addrlen,
+						 int flags)
+{
+	int sysid;
+	long new_fd, new_dfd, dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	SCLIB_ERR_RET(dfd);
+	new_fd = sclib_file_add(&sclib_file, 0);
+	SCLIB_VAL_RET(new_fd, new_dfd);
+
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		size_t len = MAX_SOCKADDR_LEN;
+		syscall_udw_t dwret;
+		void *mem = mem, *raddr = NULL;
+
+		if (addr != NULL) {
+			if ((size_t) *addrlen < len)
+				len = *addrlen;
+			mem = sclib_memory_alloc(&sclib_data[sysid], len);
+			SCLIB_MEM_RET(mem, new_dfd);
+			raddr = sclib_mem(sysid, mem);
+		}
+		dwret = SCLIB_REMOTE_CALL_DW(sysid, accept4, 4, dfd, len, raddr, flags);
+		new_dfd = syscall_result_lower(dwret);
+		if (addr != NULL) {
+			if (!SCLIB_IS_ERR(new_dfd)) {
+				size_t retlen = syscall_result_upper(dwret);
+				memcpy(addr, mem, MIN(len, retlen));
+				*addrlen = retlen;
+			}
+			sclib_memory_free(&sclib_data[sysid], mem);
+		}
+	} else {
+		new_dfd = SCLIB_LOCAL_CALL(accept4, 4, dfd, addr, addrlen, flags);
+	}
+
+error_mem:
+	if (SCLIB_IS_ERR(new_dfd)) {
+		sclib_file_add_fail(&sclib_file, new_fd);
+	} else {
+		uint8_t new_dfd_flags = 0;
+		if (flags & SOCK_CLOEXEC)
+			new_dfd_flags |= SCLIB_FD_EXEC;
+		sclib_file_add_ok(&sclib_file, new_fd, new_dfd, sysid, new_dfd_flags, 0);
+	}
+error_val:
+	sclib_file_put(&sclib_file, fd);
+
+	SCLIB_ERR_RET(new_dfd);
+	return new_fd;
+}
+
 int accept4(int fd, struct sockaddr *addr, socklen_t * addrlen, int flags)
 {
 	if (SINGLE_THREAD_P)
@@ -125,7 +225,29 @@
 
 #ifdef L_bind
 #ifdef __NR_bind
-_syscall3(int, bind, int, sockfd, const struct sockaddr *, myaddr, socklen_t, addrlen)
+int bind(int fd, const struct sockaddr *myaddr, socklen_t addrlen)
+{
+	int sysid;
+	long err, dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	SCLIB_ERR_RET(dfd);
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		void *mem = sclib_memory_alloc(&sclib_data[sysid], addrlen);
+
+		SCLIB_MEM_RET(mem, err);
+		mem = memcpy(mem, myaddr, addrlen);
+		err = SCLIB_REMOTE_CALL(sysid, bind, 3, dfd, sclib_mem(sysid, mem), addrlen);
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		err = SCLIB_LOCAL_CALL(bind, 3, dfd, myaddr, addrlen);
+	}
+
+error_mem:
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(err);
+	return err;
+}
+
 #elif defined(__NR_socketcall)
 int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen)
 {
@@ -143,9 +265,31 @@
 #ifdef L_connect
 extern __typeof(connect) __libc_connect;
 #ifdef __NR_connect
-#define __NR___sys_connect __NR_connect
-static
-_syscall3(int, __sys_connect, int, sockfd, const struct sockaddr *, saddr, socklen_t, addrlen)
+static int __sys_connect(int fd, const struct sockaddr *saddr, socklen_t addrlen)
+{
+	int sysid;
+	long err, dfd;
+
+	dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+	SCLIB_ERR_RET(dfd);
+
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		void *mem = sclib_memory_alloc(&sclib_data[sysid], addrlen);
+
+		SCLIB_MEM_RET(mem, err);
+		mem = memcpy(mem, saddr, addrlen);
+		err = SCLIB_REMOTE_CALL(sysid, connect, 3, dfd, sclib_mem(sysid, mem), addrlen);
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		err = SCLIB_LOCAL_CALL(connect, 3, dfd, saddr, addrlen);
+	}
+
+error_mem:
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(err);
+	return err;
+}
+
 int __libc_connect(int sockfd, const struct sockaddr *saddr, socklen_t addrlen)
 {
 	if (SINGLE_THREAD_P)
@@ -184,7 +328,39 @@
 
 #ifdef L_getpeername
 #ifdef __NR_getpeername
-_syscall3(int, getpeername, int, sockfd, struct sockaddr *, addr, socklen_t *,paddrlen)
+
+int getpeername(int fd, struct sockaddr *addr, socklen_t *addrlen)
+{
+	int sysid;
+	long err, dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	SCLIB_ERR_RET(dfd);
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		size_t len = MAX_SOCKADDR_LEN;
+		syscall_udw_t dwret;
+		void *mem;
+
+		if ((size_t) *addrlen < len)
+			len = *addrlen;
+		mem = sclib_memory_alloc(&sclib_data[sysid], len);
+		SCLIB_MEM_RET(mem, err);
+		dwret = SCLIB_REMOTE_CALL_DW(sysid, getpeername, 3, dfd, len, sclib_mem(sysid, mem));
+		err = syscall_result_lower(dwret);
+		if (!SCLIB_IS_ERR(err)) {
+			size_t retlen = syscall_result_upper(dwret);
+			memcpy(addr, mem, MIN(len, retlen));
+			*addrlen = retlen;
+		}
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		err = SCLIB_LOCAL_CALL(getpeername, 3, dfd, addr, addrlen);
+	}
+
+error_mem:
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(err);
+	return err;
+}
 #elif defined(__NR_socketcall)
 int getpeername(int sockfd, struct sockaddr *addr, socklen_t * paddrlen)
 {
@@ -200,7 +376,39 @@
 
 #ifdef L_getsockname
 #ifdef __NR_getsockname
-_syscall3(int, getsockname, int, sockfd, struct sockaddr *, addr, socklen_t *,paddrlen)
+int getsockname(int fd, struct sockaddr *addr, socklen_t *addrlen)
+{
+	int sysid;
+	long err, dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	SCLIB_ERR_RET(dfd);
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		size_t len = MAX_SOCKADDR_LEN;
+		syscall_udw_t dwret;
+		void *mem;
+
+		if ((size_t) *addrlen < len)
+			len = *addrlen;
+		mem = sclib_memory_alloc(&sclib_data[sysid], len);
+		SCLIB_MEM_RET(mem, err);
+		dwret = SCLIB_REMOTE_CALL_DW(sysid, getsockname, 3, dfd, len, sclib_mem(sysid, mem));
+		err = syscall_result_lower(dwret);
+		if (!SCLIB_IS_ERR(err)) {
+			size_t retlen = syscall_result_upper(dwret);
+			memcpy(addr, mem, MIN(len, retlen));
+			*addrlen = retlen;
+		}
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		err = SCLIB_LOCAL_CALL(getsockname, 3, dfd, addr, addrlen);
+	}
+
+error_mem:
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(err);
+	return err;
+}
+
 #elif defined(__NR_socketcall)
 int getsockname(int sockfd, struct sockaddr *addr, socklen_t * paddrlen)
 {
@@ -217,7 +425,41 @@
 
 #ifdef L_getsockopt
 #ifdef __NR_getsockopt
-_syscall5(int, getsockopt, int, fd, int, level, int, optname, __ptr_t, optval, socklen_t *, optlen)
+int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen)
+{
+	int sysid;
+	long err, dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	SCLIB_ERR_RET(dfd);
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		size_t len = *optlen;
+		syscall_udw_t dwret;
+		void *mem;
+
+		if ((size_t) *optlen < len)
+			len = *optlen;
+		mem = sclib_memory_alloc(&sclib_data[sysid], len);
+		SCLIB_MEM_RET(mem, err);
+		dwret = SCLIB_REMOTE_CALL_DW(sysid, getsockopt, 5, dfd, len, optname,
+									sclib_mem(sysid, mem), level);
+		err = syscall_result_lower(dwret);
+		if (!SCLIB_IS_ERR(err)) {
+			size_t retlen = syscall_result_upper(dwret);
+			memcpy(optval, mem, MIN(len, retlen));
+			*optlen = retlen;
+		}
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		err = SCLIB_LOCAL_CALL(getsockopt, 5, dfd, level, optname, optval, optlen);
+	}
+
+error_mem:
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(err);
+	return err;
+
+}
+
 #elif defined(__NR_socketcall)
 int getsockopt(int fd, int level, int optname, __ptr_t optval,
 		   socklen_t * optlen)
@@ -236,7 +478,19 @@
 
 #ifdef L_listen
 #ifdef __NR_listen
-_syscall2(int, listen, int, sockfd, int, backlog)
+
+int listen(int fd, int backlog)
+{
+	int sysid;
+	long err, dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	SCLIB_ERR_RET(dfd);
+	err = SCLIB_SYSID_CALL(sysid, listen, 2, dfd, backlog);
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(err);
+	return err;
+}
+
 #elif defined(__NR_socketcall)
 int listen(int sockfd, int backlog)
 {
@@ -303,10 +557,67 @@
 #ifdef L_recvfrom
 extern __typeof(recvfrom) __libc_recvfrom;
 #ifdef __NR_recvfrom
-#define __NR___sys_recvfrom __NR_recvfrom
-static
-_syscall6(ssize_t, __sys_recvfrom, int, sockfd, __ptr_t, buffer, size_t, len,
-	int, flags, struct sockaddr *, to, socklen_t *, tolen)
+static ssize_t __sys_recvfrom(int fd, void *buffer, size_t len, int flags,
+				struct sockaddr *to, socklen_t *tolen)
+{
+	int sysid;
+	size_t size;
+	long dfd;
+
+	dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+	SCLIB_ERR_RET(dfd);
+
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		size_t inlen = 0;
+		size_t ret, chunk = MIN(len, SCLIB_MAX_BUFFER);
+		syscall_udw_t dwret;
+		void *mem, *rbuffer, *rto = NULL;
+
+		if (to != NULL) {
+			inlen = MAX_SOCKADDR_LEN;
+			if ((size_t) *tolen < inlen)
+				inlen = *tolen;
+		}
+		mem = sclib_memory_alloc(&sclib_data[sysid], chunk + inlen);
+		SCLIB_MEM_RET(mem, size);
+		size = 0;
+		rbuffer = sclib_mem(sysid, mem);
+		if (to != NULL)
+			rto = (struct sockaddr *) ((char *) rbuffer + chunk);
+
+		for (; len > chunk; len -= chunk) {
+			ret = SCLIB_REMOTE_CALL(sysid, recvfrom, 6, dfd, 0, chunk, flags,
+									NULL, rbuffer);
+			SCLIB_VAL_RET(ret, size);
+			size += ret;
+			buffer = mempcpy(buffer, mem, ret);
+			if (unlikely(ret < chunk))
+				goto error_val;
+		}
+		dwret = SCLIB_REMOTE_CALL_DW(sysid, recvfrom, 6, dfd, inlen, len, flags,
+									 rto, rbuffer);
+		ret = syscall_result_lower(dwret);
+		SCLIB_VAL_RET(ret, size);
+		if (to != NULL) {
+			size_t retlen = syscall_result_upper(dwret);
+			memcpy(to, mem + len, MIN(inlen, retlen));
+			*tolen = retlen;
+		}
+		size += ret;
+		memcpy(buffer, mem, ret);
+
+error_val:
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		size = SCLIB_LOCAL_CALL(recvfrom, 6, dfd, buffer, len, flags, to, tolen);
+	}
+
+error_mem:
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(size);
+	return size;
+}
+
 ssize_t __libc_recvfrom(int sockfd, __ptr_t buffer, size_t len, int flags,
 		 struct sockaddr *to, socklen_t * tolen)
 {
@@ -352,9 +663,76 @@
 #ifdef L_recvmsg
 extern __typeof(recvmsg) __libc_recvmsg;
 #ifdef __NR_recvmsg
-#define __NR___sys_recvmsg __NR_recvmsg
-static
-_syscall3(ssize_t, __sys_recvmsg, int, sockfd, struct msghdr *, msg, int, flags)
+
+static ssize_t __sys_recvmsg(int fd, struct msghdr *msg, int flags)
+{
+	int sysid;
+	long size, dfd;
+
+	dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+	SCLIB_ERR_RET(dfd);
+
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		size_t total_iovlen;
+		struct msghdr *mem, *rmsg;
+
+		total_iovlen = sclib_iovec_length(msg->msg_iov, msg->msg_iovlen);
+		SCLIB_VAL_RET(total_iovlen, size);
+		if (msg->msg_namelen > MAX_SOCKADDR_LEN)
+			msg->msg_namelen = MAX_SOCKADDR_LEN;
+		if (msg->msg_controllen > MAX_SOCKADDR_LEN)
+			msg->msg_controllen = MAX_SOCKADDR_LEN;
+		mem = sclib_memory_alloc(&sclib_data[sysid], sizeof(struct msghdr) +
+			   sizeof(struct iovec) + total_iovlen +
+			   msg->msg_controllen + msg->msg_namelen);
+		SCLIB_MEM_RET(mem, size);
+		rmsg = sclib_init_msghdr(mem, msg, total_iovlen, sclib_mem(sysid, mem));
+		size = SCLIB_REMOTE_CALL(sysid, recvmsg, 3, dfd, rmsg, flags);
+		if (!SCLIB_IS_ERR(size)) {
+			sclib_copy_to_msghdr(msg, mem, size, total_iovlen,
+								 mem->msg_controllen, mem->msg_namelen);
+		}
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		size = SCLIB_LOCAL_CALL(recvmsg, 3, dfd, msg, flags);
+		if (!SCLIB_IS_ERR(size) && msg->msg_controllen >= CMSG_SPACE(sizeof(int))) {
+			struct cmsghdr *cmsg = (struct cmsghdr *) msg->msg_control;
+
+			/* Convert file descriptors */
+			if (cmsg->cmsg_level == SOL_SOCKET && cmsg->cmsg_type == SCM_RIGHTS) {
+				int *fds = (int *) CMSG_DATA(cmsg);
+				size_t i, n;
+
+				n = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr))) / sizeof(int);
+				for (i = 0; i != n; i++) {
+					long mfd;
+					mfd = sclib_file_add(&sclib_file, 0);
+					if (mfd < 0) {
+						size = mfd;
+						while (n != i) { /* Rollback remaining files */
+							--n;
+							SCLIB_LOCAL_CALL(close, 1, fds[n]);
+						}
+						while (i != 0) { /* Rollback added file */
+							--i;
+							__internal_sys_close(fds[i]);
+						}
+						goto error_val;
+					}
+					sclib_file_add_ok(&sclib_file, mfd, fds[i], SYSCALL_SYSID_LOCAL, 0, 0);
+					fds[i] = mfd;
+				}
+			}
+		}
+	}
+
+error_mem:
+error_val:
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(size);
+	return size;
+}
+
 ssize_t __libc_recvmsg(int sockfd, struct msghdr *msg, int flags)
 {
 	if (SINGLE_THREAD_P)
@@ -444,9 +822,78 @@
 #ifdef L_sendmsg
 extern __typeof(sendmsg) __libc_sendmsg;
 #ifdef __NR_sendmsg
-#define __NR___sys_sendmsg __NR_sendmsg
-static
-_syscall3(ssize_t, __sys_sendmsg, int, sockfd, const struct msghdr *, msg, int, flags)
+
+static ssize_t __sys_sendmsg(int fd, const struct msghdr *msg, int flags)
+{
+	int sysid;
+	long size, dfd;
+
+	dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+	SCLIB_ERR_RET(dfd);
+
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		size_t total_iovlen;
+		struct msghdr *mem, *rmsg;
+
+		total_iovlen = sclib_iovec_length(msg->msg_iov, msg->msg_iovlen);
+		SCLIB_VAL_RET(total_iovlen, size);
+		mem = sclib_memory_alloc(&sclib_data[sysid], sizeof(struct msghdr) +
+				sizeof(struct iovec) + total_iovlen +
+				msg->msg_controllen + msg->msg_namelen);
+		SCLIB_MEM_RET(mem, size);
+		rmsg = sclib_init_msghdr(mem, msg, total_iovlen, sclib_mem(sysid, mem));
+		sclib_copy_from_msghdr(mem, msg, total_iovlen);
+		size = SCLIB_REMOTE_CALL(sysid, sendmsg, 3, dfd, rmsg, flags);
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		struct msghdr *nmsg = (struct msghdr *) msg;
+		const int *fds = NULL;
+		int *nfds;
+		size_t i = 0, n;
+
+		if (msg->msg_controllen >= CMSG_SPACE(sizeof(int))) {
+			const struct cmsghdr *cmsg = (const struct cmsghdr *) msg->msg_control;
+			struct cmsghdr *ncmsg;
+
+			/* Convert file descriptors */
+			if (cmsg->cmsg_level == SOL_SOCKET && cmsg->cmsg_type == SCM_RIGHTS) {
+				nmsg = (struct msghdr *) malloc(sizeof(struct msghdr) + msg->msg_controllen);
+				SCLIB_MEM_RET(nmsg, size);
+				memcpy(nmsg, msg, sizeof(struct msghdr));
+				ncmsg = (struct cmsghdr *) (nmsg + 1);
+				nmsg->msg_control = ncmsg;
+				memcpy(ncmsg, cmsg, sizeof(struct cmsghdr));
+				fds = (const int *) CMSG_DATA(cmsg);
+				nfds = (int *) CMSG_DATA(ncmsg);
+				n = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr))) / sizeof(int);
+				for (; i != n; i++) {
+					long mdfd;
+					int msysid;
+					mdfd = sclib_file_getid(&sclib_file, fds[i], &msysid);
+					if (mdfd < 0 || msysid != SYSCALL_SYSID_LOCAL) {
+						size = -EINVAL;
+						goto error_conv;
+					}
+					nfds[i] = mdfd;
+				}
+			}
+		}
+		size = SCLIB_LOCAL_CALL(sendmsg, 3, dfd, nmsg, flags);
+		if (fds != NULL) {
+error_conv:
+			while (i != 0)
+				sclib_file_put(&sclib_file, fds[--i]);
+			free(nmsg);
+		}
+	}
+
+error_mem:
+error_val:
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(size);
+	return size;
+}
+
 ssize_t __libc_sendmsg(int sockfd, const struct msghdr *msg, int flags)
 {
 	if (SINGLE_THREAD_P)
@@ -486,10 +933,55 @@
 #ifdef L_sendto
 extern __typeof(sendto) __libc_sendto;
 #ifdef __NR_sendto
-#define __NR___sys_sendto  __NR_sendto
-static
-_syscall6(ssize_t, __sys_sendto, int, sockfd, const void *, buffer,
-	size_t, len, int, flags, const struct sockaddr *, to, socklen_t, tolen)
+static ssize_t __sys_sendto(int fd, const void *buffer, size_t len, int flags,
+							const struct sockaddr *to, socklen_t tolen)
+{
+	int sysid;
+	size_t size;
+	long dfd;
+
+	dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+	SCLIB_ERR_RET(dfd);
+
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		size_t ret, chunk = MIN(len, SCLIB_MAX_BUFFER);
+		void *rto = NULL;
+		void *rbuffer, *mem = sclib_memory_alloc(&sclib_data[sysid], chunk + tolen);
+
+		SCLIB_MEM_RET(mem, size);
+		size = 0;
+		rbuffer = sclib_mem(sysid, mem);
+		if (to != NULL && tolen != 0)
+			rto = sclib_mem(sysid, memcpy(mem + chunk, to, tolen));
+
+		for (; len > chunk; len -= chunk) {
+			memcpy(mem, buffer, chunk);
+			buffer += chunk;
+			ret = SCLIB_REMOTE_CALL(sysid, sendto, 6, dfd, tolen, chunk,
+									flags | MSG_MORE, rto, rbuffer);
+			SCLIB_VAL_RET(ret, size);
+			size += ret;
+			if (unlikely(ret < chunk))
+				goto error_val;
+		}
+		memcpy(mem, buffer, len);
+		ret = SCLIB_REMOTE_CALL(sysid, sendto, 6, dfd, tolen, len, flags,
+								rto, rbuffer);
+		SCLIB_VAL_RET(ret, size);
+		size += ret;
+
+error_val:
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		size = SCLIB_LOCAL_CALL(sendto, 6, dfd, buffer, len, flags, to, tolen);
+	}
+
+error_mem:
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(size);
+	return size;
+}
+
 ssize_t __libc_sendto(int sockfd, const void *buffer, size_t len, int flags,const struct sockaddr *to, socklen_t tolen)
 {
 	if (SINGLE_THREAD_P)
@@ -533,7 +1025,35 @@
 
 #ifdef L_setsockopt
 #ifdef __NR_setsockopt
-_syscall5(int, setsockopt, int, fd, int, level, int, optname, const void *, optval, socklen_t, optlen)
+
+int setsockopt(int fd, int level, int optname, const void *optval,
+			   socklen_t len)
+{
+	int sysid;
+	long err, dfd;
+
+	dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+	SCLIB_ERR_RET(dfd);
+
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		void *mem;
+
+		mem = sclib_memory_alloc(&sclib_data[sysid], len);
+		SCLIB_MEM_RET(mem, err);
+		mem = memcpy(mem, optval, len);
+		err = SCLIB_REMOTE_CALL(sysid, setsockopt, 5, dfd, len, optname,
+								sclib_mem(sysid, mem), level);
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		err = SCLIB_LOCAL_CALL(setsockopt, 5, dfd, level, optname, optval, len);
+	}
+
+error_mem:
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(err);
+	return err;
+}
+
 #elif defined(__NR_socketcall)
 /* [sg]etsockoptions by bir7@leland.stanford.edu */
 int setsockopt(int fd, int level, int optname, const void *optval,
@@ -554,7 +1074,18 @@
 
 #ifdef L_shutdown
 #ifdef __NR_shutdown
-_syscall2(int, shutdown, int, sockfd, int, how)
+int shutdown(int fd, int how)
+{
+	int sysid;
+	long err, dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	SCLIB_ERR_RET(dfd);
+	err = SCLIB_SYSID_CALL(sysid, shutdown, 2, dfd, how);
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(err);
+	return err;
+}
+
 #elif defined(__NR_socketcall)
 /* shutdown by bir7@leland.stanford.edu */
 int shutdown(int sockfd, int how)
@@ -570,7 +1101,26 @@
 
 #ifdef L_socket
 #ifdef __NR_socket
-_syscall3(int, socket, int, family, int, type, int, protocol)
+int socket(int family, int type, int protocol)
+{
+	int sysid;
+	long dfd, fd = sclib_file_add(&sclib_file, 0);
+
+	SCLIB_ERR_RET(fd);
+	sysid = (family != AF_UNIX) ? SYSCALL_SYSID_NETWORK : SYSCALL_SYSID_LOCAL;
+	dfd = SCLIB_SYSID_CALL(sysid, socket, 3, family, type, protocol);
+	if (SCLIB_IS_ERR(dfd)) {
+		sclib_file_add_fail(&sclib_file, fd);
+	} else {
+		uint8_t dfd_flags = 0;
+		if (type & SOCK_CLOEXEC)
+			dfd_flags |= SCLIB_FD_EXEC;
+		sclib_file_add_ok(&sclib_file, fd, dfd, sysid, dfd_flags, 0);
+	}
+	SCLIB_ERR_RET(dfd);
+	return fd;
+}
+
 #elif defined(__NR_socketcall)
 int socket(int family, int type, int protocol)
 {
@@ -587,7 +1137,43 @@
 
 #ifdef L_socketpair
 #ifdef __NR_socketpair
-_syscall4(int, socketpair, int, family, int, type, int, protocol, int *, sockvec)
+int socketpair(int family, int type, int protocol, int fd[2])
+{
+	long ret;
+	uint8_t lfd_flags;
+	int lfd[2];
+
+	/* It supposed to work only with AF_UNIX on Linux */
+	ret = sclib_file_add(&sclib_file, 0);
+	if (SCLIB_IS_ERR(ret))
+		goto lfd_err2;
+	fd[0] = ret;
+	ret = sclib_file_add(&sclib_file, 0);
+	if (SCLIB_IS_ERR(ret))
+		goto lfd_err1;
+	fd[1] = ret;
+	ret = SCLIB_LOCAL_CALL(socketpair, 4, family, type, protocol, lfd);
+	if (SCLIB_IS_ERR(ret)) {
+		sclib_file_add_fail(&sclib_file, fd[1]);
+	} else {
+		lfd_flags = 0;
+		if (type & SOCK_CLOEXEC)
+			lfd_flags |= SCLIB_FD_EXEC;
+		sclib_file_add_ok(&sclib_file, fd[1], lfd[1], SYSCALL_SYSID_LOCAL, lfd_flags, 0);
+	}
+lfd_err1:
+	if (SCLIB_IS_ERR(ret)) {
+		sclib_file_add_fail(&sclib_file, fd[0]);
+	} else {
+		lfd_flags = 0;
+		if (type & SOCK_CLOEXEC)
+			lfd_flags |= SCLIB_FD_EXEC;
+		sclib_file_add_ok(&sclib_file, fd[0], lfd[0], SYSCALL_SYSID_LOCAL, lfd_flags, 0);
+	}
+lfd_err2:
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 #elif defined(__NR_socketcall)
 int socketpair(int family, int type, int protocol, int sockvec[2])
 {
diff -urN uClibc-0.9.33/libc/misc/internals/__uClibc_main.c uClibc-0.9.33-new/libc/misc/internals/__uClibc_main.c
--- uClibc-0.9.33/libc/misc/internals/__uClibc_main.c	2013-09-23 20:39:07.622221812 -0400
+++ uClibc-0.9.33-new/libc/misc/internals/__uClibc_main.c	2013-09-23 20:39:32.938222861 -0400
@@ -40,6 +40,8 @@
 #include <pthread.h>
 #endif 
 
+#include <bits/sclib.h>
+
 #ifndef SHARED
 void *__libc_stack_end = NULL;
 
@@ -76,6 +78,42 @@
 weak_alias (__pthread_return_0, __pthread_mutex_lock)
 weak_alias (__pthread_return_0, __pthread_mutex_trylock)
 weak_alias (__pthread_return_0, __pthread_mutex_unlock)
+weak_alias (__pthread_return_0, __pthread_mutex_reinit)
+
+static long __sclib_futex_return_0 (int *ptr, int val) { return 0; }
+weak_alias(__sclib_futex_return_0, __sclib_futex_wait)
+weak_alias(__sclib_futex_return_0, __sclib_futex_wake)
+
+struct __sclib_mutex_auto;
+
+static long __sclib_mutex_auto_return_0 (struct __sclib_mutex_auto *mutex)
+{
+	return 0;
+}
+
+weak_alias(__sclib_mutex_auto_return_0, __sclib_mutex_auto_reinit);
+weak_alias(__sclib_mutex_auto_return_0, __sclib_mutex_auto_lock);
+weak_alias(__sclib_mutex_auto_return_0, __sclib_mutex_auto_trylock);
+weak_alias(__sclib_mutex_auto_return_0, __sclib_mutex_auto_unlock); 
+
+long weak_function
+__sclib_mutex_auto_init(struct __sclib_mutex_auto *mutex, int kind)
+{
+	return 0;
+}
+
+void weak_function
+__sclib_mutex_auto_destroy (struct __sclib_mutex_auto *mutex)
+{
+}
+
+struct syscall_entry;
+
+void weak_function
+__sclib_schedule(int sysid, struct syscall_entry *entry)
+{
+	sclib_schedule_single(sysid, entry);
+}
 
 int weak_function
 __pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)
@@ -124,9 +162,9 @@
 #endif
 #ifdef __UCLIBC_HAS_THREADS__
 #if !defined (__UCLIBC_HAS_THREADS_NATIVE__) || defined (SHARED)
-extern void weak_function __pthread_initialize_minimal(void);
+extern void weak_function __pthread_initialize_minimal(struct syscall_queue *);
 #else
-extern void __pthread_initialize_minimal(void);
+extern void __pthread_initialize_minimal(struct syscall_queue *);
 #endif
 #endif
 
@@ -234,6 +272,8 @@
      * better than  malloc using __pagesize=0 for atexit, ctors, etc.  */
     __pagesize = PAGE_SIZE;
 
+	sclib_init_minimal();	
+
 #ifdef __UCLIBC_HAS_THREADS__
     /* Before we start initializing uClibc we have to call
      * __pthread_initialize_minimal so we can use pthread_locks
@@ -242,7 +282,7 @@
 #if !defined (__UCLIBC_HAS_THREADS_NATIVE__) || defined (SHARED)
     if (likely(__pthread_initialize_minimal!=NULL))
 #endif
-	__pthread_initialize_minimal();
+	__pthread_initialize_minimal(sclib_rqueue);
 #endif
 
 #ifndef SHARED
@@ -260,6 +300,9 @@
 # endif
 #endif
 
+	/* Initialize sclib right after pthreads */
+	sclib_init();
+
 #ifdef __UCLIBC_HAS_LOCALE__
     /* Initialize the global locale structure. */
     if (likely(not_null_ptr(_locale_init)))
@@ -274,7 +317,6 @@
      */
     if (likely(not_null_ptr(_stdio_init)))
 	_stdio_init();
-
 }
 libc_hidden_def(__uClibc_init)
 
@@ -487,6 +529,10 @@
 	}
 	else
 	{
+		/* We still need thread-local data for this. */
+//		sclib_efds_close();
+		sclib_memory_prealloc_exit();
+
 		/* Remove the thread-local data.  */
 # ifdef SHARED
 		__libc_pthread_functions.ptr__nptl_deallocate_tsd ();
diff -urN uClibc-0.9.33/libc/misc/mntent/mntent.c uClibc-0.9.33-new/libc/misc/mntent/mntent.c
--- uClibc-0.9.33/libc/misc/mntent/mntent.c	2013-09-23 20:39:07.630221811 -0400
+++ uClibc-0.9.33-new/libc/misc/mntent/mntent.c	2013-09-23 20:39:32.938222861 -0400
@@ -10,7 +10,7 @@
 #include <mntent.h>
 #include <bits/uClibc_mutex.h>
 
-__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);
+__UCLIBC_MUTEX_STATIC(mylock, __SCLIB_MUTEX_NORMAL);
 
 
 
diff -urN uClibc-0.9.33/libc/misc/syslog/syslog.c uClibc-0.9.33-new/libc/misc/syslog/syslog.c
--- uClibc-0.9.33/libc/misc/syslog/syslog.c	2013-09-23 20:39:07.726221815 -0400
+++ uClibc-0.9.33-new/libc/misc/syslog/syslog.c	2013-09-23 20:39:32.942222861 -0400
@@ -82,7 +82,7 @@
 
 #include <bits/uClibc_mutex.h>
 
-__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);
+__UCLIBC_MUTEX_STATIC(mylock, __SCLIB_MUTEX_NORMAL);
 
 
 /* !glibc_compat: glibc uses argv[0] by default
diff -urN uClibc-0.9.33/libc/misc/time/time.c uClibc-0.9.33-new/libc/misc/time/time.c
--- uClibc-0.9.33/libc/misc/time/time.c	2013-09-23 20:39:07.674221813 -0400
+++ uClibc-0.9.33-new/libc/misc/time/time.c	2013-09-23 20:39:32.942222861 -0400
@@ -1727,7 +1727,7 @@
 long timezone = 0;
 char *tzname[2] = { (char *) UTC, (char *) (UTC-1) };
 
-__UCLIBC_MUTEX_INIT(_time_tzlock, PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP);
+__UCLIBC_MUTEX_INIT(_time_tzlock, __SCLIB_MUTEX_RECURSIVE);
 
 rule_struct _time_tzinfo[2];
 
diff -urN uClibc-0.9.33/libc/misc/utmp/utent.c uClibc-0.9.33-new/libc/misc/utmp/utent.c
--- uClibc-0.9.33/libc/misc/utmp/utent.c	2013-09-23 20:39:07.582221807 -0400
+++ uClibc-0.9.33-new/libc/misc/utmp/utent.c	2013-09-23 20:39:32.942222861 -0400
@@ -22,7 +22,7 @@
 #include <not-cancel.h>
 
 #include <bits/uClibc_mutex.h>
-__UCLIBC_MUTEX_STATIC(utmplock, PTHREAD_MUTEX_INITIALIZER);
+__UCLIBC_MUTEX_STATIC(utmplock, __SCLIB_MUTEX_NORMAL);
 
 
 /* Do not create extra unlocked functions if no locking is needed */
diff -urN uClibc-0.9.33/libc/pwd_grp/lckpwdf.c uClibc-0.9.33-new/libc/pwd_grp/lckpwdf.c
--- uClibc-0.9.33/libc/pwd_grp/lckpwdf.c	2013-09-23 20:39:07.926221822 -0400
+++ uClibc-0.9.33-new/libc/pwd_grp/lckpwdf.c	2013-09-23 20:39:32.942222861 -0400
@@ -36,7 +36,7 @@
 
 /* Prevent problems in multithreaded program by using mutex.  */
 #include <bits/uClibc_mutex.h>
-__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);
+__UCLIBC_MUTEX_STATIC(mylock, __SCLIB_MUTEX_NORMAL);
 
 /* Prototypes for local functions.  */
 static void noop_handler (int __sig);
diff -urN uClibc-0.9.33/libc/pwd_grp/pwd_grp.c uClibc-0.9.33-new/libc/pwd_grp/pwd_grp.c
--- uClibc-0.9.33/libc/pwd_grp/pwd_grp.c	2013-09-23 20:39:07.926221822 -0400
+++ uClibc-0.9.33-new/libc/pwd_grp/pwd_grp.c	2013-09-23 20:39:32.942222861 -0400
@@ -417,7 +417,7 @@
 /**********************************************************************/
 
 #ifdef L_getpwent_r
-__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);
+__UCLIBC_MUTEX_STATIC(mylock, __SCLIB_MUTEX_NORMAL);
 
 static FILE *pwf /*= NULL*/;
 
@@ -474,7 +474,7 @@
 #endif
 /**********************************************************************/
 #ifdef L_getgrent_r
-__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);
+__UCLIBC_MUTEX_STATIC(mylock, __SCLIB_MUTEX_NORMAL);
 
 static FILE *grf /*= NULL*/;
 
@@ -530,7 +530,7 @@
 #endif
 /**********************************************************************/
 #ifdef L_getspent_r
-__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);
+__UCLIBC_MUTEX_STATIC(mylock, __SCLIB_MUTEX_NORMAL);
 
 static FILE *spf /*= NULL*/;
 
diff -urN uClibc-0.9.33/libc/stdio/popen.c uClibc-0.9.33-new/libc/stdio/popen.c
--- uClibc-0.9.33/libc/stdio/popen.c	2013-09-23 20:39:08.058221828 -0400
+++ uClibc-0.9.33-new/libc/stdio/popen.c	2013-09-23 20:39:32.942222861 -0400
@@ -36,7 +36,7 @@
 #endif
 
 #ifndef VFORK_LOCK
-__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);
+__UCLIBC_MUTEX_STATIC(mylock, __SCLIB_MUTEX_NORMAL);
 # define VFORK_LOCK		__UCLIBC_MUTEX_LOCK(mylock)
 # define VFORK_UNLOCK		__UCLIBC_MUTEX_UNLOCK(mylock)
 #endif
diff -urN uClibc-0.9.33/libc/stdio/_stdio.c uClibc-0.9.33-new/libc/stdio/_stdio.c
--- uClibc-0.9.33/libc/stdio/_stdio.c	2013-09-23 20:39:08.038221827 -0400
+++ uClibc-0.9.33-new/libc/stdio/_stdio.c	2013-09-23 20:39:32.942222861 -0400
@@ -74,12 +74,12 @@
 #endif
 
 #ifdef __UCLIBC_HAS_THREADS__
-#ifdef __USE_STDIO_FUTEXES__
+#if 0
 #define __STDIO_FILE_INIT_THREADSAFE \
 	2, _LIBC_LOCK_RECURSIVE_INITIALIZER,
 #else
 #define __STDIO_FILE_INIT_THREADSAFE \
-	2, PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP,
+	2, { .kind = __SCLIB_MUTEX_RECURSIVE, .value = 0, .owner = 0, .recur_count = 0 },
 #endif
 #else
 #define __STDIO_FILE_INIT_THREADSAFE
@@ -171,11 +171,11 @@
 /* 2 if threading not initialized and 0 otherwise; */
 int _stdio_user_locking = 2;
 
-#ifndef __USE_STDIO_FUTEXES__
+#if 1
 void attribute_hidden __stdio_init_mutex(__UCLIBC_MUTEX_TYPE *m)
 {
 	const __UCLIBC_MUTEX_STATIC(__stdio_mutex_initializer,
-		PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP);
+		__SCLIB_MUTEX_RECURSIVE);
 
 	memcpy(m, &__stdio_mutex_initializer, sizeof(__stdio_mutex_initializer));
 }
diff -urN uClibc-0.9.33/libc/stdlib/abort.c uClibc-0.9.33-new/libc/stdlib/abort.c
--- uClibc-0.9.33/libc/stdlib/abort.c	2013-09-23 20:39:07.546221807 -0400
+++ uClibc-0.9.33-new/libc/stdlib/abort.c	2013-09-23 20:39:32.942222861 -0400
@@ -54,7 +54,7 @@
 
 /* Be prepared in case multiple threads try to abort() */
 #include <bits/uClibc_mutex.h>
-__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP);
+__UCLIBC_MUTEX_STATIC(mylock, __SCLIB_MUTEX_RECURSIVE);
 
 /* Cause an abnormal program termination with core-dump */
 void abort(void)
diff -urN uClibc-0.9.33/libc/stdlib/_atexit.c uClibc-0.9.33-new/libc/stdlib/_atexit.c
--- uClibc-0.9.33/libc/stdlib/_atexit.c	2013-09-23 20:39:07.518221808 -0400
+++ uClibc-0.9.33-new/libc/stdlib/_atexit.c	2013-09-23 20:39:32.942222861 -0400
@@ -316,7 +316,7 @@
 
 extern void weak_function _stdio_term(void) attribute_hidden;
 attribute_hidden void (*__exit_cleanup)(int) = 0;
-__UCLIBC_MUTEX_INIT(__atexit_lock, PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP);
+__UCLIBC_MUTEX_INIT(__atexit_lock, __SCLIB_MUTEX_RECURSIVE);
 
 extern void __uClibc_fini(void);
 libc_hidden_proto(__uClibc_fini)
diff -urN uClibc-0.9.33/libc/stdlib/malloc-simple/alloc.c uClibc-0.9.33-new/libc/stdlib/malloc-simple/alloc.c
--- uClibc-0.9.33/libc/stdlib/malloc-simple/alloc.c	2013-09-23 20:39:07.506221806 -0400
+++ uClibc-0.9.33-new/libc/stdlib/malloc-simple/alloc.c	2013-09-23 20:39:32.942222861 -0400
@@ -112,7 +112,7 @@
 #ifdef L_memalign
 
 #include <bits/uClibc_mutex.h>
-__UCLIBC_MUTEX_INIT(__malloc_lock, PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP);
+__UCLIBC_MUTEX_INIT(__malloc_lock, __SCLIB_MUTEX_RECURSIVE);
 #define __MALLOC_LOCK		__UCLIBC_MUTEX_LOCK(__malloc_lock)
 #define __MALLOC_UNLOCK		__UCLIBC_MUTEX_UNLOCK(__malloc_lock)
 
diff -urN uClibc-0.9.33/libc/stdlib/malloc-standard/malloc.c uClibc-0.9.33-new/libc/stdlib/malloc-standard/malloc.c
--- uClibc-0.9.33/libc/stdlib/malloc-standard/malloc.c	2013-09-23 20:39:07.514221808 -0400
+++ uClibc-0.9.33-new/libc/stdlib/malloc-standard/malloc.c	2013-09-23 20:39:32.942222861 -0400
@@ -17,7 +17,7 @@
 #include "malloc.h"
 
 
-__UCLIBC_MUTEX_INIT(__malloc_lock, PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP);
+__UCLIBC_MUTEX_INIT(__malloc_lock, __SCLIB_MUTEX_RECURSIVE);
 
 /*
    There is exactly one instance of this struct in this malloc.
diff -urN uClibc-0.9.33/libc/stdlib/random.c uClibc-0.9.33-new/libc/stdlib/random.c
--- uClibc-0.9.33/libc/stdlib/random.c	2013-09-23 20:39:07.514221808 -0400
+++ uClibc-0.9.33-new/libc/stdlib/random.c	2013-09-23 20:39:32.942222861 -0400
@@ -32,7 +32,7 @@
    `srand' functions to prevent concurrent calls from modifying common
    data.  */
 #include <bits/uClibc_mutex.h>
-__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP);
+__UCLIBC_MUTEX_STATIC(mylock, __SCLIB_MUTEX_RECURSIVE);
 
 
 /* An improved random number generation package.  In addition to the standard
diff -urN uClibc-0.9.33/libc/stdlib/setenv.c uClibc-0.9.33-new/libc/stdlib/setenv.c
--- uClibc-0.9.33/libc/stdlib/setenv.c	2013-09-23 20:39:07.522221807 -0400
+++ uClibc-0.9.33-new/libc/stdlib/setenv.c	2013-09-23 20:39:32.942222861 -0400
@@ -27,7 +27,7 @@
 
 
 #include <bits/uClibc_mutex.h>
-__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);
+__UCLIBC_MUTEX_STATIC(mylock, __SCLIB_MUTEX_NORMAL);
 
 
 /* If this variable is not a null pointer we allocated the current
diff -urN uClibc-0.9.33/libc/stdlib/system.c uClibc-0.9.33-new/libc/stdlib/system.c
--- uClibc-0.9.33/libc/stdlib/system.c	2013-09-23 20:39:07.522221807 -0400
+++ uClibc-0.9.33-new/libc/stdlib/system.c	2013-09-23 20:39:32.942222861 -0400
@@ -23,7 +23,7 @@
 /* TODO: the cancellable version breaks on sparc currently,
  * need to figure out why still
  */
-#if !defined __UCLIBC_HAS_THREADS_NATIVE__ || defined __sparc__
+#if 1 /* Use this version for sclib */
 /* uClinux-2.0 has vfork, but Linux 2.0 doesn't */
 #include <sys/syscall.h>
 #ifndef __NR_vfork
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/access.c uClibc-0.9.33-new/libc/sysdeps/linux/common/access.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/access.c	2013-09-23 20:39:08.230221837 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/access.c	2013-09-23 20:39:32.942222861 -0400
@@ -9,4 +9,10 @@
 
 #include <sys/syscall.h>
 #include <unistd.h>
-_syscall2(int, access, const char *, pathname, int, mode)
+
+#include <bits/sclib.h>
+
+int access(const char *pathname, int mode)
+{
+	return SCLIB_PATH_CALL(access, 2, pathname, mode);
+}
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/bits/_dcmpxchg.h uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/_dcmpxchg.h
--- uClibc-0.9.33/libc/sysdeps/linux/common/bits/_dcmpxchg.h	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/_dcmpxchg.h	2013-09-23 20:39:32.942222861 -0400
@@ -0,0 +1,30 @@
+#ifndef _SYSCALL_COMMON_DCMPXCHG_H
+#define _SYSCALL_COMMON_DCMPXCHG_H 1
+
+/* Double CAS implementation */
+# if defined(__x86_64__) || defined(__i386__)
+
+#  if defined(__x86_64__)
+#   define __DCMPXCHG "cmpxchg16b"
+#  else
+#   define __DCMPXCHG "cmpxchg8b"
+#  endif
+
+static inline bool dcmpxchg(size_t *addr, size_t prev_lo, size_t prev_hi,
+	size_t new_lo, size_t new_hi)
+{
+	bool result;
+	__asm__ __volatile__ ("lock " __DCMPXCHG " %0\n\t"
+						  "setz %b1"
+						  : "+m" (*addr), "=a" (result), "+d" (prev_hi)
+						  : "a" (prev_lo), "b" (new_lo), "c" (new_hi)
+						  : "cc"
+	);
+	return result;
+}
+
+#  undef __DCMPXCHG
+
+# endif
+
+#endif /* !_SYSCALL_COMMON_DCMPXCHG */
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/bits/sclib.h uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/sclib.h
--- uClibc-0.9.33/libc/sysdeps/linux/common/bits/sclib.h	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/sclib.h	2013-09-23 20:39:32.942222861 -0400
@@ -0,0 +1,419 @@
+/**
+ * VM-Syscalls
+ * Copyright (c) 2012 Ruslan Nikolaev <rnikola@vt.edu>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef _SCLIB_H
+#define _SCLIB_H 1
+
+#include <sys/mman.h>
+#include <libc-symbols.h>
+#include <bits/uClibc_page.h>
+#include <../libc/termios/kernel_termios.h>
+#include <scheduleP.h>
+#include "sclib_public.h"
+#include "_syscall_queue.h"
+
+/* Not declared anywhere currently */
+#if !defined(F_SETOWN_EX) && !defined(F_GETOWN_EX)
+struct f_owner_ex {
+	int type;
+	__kernel_pid_t pid;
+};
+#endif
+#ifndef F_SETOWN_EX
+# define F_SETOWN_EX 15
+#endif
+#ifndef F_GETOWN_EX
+# define F_GETOWN_EX 16
+#endif
+
+#define SCLIB_WAIT_ITERATIONS			4000
+#define SCLIB_NUM_KTHREADS				10
+#define SCLIB_MAX_KTHREADS				1024
+#define SCLIB_MEMORY_ALIGN				(2 * sizeof(size_t))
+#define SCLIB_MEMORY_MAGIC_ALLOC		0xAAA00AAA
+#define SCLIB_MEMORY_MAGIC_FREE			0xFFF00FFF
+
+#define SCLIB_MEMORY_PREALLOC
+
+#define SCLIB_WAIT_RESULT_DELAY			__asm__ __volatile__ ("pause")
+
+struct sclib_memory_block_s;
+typedef struct sclib_memory_block_s sclib_memory_block_t;
+
+typedef struct sclib_memory_binfo_s {
+	size_t magic;
+	size_t size;
+} sclib_memory_binfo_t;
+
+struct sclib_memory_block_s {
+	sclib_memory_binfo_t block;
+	sclib_memory_list_t list;
+};
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void sclib_init(void);
+libc_hidden_proto(sclib_init)
+
+void sclib_terminate(void);
+libc_hidden_proto(sclib_terminate)
+
+void sclib_memory_init(void);
+libc_hidden_proto(sclib_memory_init)
+
+#ifdef SCLIB_MEMORY_PREALLOC
+# ifdef __UCLIBC_HAS_TLS__
+extern __thread sclib_memory_block_t *sclib_memptr[SYSCALL_SYSIDS];
+# else
+#  error "Need TLS support for SCLIB thread data"
+# endif
+static inline void sclib_memory_prealloc_init(void)
+{
+	size_t sysid;
+	for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++)
+		sclib_memptr[sysid] = NULL;
+}
+void sclib_memory_prealloc_exit(void);
+libc_hidden_proto(sclib_memory_prealloc_exit)
+#else
+static inline void sclib_memory_prealloc_init(void) {}
+static inline void sclib_memory_prealloc_exit(void) {}
+#endif
+
+void sclib_file_init(sclib_file_table_t *file);
+libc_hidden_proto(sclib_file_init)
+
+void sclib_file_exec(sclib_file_table_t *file);
+libc_hidden_proto(sclib_file_exec)
+
+long sclib_fds_save(void);
+libc_hidden_proto(sclib_fds_save)
+
+long sclib_fd_mmap(void);
+libc_hidden_proto(sclib_fd_mmap)
+
+long sclib_fd_open(void);
+libc_hidden_proto(sclib_fd_open)
+
+void sclib_fd_close(void);
+libc_hidden_proto(sclib_fd_close)
+
+char *sclib_get_path(char *abspath, const char *path, int *sysid, size_t *sz);
+libc_hidden_proto(sclib_get_path)
+
+long sclib_efds_open(bool new_process);
+libc_hidden_proto(sclib_efds_open)
+
+void sclib_efds_close(void);
+libc_hidden_proto(sclib_efds_close)
+
+extern struct syscall_queue *sclib_rqueue;
+libc_hidden_proto(sclib_rqueue)
+
+extern size_t sclib_wait_iterations;
+libc_hidden_proto(sclib_wait_iterations);
+
+static inline void sclib_queue_init(struct syscall_queue *queue)
+{
+	size_t i;
+
+	queue->alloc_head.index = 0;
+	queue->alloc_head.stamp = 0;
+	queue->alloc_tail = queue->alloc_head;
+	queue->free_head.index = 1;
+	queue->free_head.stamp = 0;
+	queue->free_tail.index = SYSCALL_MAX_PTHREADS-1;
+	queue->free_tail.stamp = 0;
+	queue->next[0].index = SYSCALL_NULL_ENTRY;
+	queue->next[0].stamp = 0;
+	for (i = 1; i < SYSCALL_MAX_PTHREADS-1; i++) {
+		queue->next[i].index = i + 1;
+		queue->next[i].stamp = 0;
+	}
+	queue->next[SYSCALL_MAX_PTHREADS-1].index = SYSCALL_NULL_ENTRY;
+	queue->next[SYSCALL_MAX_PTHREADS-1].stamp = 0;
+	queue->waiters = 0;
+	queue->nkthreads = 1;
+}
+
+static inline void sclib_init_minimal(void)
+{
+	long ret, fd;
+
+	fd = SCLIB_LOCAL_CALL(open, 2, "/dev/syscall_service", O_RDWR);
+	if (SCLIB_IS_ERR(fd)) {
+		fprintf(stderr, "Cannot open /dev/syscall_service!\n");
+		exit(1);
+	}
+	ret = SCLIB_LOCAL_CALL(mmap, 6, NULL, SYSCALL_QUEUE_PAGES * PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+	if (SCLIB_IS_ERR(ret)) {
+		fprintf(stderr, "Cannot mmap ready queue!\n");
+		exit(1);
+	}
+	SCLIB_LOCAL_CALL(close, 1, fd);
+	sclib_rqueue = (struct syscall_queue *) ret;
+	sclib_queue_init(sclib_rqueue);
+}
+
+static inline void sclib_ioctl_decode(unsigned long cmd, unsigned *dir, size_t *size)
+{
+	switch (cmd) {
+		case TCGETS:
+		case TIOCGLCKTRMIOS:
+			*dir = _IOC_READ;
+			*size = sizeof(struct __kernel_termios);
+			break;
+		case TCSETS:
+		case TCSETSW:
+		case TCSETSF:
+		case TIOCSLCKTRMIOS:
+			*dir = _IOC_WRITE;
+			*size = sizeof(struct __kernel_termios);
+			break;
+		case TCGETA:
+			*dir = _IOC_READ;
+			*size = sizeof(struct termio);
+			break;
+		case TCSETA:
+		case TCSETAW:
+		case TCSETAF:
+			*dir = _IOC_WRITE;
+			*size = sizeof(struct termio);
+			break;
+		case TIOCGWINSZ:
+			*dir = _IOC_READ;
+			*size = sizeof(struct winsize);
+			break;
+		case TIOCSWINSZ:
+			*dir = _IOC_WRITE;
+			*size = sizeof(struct winsize);
+			break;
+		case TIOCINQ: /* FIONREAD, SIOCINQ */
+		case TIOCOUTQ: /* SIOCOUTQ */
+		case TIOCGPGRP:
+		case TIOCGSID:
+		case TIOCGETD:
+		case TIOCMGET:
+		case TIOCGSOFTCAR:
+		case FIOGETOWN:
+		case SIOCATMARK:
+			*dir = _IOC_READ;
+			*size = sizeof(int);
+			break;
+		case TIOCSPGRP:
+		case TIOCSETD:
+		case TIOCPKT:
+		case TIOCMSET:
+		case TIOCMBIC:
+		case TIOCMBIS:
+		case TIOCSSOFTCAR:
+		case FIONBIO:
+		case FIOASYNC:
+		case FIOSETOWN:
+			*dir = _IOC_WRITE;
+			*size = sizeof(int);
+			break;
+		case TIOCSTI:
+			*dir = _IOC_WRITE;
+			*size = sizeof(char);
+			break;
+		case FIOQSIZE:
+			*dir = _IOC_READ;
+			*size = sizeof(loff_t);
+			break;
+		case SIOCSPGRP:
+			*dir = _IOC_WRITE;
+			*size = sizeof(pid_t);
+			break;
+		case SIOCGPGRP:
+			*dir = _IOC_READ;
+			*size = sizeof(pid_t);
+			break;
+		case SIOCGSTAMP:
+			*dir = _IOC_READ;
+			*size = sizeof(struct timeval);
+			break;
+		case SIOCGSTAMPNS:
+			*dir = _IOC_READ;
+			*size = sizeof(struct timespec);
+			break;
+		case FIOCLEX:
+		case FIONCLEX:
+			*dir = 0;
+			*size = 0;
+			break;
+		default:
+			*dir = _IOC_DIR(cmd);
+			*size = _IOC_SIZE(cmd);
+			break;
+	}
+}
+
+static inline void sclib_fcntl_decode(unsigned cmd, unsigned *dir, size_t *size)
+{
+	switch (cmd) {
+		case F_GETLK:
+			*dir = _IOC_READ | _IOC_WRITE;
+			*size = sizeof(struct flock);
+			break;
+		case F_SETLK:
+		case F_SETLKW:
+			*dir = _IOC_WRITE;
+			*size = sizeof(struct flock);
+			break;
+		case F_GETOWN_EX:
+			*dir = _IOC_READ;
+			*size = sizeof(struct f_owner_ex);
+			break;
+		case F_SETOWN_EX:
+			*dir = _IOC_WRITE;
+			*size = sizeof(struct f_owner_ex);
+			break;
+		default:
+			*dir = _IOC_NONE;
+			*size = 0;
+			break;
+	}
+}
+
+static inline void __sclib_queue_add(struct syscall_queue *queue, struct pthread *thread)
+{
+	struct pthread *result;
+	size_t idx;
+
+	idx = syscall_queue_dequeue(queue->next, queue->entries, &queue->free_head,
+		&queue->free_tail, &result, SYSCALL_MAX_PTHREADS, false);
+	if ((ssize_t) idx < 0) {
+		fprintf(stderr, "ERROR: ready queue failure (5)!\n");
+		exit(1);
+	}
+	queue->entries[idx] = thread;
+	if (syscall_queue_enqueue(queue->next, &queue->alloc_tail, idx, SYSCALL_MAX_PTHREADS, false) != 0) {
+		fprintf(stderr, "ERROR: ready queue failure (6)!\n");
+		exit(1);
+	}
+	if (VOLATILE_READ(queue->waiters) != 0) {
+		SCLIB_LOCAL_CALL(rqueue_wake, 1, 1);
+	}
+}
+
+static inline struct pthread *__sclib_queue_remove(struct syscall_queue *queue, bool block)
+{
+	struct pthread *result;
+	size_t idx;
+	size_t counter = sclib_wait_iterations;
+
+again:
+	idx = syscall_queue_dequeue(queue->next, queue->entries, &queue->alloc_head, &queue->alloc_tail, &result, SYSCALL_MAX_PTHREADS, false);
+	if (idx == SYSCALL_ERROR_ENTRY) {
+		fprintf(stderr, "ERROR: ready queue failure (7)!\n");
+		exit(1);
+	}
+	if (idx == SYSCALL_NULL_ENTRY) {
+		if (!block)
+			return NULL;
+		/* Spin a little bit. */
+		if (counter != 0) {
+			SCLIB_WAIT_RESULT_DELAY;
+			counter--;
+			goto again;
+		}
+		__sync_fetch_and_add(&queue->waiters, 1);
+		while ((long) (idx = SCLIB_LOCAL_CALL(rqueue_wait, 1, &result)) == -EINTR) {}
+		__sync_fetch_and_sub(&queue->waiters, 1);
+		if (SCLIB_IS_ERR(idx)) {
+			fprintf(stderr, "ERROR: ready queue failure in kernel (7)!\n");
+			exit(1);
+		}
+	}
+	if (syscall_queue_enqueue(queue->next, &queue->free_tail, idx, SYSCALL_MAX_PTHREADS, false) != 0) {
+		fprintf(stderr, "ERROR: ready queue failure (8)!\n");
+		exit(1);
+	}
+#if 0
+	if (queue->waiters != 0 && syscall_queue_check(queue->next, &queue->alloc_head, &queue->alloc_tail, SYSCALL_MAX_PTHREADS) == 0)
+		SCLIB_LOCAL_CALL(rqueue_wake, 1, 1);
+#endif
+	return result;
+}
+
+static inline struct pthread *__sclib_queue_single_remove(struct syscall_queue *queue, int sysid, unsigned int id, struct syscall_entry *entry)
+{
+	struct pthread *result;
+	size_t idx;
+	size_t counter = sclib_wait_iterations;
+
+again:
+	idx = syscall_queue_dequeue(queue->next, queue->entries, &queue->alloc_head, &queue->alloc_tail, &result, SYSCALL_MAX_PTHREADS, false);
+	if (idx == SYSCALL_ERROR_ENTRY) {
+		fprintf(stderr, "ERROR: ready queue failure (7)!\n");
+		exit(1);
+	}
+	if (idx == SYSCALL_NULL_ENTRY) {
+		/* Spin a little bit. */
+		if (counter != 0) {
+			SCLIB_WAIT_RESULT_DELAY;
+			counter--;
+			goto again;
+		}
+		__sync_fetch_and_add(&queue->waiters, 1);
+		idx = SCLIB_LOCAL_CALL(rqueue_wait_notify, 4, sysid, id, entry, &result);
+		if ((long) idx == -EINTR) {
+			while ((long) (idx = SCLIB_LOCAL_CALL(rqueue_wait, 1, &result)) == -EINTR) {}
+		}
+		__sync_fetch_and_sub(&queue->waiters, 1);
+		if (SCLIB_IS_ERR(idx)) {
+			fprintf(stderr, "ERROR: ready queue failure in kernel (7)!\n");
+			exit(1);
+		}
+	}
+	if (syscall_queue_enqueue(queue->next, &queue->free_tail, idx, SYSCALL_MAX_PTHREADS, false) != 0) {
+		fprintf(stderr, "ERROR: ready queue failure (8)!\n");
+		exit(1);
+	}
+#if 0
+	if (queue->waiters != 0 && syscall_queue_check(queue->next, &queue->alloc_head, &queue->alloc_tail, SYSCALL_MAX_PTHREADS) == 0)
+		SCLIB_LOCAL_CALL(rqueue_wake, 1, 1);
+#endif
+	return result;
+}
+
+static inline void sclib_schedule_single(int sysid, struct syscall_entry *entry)
+{
+	unsigned int id;
+
+	do {
+		id = entry->id;
+		if (id == SYSCALL_ENTRY_DONE) /* Already completed. */
+			return;
+	} while (!__sync_bool_compare_and_swap(&entry->id, id, id + SYSCALL_ENTRY_RQUEUE));
+	__sclib_queue_single_remove(sclib_rqueue, sysid, id, entry);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_SCLIB_H */
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/bits/sclib_public.h uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/sclib_public.h
--- uClibc-0.9.33/libc/sysdeps/linux/common/bits/sclib_public.h	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/sclib_public.h	2013-09-23 20:39:32.946222861 -0400
@@ -0,0 +1,1086 @@
+/**
+ * VM-Syscalls
+ * Copyright (c) 2012 Ruslan Nikolaev <rnikola@vt.edu>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef _SCLIB_PUBLIC_H
+#define _SCLIB_PUBLIC_H 1
+
+#include <inttypes.h>
+#include <sys/types.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <sys/syscall.h>
+#include <sys/param.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <features.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <limits.h>
+
+/* A special value for epoll */
+#define EPOLLEFD	(1 << 23)
+
+#define SCLIB_LIB_PATH			"/usr/sclib/lib"
+#define SCLIB_STORAGE_PREFIX	"/storage"
+#define SCLIB_MAX_BUFFER		(SYSCALL_DATA_SHARED_PAGES * PAGE_SIZE) / 8
+
+#define smp_mb()				__sync_synchronize()
+
+#ifndef likely
+# define likely(x)				__builtin_expect((x),1)
+#endif
+#ifndef unlikely
+# define unlikely(x)			__builtin_expect((x),0)
+#endif
+
+#include "_syscall.h"
+#include "_syscall_stack.h"
+#include "_syscall_num.h"
+
+#define SYSCALL_SYSID_ALL		-1
+#define SYSCALL_SYSID_LOCAL		SYSCALL_SYSIDS
+
+struct syscall_efd {
+	uint64_t efd_num;
+	int n;
+	int efd[SYSCALL_SYSIDS+1];
+};
+
+/* Sclib iovec cookie */
+struct sclib_iovc {
+	const struct iovec *iovc_iov;
+	size_t iovc_off;
+};
+
+#define SCLIB_IS_ERR(x)	\
+	(unlikely((unsigned long) (x) >= (unsigned long) (-4095L)))
+
+#define SCLIB_ERR_RET(x) \
+	do { \
+		if (SCLIB_IS_ERR(x)) { \
+			__set_errno(-(x)); \
+			return -1; \
+		} \
+	} while (0);
+
+#define SCLIB_SYS_RET(x) \
+	do { \
+		if (SCLIB_IS_ERR(x)) \
+			return (x); \
+	} while (0);
+
+#define SCLIB_VAL_RET(e, r) \
+	do { \
+		if (SCLIB_IS_ERR(e)) { \
+			(r) = (e); \
+			goto error_val; \
+		} \
+	} while (0);
+
+#define SCLIB_VAL2_RET(e, r) \
+	do { \
+		if (SCLIB_IS_ERR(e)) { \
+			(r) = (e); \
+			goto error_val2; \
+		} \
+	} while (0);
+
+#define SCLIB_MEM_RET(x, r) \
+	do { \
+		if (unlikely((x) == NULL)) { \
+			(r) = -ENOMEM; \
+			goto error_mem; \
+		} \
+	} while (0);
+
+#define SCLIB_DFD_SYSCALL(call, par, fd, ...) (__extension__ ({ \
+	long __ret, __dfd; \
+	int __sysid; \
+	__dfd = sclib_file_getid(&sclib_file, (fd), &__sysid); \
+	SCLIB_ERR_RET(__dfd); \
+	__ret = SCLIB_SYSID_CALL(__sysid, call, par, __dfd, ##__VA_ARGS__); \
+	sclib_file_put(&sclib_file, (fd)); \
+	SCLIB_ERR_RET(__ret); \
+	__ret; }))
+
+#define SCLIB_DFD_INBUF_SYSCALL(call, sz, par, fd, buf, ...) (__extension__ ({ \
+	long __ret, __dfd; \
+	int __sysid; \
+	void *__rbuf; \
+	size_t __sz; \
+	__dfd = sclib_file_getid(&sclib_file, (fd), &__sysid); \
+	SCLIB_ERR_RET(__dfd); \
+	if (__sysid != SYSCALL_SYSID_LOCAL) { \
+		__sz = (sz); \
+		__rbuf = sclib_memory_alloc(&sclib_data[__sysid], __sz); \
+		SCLIB_MEM_RET(__rbuf, __ret); \
+		__rbuf = memcpy(__rbuf, (buf), __sz); \
+		__ret = SCLIB_REMOTE_CALL(__sysid, call, par, __dfd, sclib_mem(__sysid, __rbuf), ##__VA_ARGS__); \
+		sclib_memory_free(&sclib_data[__sysid], __rbuf); \
+	} else { \
+		__ret = SCLIB_LOCAL_CALL(call, par, __dfd, (buf), ##__VA_ARGS__); \
+	} \
+error_mem: \
+	sclib_file_put(&sclib_file, (fd)); \
+	SCLIB_ERR_RET(__ret); \
+	__ret; }))
+
+#define SCLIB_DFD_STR_INBUF_SYSCALL(call, sz1, sz2, par, fd, str, buf, ...) (__extension__ ({ \
+	long __ret, __dfd; \
+	int __sysid; \
+	void *__rbuf, *__off; \
+	size_t __sz1, __sz2; \
+	__dfd = sclib_file_getid(&sclib_file, (fd), &__sysid); \
+	SCLIB_ERR_RET(__dfd); \
+	if (__sysid != SYSCALL_SYSID_LOCAL) { \
+		__sz1 = (sz1); \
+		__sz2 = (sz2); \
+		__rbuf = sclib_memory_alloc(&sclib_data[__sysid], __sz1 + __sz2); \
+		SCLIB_MEM_RET(__rbuf, __ret); \
+		memcpy(mempcpy(__rbuf, (buf), __sz2), str, __sz1); \
+		__off = sclib_mem(__sysid, __rbuf); \
+		__ret = SCLIB_REMOTE_CALL(__sysid, call, par, __dfd, __off + __sz2, __off, ##__VA_ARGS__); \
+		sclib_memory_free(&sclib_data[__sysid], __rbuf); \
+	} else { \
+		__ret = SCLIB_LOCAL_CALL(call, par, __dfd, str, buf, ##__VA_ARGS__); \
+	} \
+error_mem: \
+	sclib_file_put(&sclib_file, (fd)); \
+	SCLIB_ERR_RET(__ret); \
+	__ret; }))
+
+#define SCLIB_DFD_OUTBUF_SYSCALL(call, sz, par, fd, buf, ...) (__extension__ ({ \
+	long __ret, __dfd; \
+	int __sysid; \
+	void *__rbuf; \
+	size_t __sz; \
+	__dfd = sclib_file_getid(&sclib_file, (fd), &__sysid); \
+	SCLIB_ERR_RET(__dfd); \
+	if (__sysid != SYSCALL_SYSID_LOCAL) { \
+		__sz = (sz); \
+		__rbuf = sclib_memory_alloc(&sclib_data[__sysid], __sz); \
+		SCLIB_MEM_RET(__rbuf, __ret); \
+		__ret = SCLIB_REMOTE_CALL(__sysid, call, par, __dfd, sclib_mem(__sysid, __rbuf), ##__VA_ARGS__); \
+		if (!SCLIB_IS_ERR(__ret)) \
+			memcpy((buf), __rbuf, __ret); \
+		sclib_memory_free(&sclib_data[__sysid], __rbuf); \
+	} else { \
+		__ret = SCLIB_LOCAL_CALL(call, par, __dfd, (buf), ##__VA_ARGS__); \
+	} \
+error_mem: \
+	sclib_file_put(&sclib_file, (fd)); \
+	SCLIB_ERR_RET(__ret); \
+	__ret; }))
+
+#define SCLIB_DFD_OUTBUFSZ_SYSCALL(call, sz, par, fd, buf, ...) (__extension__ ({ \
+	long __ret, __dfd; \
+	int __sysid; \
+	void *__rbuf; \
+	size_t __sz; \
+	__dfd = sclib_file_getid(&sclib_file, (fd), &__sysid); \
+	SCLIB_ERR_RET(__dfd); \
+	if (__sysid != SYSCALL_SYSID_LOCAL) { \
+		__sz = (sz); \
+		__rbuf = sclib_memory_alloc(&sclib_data[__sysid], __sz); \
+		SCLIB_MEM_RET(__rbuf, __ret); \
+		__ret = SCLIB_REMOTE_CALL(__sysid, call, par, __dfd, sclib_mem(__sysid, __rbuf), ##__VA_ARGS__); \
+		if (!SCLIB_IS_ERR(__ret)) \
+			memcpy((buf), __rbuf, __sz); \
+		sclib_memory_free(&sclib_data[__sysid], __rbuf); \
+	} else { \
+		__ret = SCLIB_LOCAL_CALL(call, par, __dfd, (buf), ##__VA_ARGS__); \
+	} \
+error_mem: \
+	sclib_file_put(&sclib_file, (fd)); \
+	SCLIB_ERR_RET(__ret); \
+	__ret; }))
+
+#define SCLIB_DFD_STR_OUTBUF_SYSCALL(call, sz1, sz2, par, fd, str, buf, ...) (__extension__ ({ \
+	long __ret, __dfd; \
+	int __sysid; \
+	void *__rbuf, *__off; \
+	size_t __sz1, __sz2; \
+	__dfd = sclib_file_getid(&sclib_file, (fd), &__sysid); \
+	SCLIB_ERR_RET(__dfd); \
+	if (__sysid != SYSCALL_SYSID_LOCAL) { \
+		__sz1 = (sz1); \
+		__sz2 = (sz2); \
+		__rbuf = sclib_memory_alloc(&sclib_data[__sysid], __sz1 + __sz2); \
+		SCLIB_MEM_RET(__rbuf, __ret); \
+		memcpy(__rbuf + __sz2, str, __sz1); \
+		__off = sclib_mem(__sysid, __rbuf); \
+		__ret = SCLIB_REMOTE_CALL(__sysid, call, par, __dfd, __off + __sz2, __off, ##__VA_ARGS__); \
+		if (!SCLIB_IS_ERR(__ret)) \
+			memcpy((buf), __rbuf, __ret); \
+		sclib_memory_free(&sclib_data[__sysid], __rbuf); \
+	} else { \
+		__ret = SCLIB_LOCAL_CALL(call, par, __dfd, str, (buf), ##__VA_ARGS__); \
+	} \
+error_mem: \
+	sclib_file_put(&sclib_file, (fd)); \
+	SCLIB_ERR_RET(__ret); \
+	__ret; }))
+
+#define SCLIB_LFD_SYSCALL(call, par, fd, ...) (__extension__ ({ \
+	long __ret, __lfd; \
+	__lfd = sclib_file_get(&sclib_file, (fd), SYSCALL_SYSID_LOCAL); \
+	SCLIB_ERR_RET(__lfd); \
+	__ret = SCLIB_LOCAL_CALL(call, par, __lfd, ##__VA_ARGS__); \
+	sclib_file_put(&sclib_file, (fd)); \
+	SCLIB_ERR_RET(__ret); \
+	__ret; }))
+
+#define SCLIB_LFDPATH_SYSCALL(call, par, fd, path, ...) (__extension__ ({ \
+	long __ret, __lfd; \
+	size_t __sz; \
+	int __sysid; \
+	char __abspath[PATH_MAX], *__dpath; \
+	__dpath = sclib_get_path(__abspath, (path), &__sysid, &__sz); \
+	if (__sysid != SYSCALL_SYSID_LOCAL) { \
+		__set_errno(EINVAL); \
+		return -1; \
+	} \
+	__lfd = sclib_file_get(&sclib_file, (fd), SYSCALL_SYSID_LOCAL); \
+	SCLIB_ERR_RET(__lfd); \
+	__ret = SCLIB_LOCAL_CALL(call, par, __lfd, __dpath, ##__VA_ARGS__); \
+	sclib_file_put(&sclib_file, (fd)); \
+	SCLIB_ERR_RET(__ret); \
+	__ret; }))
+
+#define SCLIB_LFD_SYSCALL2(call, par, fd1, fd2, ...) (__extension__ ({ \
+	long __ret, __lfd1, __lfd2; \
+	__lfd1 = sclib_file_get(&sclib_file, (fd1), SYSCALL_SYSID_LOCAL); \
+	if (SCLIB_IS_ERR(__lfd1)) { \
+		__ret = __lfd1; \
+		goto __lfd1_err; \
+	} \
+	__lfd2 = sclib_file_get(&sclib_file, (fd2), SYSCALL_SYSID_LOCAL); \
+	if (SCLIB_IS_ERR(__lfd2)) { \
+		__ret = __lfd2; \
+		goto __lfd2_err; \
+	} \
+	__ret = SCLIB_LOCAL_CALL(call, par, __lfd1, __lfd2, ##__VA_ARGS__); \
+	sclib_file_put(&sclib_file, (fd2)); \
+__lfd2_err: sclib_file_put(&sclib_file, (fd1)); \
+__lfd1_err:	SCLIB_ERR_RET(__ret); \
+	__ret; }))
+
+#define SCLIB_DFD_SYSCALL_AT(call, par, fd, path, ...) (__extension__ ({ \
+	const char *__dpath = (const char *) (path); \
+	char __abspath[PATH_MAX]; \
+	void *__rbuf = __rbuf, *__off; \
+	size_t __sz; \
+	int __sysid; \
+	long __ret, __dfd; \
+	if ((fd) == AT_FDCWD) {	\
+		__dpath = sclib_get_path(__abspath, __dpath ? __dpath : "", &__sysid, &__sz); \
+		__dfd = -1; \
+	} else if (__dpath && *__dpath == '/') { \
+		__dpath = sclib_get_path(__abspath, __dpath, &__sysid, &__sz); \
+		__dfd = -1; \
+	} else { \
+		__sz = __dpath ? (strlen(__dpath) + 1) : 0; \
+		__dfd = sclib_file_getid(&sclib_file, (fd), &__sysid); \
+		SCLIB_ERR_RET(__dfd); \
+	} \
+	if (__sysid != SYSCALL_SYSID_LOCAL) { \
+		__off = NULL; \
+		if (__sz != 0) { \
+			__rbuf = sclib_memory_alloc(&sclib_data[__sysid], __sz); \
+			SCLIB_MEM_RET(__rbuf, __ret); \
+			memcpy(__rbuf, __dpath, __sz); \
+			__off = sclib_mem(__sysid, __rbuf); \
+		} \
+		__ret = SCLIB_REMOTE_CALL(__sysid, call, par, __dfd, __off, ##__VA_ARGS__); \
+		if (__sz != 0) \
+			sclib_memory_free(&sclib_data[__sysid], __rbuf); \
+	} else { \
+		__ret = SCLIB_LOCAL_CALL(call, par, __dfd, __dpath, ##__VA_ARGS__); \
+	} \
+error_mem: \
+	if (__dfd >= 0) \
+		sclib_file_put(&sclib_file, (fd)); \
+	SCLIB_ERR_RET(__ret); \
+	__ret; }))
+
+#define SCLIB_DFD_INBUF_SYSCALL_AT(call, sz, par, fd, path, buf, ...) (__extension__ ({ \
+	const char *__dpath = (const char *) (path); \
+	char __abspath[PATH_MAX]; \
+	void *__rbuf = __rbuf, *__off; \
+	size_t __sz2, __sz1; \
+	int __sysid; \
+	long __ret, __dfd; \
+	if ((fd) == AT_FDCWD) {	\
+		__dpath = sclib_get_path(__abspath, __dpath ? __dpath : "", &__sysid, &__sz2); \
+		__dfd = -1; \
+	} else if (__dpath && *__dpath == '/') { \
+		__dpath = sclib_get_path(__abspath, __dpath, &__sysid, &__sz2); \
+		__dfd = -1; \
+	} else { \
+		__sz2 = __dpath ? (strlen(__dpath) + 1) : 0; \
+		__dfd = sclib_file_getid(&sclib_file, (fd), &__sysid); \
+		SCLIB_ERR_RET(__dfd); \
+	} \
+	if (__sysid != SYSCALL_SYSID_LOCAL) { \
+		__sz1 = (sz); \
+		__off = NULL; \
+		if (__sz1 + __sz2 != 0) { \
+			__rbuf = sclib_memory_alloc(&sclib_data[__sysid], __sz1 + __sz2); \
+			SCLIB_MEM_RET(__rbuf, __ret); \
+			memcpy(mempcpy(__rbuf, (buf), __sz1), __dpath, __sz2); \
+			__off = sclib_mem(__sysid, __rbuf); \
+		} \
+		__ret = SCLIB_REMOTE_CALL(__sysid, call, par, __dfd, __sz2 ? (__off + __sz1) : NULL, __off, ##__VA_ARGS__); \
+		if (__sz1 + __sz2 != 0) \
+			sclib_memory_free(&sclib_data[__sysid], __rbuf); \
+	} else { \
+		__ret = SCLIB_LOCAL_CALL(call, par, __dfd, __dpath, (buf), ##__VA_ARGS__); \
+	} \
+error_mem: \
+	if (__dfd >= 0) \
+		sclib_file_put(&sclib_file, (fd)); \
+	SCLIB_ERR_RET(__ret); \
+	__ret; }))
+
+#define SCLIB_DFD_SYSCALL_AT2(call, par, fd1, path1, fd2, path2, ...) (__extension__ ({ \
+	const char *__dpath1 = (const char *) (path1); \
+	const char *__dpath2 = (const char *) (path2); \
+	char __abspath1[PATH_MAX], __abspath2[PATH_MAX]; \
+	void *__rbuf = __rbuf, *__off; \
+	size_t __sz2, __sz1; \
+	int __sysid, __sysid2; \
+	long __ret, __dfd1, __dfd2; \
+	if ((fd1) == AT_FDCWD) { \
+		__dpath1 = sclib_get_path(__abspath1, __dpath1 ? __dpath1 : "", &__sysid, &__sz1); \
+		__dfd1 = -1; \
+	} else if (__dpath1 && *__dpath1 == '/') { \
+		__dpath1 = sclib_get_path(__abspath1, __dpath1, &__sysid, &__sz1); \
+		__dfd1 = -1; \
+	} else { \
+		__sz1 = __dpath1 ? (strlen(__dpath1) + 1) : 0; \
+		__dfd1 = sclib_file_getid(&sclib_file, (fd1), &__sysid); \
+		__ret = __dfd1; \
+		goto __dfd1_err; \
+	} \
+	if ((fd2) == AT_FDCWD) { \
+		__dpath2 = sclib_get_path(__abspath2, __dpath2 ? __dpath2 : "", &__sysid2, &__sz2); \
+		__dfd2 = -1; \
+	} else if (__dpath2 && *__dpath2 == '/') { \
+		__dpath2 = sclib_get_path(__abspath2, __dpath2, &__sysid2, &__sz2); \
+		__dfd2 = -1; \
+	} else { \
+		__sz2 = __dpath2 ? (strlen(__dpath2) + 1) : 0; \
+		__dfd2 = sclib_file_getid(&sclib_file, (fd2), &__sysid2); \
+		__ret = __dfd2; \
+		goto __dfd2_err; \
+	} \
+	if (__sysid != __sysid2) { \
+		__ret = -EINVAL; \
+		goto error_mem; \
+	} \
+	if (__sysid != SYSCALL_SYSID_LOCAL) { \
+		__off = NULL; \
+		if (__sz1 + __sz2 != 0) { \
+			__rbuf = sclib_memory_alloc(&sclib_data[__sysid], __sz1 + __sz2); \
+			SCLIB_MEM_RET(__rbuf, __ret); \
+			memcpy(mempcpy(__rbuf, __dpath1, __sz1), __dpath2, __sz2); \
+			__off = sclib_mem(__sysid, __rbuf); \
+		} \
+		__ret = SCLIB_REMOTE_CALL(__sysid, call, par, __dfd1, __off, __dfd2, __sz2 ? (__off + __sz1) : NULL, ##__VA_ARGS__); \
+		if (__sz1 + __sz2 != 0) \
+			sclib_memory_free(&sclib_data[__sysid], __rbuf); \
+	} else { \
+		__ret = SCLIB_LOCAL_CALL(call, par, __dfd1, __dpath1, __dfd2, __dpath2, ##__VA_ARGS__); \
+	} \
+error_mem: \
+	if (__dfd2 >= 0) \
+		sclib_file_put(&sclib_file, (fd2)); \
+__dfd2_err: \
+	if (__dfd1 >= 0) \
+		sclib_file_put(&sclib_file, (fd1)); \
+__dfd1_err: \
+	SCLIB_ERR_RET(__ret); \
+	__ret; }))
+
+#define SCLIB_LFD_SYSCALL_NOSTATUS(call, par, fd, ...) (__extension__ ({ \
+	INTERNAL_SYSCALL_DECL(__err); \
+	long __lfd = sclib_file_get(&sclib_file, (fd), SYSCALL_SYSID_LOCAL); \
+	if (unlikely(__lfd < 0)) \
+		return; \
+	INTERNAL_SYSCALL(call, __err, par, __lfd, ##__VA_ARGS__); \
+	sclib_file_put(&sclib_file, (fd)); \
+}))
+
+#define SCLIB_PATH_CALL(call, par, path, ...) (__extension__ ({ \
+	char __abspath[PATH_MAX], *__dpath; \
+	long __ret; \
+	int __sysid; \
+	void *__rbuf; \
+	size_t __sz; \
+	__dpath = sclib_get_path(__abspath, (path), &__sysid, &__sz); \
+	if (__sysid != SYSCALL_SYSID_LOCAL) { \
+		__rbuf = sclib_memory_alloc(&sclib_data[__sysid], __sz); \
+		SCLIB_MEM_RET(__rbuf, __ret); \
+		memcpy(__rbuf, __dpath, __sz); \
+		__ret = SCLIB_REMOTE_CALL(__sysid, call, par, sclib_mem(__sysid, __rbuf), ##__VA_ARGS__); \
+		sclib_memory_free(&sclib_data[__sysid], __rbuf); \
+	} else { \
+		__ret = SCLIB_LOCAL_CALL(call, par, __dpath, ##__VA_ARGS__); \
+	} \
+error_mem: \
+	SCLIB_ERR_RET(__ret); \
+	__ret; }))
+
+#define SCLIB_PATH_INBUF_CALL(call, sz, par, path, buf, ...) (__extension__ ({ \
+	char __abspath[PATH_MAX], *__dpath; \
+	long __ret; \
+	int __sysid; \
+	void *__rbuf, *__off; \
+	size_t __sz1, __sz2; \
+    __dpath = sclib_get_path(__abspath, (path), &__sysid, &__sz2); \
+	if (__sysid != SYSCALL_SYSID_LOCAL) { \
+		__sz1 = (sz); \
+		__rbuf = sclib_memory_alloc(&sclib_data[__sysid], __sz1 + __sz2); \
+		SCLIB_MEM_RET(__rbuf, __ret); \
+		memcpy(mempcpy(__rbuf, (buf), __sz1), __dpath, __sz2); \
+		__off = sclib_mem(__sysid, __rbuf); \
+		__ret = SCLIB_REMOTE_CALL(__sysid, call, par, __off + __sz1, __off, ##__VA_ARGS__); \
+		sclib_memory_free(&sclib_data[__sysid], __rbuf); \
+	} else { \
+		__ret = SCLIB_LOCAL_CALL(call, par, __dpath, (buf), ##__VA_ARGS__); \
+	} \
+error_mem: \
+	SCLIB_ERR_RET(__ret); \
+	__ret; }))
+
+#define SCLIB_PATH_OUTBUF_CALL(call, sz, par, path, buf, ...) (__extension__ ({ \
+	char __abspath[PATH_MAX], *__dpath; \
+	long __ret; \
+	int __sysid; \
+	void *__rbuf, *__off; \
+	size_t __sz1, __sz2; \
+    __dpath = sclib_get_path(__abspath, (path), &__sysid, &__sz2); \
+	if (__sysid != SYSCALL_SYSID_LOCAL) { \
+		__sz1 = (sz); \
+		__rbuf = sclib_memory_alloc(&sclib_data[__sysid], __sz1 + __sz2); \
+		SCLIB_MEM_RET(__rbuf, __ret); \
+		memcpy(__rbuf + __sz1, __dpath, __sz2); \
+		__off = sclib_mem(__sysid, __rbuf); \
+		__ret = SCLIB_REMOTE_CALL(__sysid, call, par, __off + __sz1, __off, ##__VA_ARGS__); \
+		if (!SCLIB_IS_ERR(__ret)) \
+			memcpy((buf), __rbuf, __sz1); \
+		sclib_memory_free(&sclib_data[__sysid], __rbuf); \
+	} else { \
+		__ret = SCLIB_LOCAL_CALL(call, par, __dpath, (buf), ##__VA_ARGS__); \
+	} \
+error_mem: \
+	SCLIB_ERR_RET(__ret); \
+	__ret; }))
+
+static inline const char *sclib_get_link(const char *path, int *sysid)
+{
+	char ch;
+
+	if (*path == '/')
+	{
+		while (*(path + 1) == '/')
+			path++;
+		if (strncmp(path, SCLIB_STORAGE_PREFIX, sizeof(SCLIB_STORAGE_PREFIX) - 1) == 0) {
+			ch = path[sizeof(SCLIB_STORAGE_PREFIX) - 1];
+			if (ch == '\0' || ch == '/') {
+				*sysid = SYSCALL_SYSID_STORAGE;
+				return path + sizeof(SCLIB_STORAGE_PREFIX) - 1;
+			}
+		}
+		*sysid = SYSCALL_SYSID_LOCAL;
+	} else {
+		*sysid = SYSCALL_SYSID_ALL;
+	}
+	return path;
+}
+
+#define SCLIB_PATH_CALL2(call, par, oldpath, newpath, ...) (__extension__ ({ \
+	char __abspath1[PATH_MAX], *__dpath1, __abspath2[PATH_MAX], *__dpath2; \
+	long __ret; \
+	int __sysid, __sysid2; \
+	void *__rbuf, *__off; \
+	size_t __sz2, __sz1; \
+	__dpath1 = sclib_get_path(__abspath1, (oldpath), &__sysid, &__sz1); \
+	__dpath2 = sclib_get_path(__abspath2, (newpath), &__sysid2, &__sz2); \
+	if (__sysid != __sysid2) { \
+		__ret = -EINVAL; \
+		goto error_mem; \
+	} \
+	if (__sysid != SYSCALL_SYSID_LOCAL) { \
+		__rbuf = sclib_memory_alloc(&sclib_data[__sysid], __sz1 + __sz2); \
+		SCLIB_MEM_RET(__rbuf, __ret); \
+		memcpy(mempcpy(__rbuf, __dpath1, __sz1), __dpath2, __sz2); \
+		__off = sclib_mem(__sysid, __rbuf); \
+		__ret = SCLIB_REMOTE_CALL(__sysid, call, par, __off, __off + __sz1, ##__VA_ARGS__); \
+		sclib_memory_free(&sclib_data[__sysid], __rbuf); \
+	} else { \
+		__ret = SCLIB_LOCAL_CALL(call, par, __dpath1, __dpath2, ##__VA_ARGS__); \
+	} \
+error_mem: \
+	SCLIB_ERR_RET(__ret); \
+	__ret; }))
+
+#define SCLIB_LOCAL_CALL(call, num, ...) (__extension__ ({ \
+	INTERNAL_SYSCALL_DECL(__err); \
+	long __retval = INTERNAL_SYSCALL(call, __err, num, ##__VA_ARGS__); \
+	if (INTERNAL_SYSCALL_ERROR_P(__retval, __err)) \
+		__retval = -INTERNAL_SYSCALL_ERRNO(__retval, __err); \
+	__retval; }))
+
+#define SCLIB_ALL_SIMPLE_CALL(call, num, ...) (__extension__ ({				\
+	void *__pos[SYSCALL_SYSIDS];											\
+	long __lret, __rret;													\
+	size_t __i;																\
+	for (__i = 0; __i < SYSCALL_SYSIDS; __i++) {							\
+		__pos[__i] =														\
+			SCLIB_REMOTE_CALL_ASYNC(__i, call, num, ##__VA_ARGS__);			\
+	}																		\
+	__lret = SCLIB_LOCAL_CALL(call, num, ##__VA_ARGS__);					\
+	for (__i = 0; __i < SYSCALL_SYSIDS; __i++) {							\
+		__rret = SCLIB_REMOTE_CALL_RESULT(__i, call, __pos[__i]);			\
+		if (SCLIB_IS_ERR(__rret))											\
+			__lret = __rret;												\
+	}																		\
+	__lret; }))
+
+#define __SCLIB_REMOTE_ARGS0(e)
+#define __SCLIB_REMOTE_ARGS1(e, x0)	(e[0] = (long) (x0))
+#define __SCLIB_REMOTE_ARGS2(e, x0, x1)	\
+	__SCLIB_REMOTE_ARGS1(e, x0); e[1] = (long) (x1);
+#define __SCLIB_REMOTE_ARGS3(e, x0, x1, x2)	\
+	__SCLIB_REMOTE_ARGS2(e, x0, x1); e[2] = (long) (x2);
+#define __SCLIB_REMOTE_ARGS4(e, x0, x1, x2, x3)	\
+	__SCLIB_REMOTE_ARGS3(e, x0, x1, x2); e[3] = (long) (x3);
+#define __SCLIB_REMOTE_ARGS5(e, x0, x1, x2, x3, x4)	\
+	__SCLIB_REMOTE_ARGS4(e, x0, x1, x2, x3); e[4] = (long) (x4);
+#define __SCLIB_REMOTE_ARGS6(e, x0, x1, x2, x3, x4, x5)	\
+	__SCLIB_REMOTE_ARGS5(e, x0, x1, x2, x3, x4); e[5] = (long) (x5);
+
+#define __SCLIB_REMOTE_CALL(rwidth, sysid, call, num, ...) (__extension__ ({ \
+	syscall_entry_t *__entry = sclib_get_entry(&sclib_data[sysid]); \
+	__SCLIB_REMOTE_ARGS##num(__entry->args, ##__VA_ARGS__); \
+	__entry->pd = THREAD_SELF; \
+	__entry->task_id = sclib_thread.task_id; \
+	__entry->seq_num = sclib_thread.seq_num++; \
+	__entry->id = __NRR_##call; \
+	__entry->signal = 0; \
+	sclib_put_entry(sysid, __entry); \
+	sclib_get_result_##rwidth(&sclib_data[sysid].buffer->page, sysid, __entry); }))
+
+#define SCLIB_REMOTE_CALL_DW(...)	\
+	__SCLIB_REMOTE_CALL(dw, ##__VA_ARGS__)
+
+#define SCLIB_REMOTE_CALL(...)	\
+	__SCLIB_REMOTE_CALL(sw, ##__VA_ARGS__)
+
+#define SCLIB_REMOTE_CALL_ASYNC(sysid, call, num, ...) (__extension__ ({ \
+	syscall_entry_t *__entry = sclib_get_entry(&sclib_data[sysid]); \
+	__SCLIB_REMOTE_ARGS##num(__entry->args, ##__VA_ARGS__); \
+	__entry->pd = THREAD_SELF; \
+	__entry->task_id = sclib_thread.task_id; \
+	__entry->seq_num = sclib_thread.seq_num++; \
+	__entry->id = __NRR_##call;	\
+	__entry->signal = 0; \
+	sclib_put_entry(sysid, __entry); \
+	__entry; }))
+
+#define __SCLIB_REMOTE_CALL_RESULT(rwidth, sysid, call, __entry_ptr)	\
+	sclib_get_result_##rwidth(&sclib_data[sysid].buffer->page, sysid, __entry_ptr)
+
+#define SCLIB_REMOTE_CALL_RESULT_DW(sysid, call, __entry_ptr)	\
+	__SCLIB_REMOTE_CALL_RESULT(dw, sysid, call, __entry_ptr)
+
+#define SCLIB_REMOTE_CALL_RESULT(sysid, call, __entry_ptr)	\
+	__SCLIB_REMOTE_CALL_RESULT(sw, sysid, call, __entry_ptr)
+
+#define SCLIB_SYSID_CALL(sysid, ...) (__extension__ ({ \
+	long __r; \
+	if ((sysid) != SYSCALL_SYSID_LOCAL) \
+		__r = SCLIB_REMOTE_CALL(sysid, __VA_ARGS__); \
+	else \
+		__r = SCLIB_LOCAL_CALL(__VA_ARGS__); \
+	__r; }))
+
+#define SCLIB_SYSID_CALL_BUFFER(sysid, call, par, arg0, argb, ...) (__extension__ ({ \
+	long __r; \
+	if ((sysid) != SYSCALL_SYSID_LOCAL) \
+		__r = SCLIB_REMOTE_CALL(sysid, call, par, arg0, sclib_mem(sysid, argb), ##__VA_ARGS__); \
+	else \
+		__r = SCLIB_LOCAL_CALL(call, par, arg0, argb, ##__VA_ARGS__); \
+	__r; }))
+
+#define SCLIB_FILE_TABLE_LENGTH		1024
+#define SCLIB_FD_EXEC				0x01
+#define SCLIB_FD_TRAN				0x02
+
+#ifdef SYSCALL_DEBUG
+
+# define SCLIB_STRACE_DEBUG(fmt, ...) (__extension__ ({ \
+	char __buf[64];														\
+	size_t __num = snprintf(__buf, sizeof(__buf), (fmt), ##__VA_ARGS__);	\
+	if (__num > sizeof(__buf) - 1)											\
+		__num = sizeof(__buf) - 1;											\
+	SCLIB_LOCAL_CALL(write, 3, -1, __buf, __num);							\
+}))
+
+# define SCLIB_LOCK_CHECK_INIT	\
+	size_t __lock_check_counter = 500000;
+
+# define SCLIB_LOCK_CHECK_STEP					do {		\
+	if (--__lock_check_counter == 0) {						\
+		fprintf(stderr, "LOCKUP BUG: %s\n", __FUNCTION__);	\
+		SCLIB_STRACE_DEBUG("LOCKUP BUG: %s\n", __FUNCTION__);	\
+		_exit(1);											\
+	}														\
+} while (0);
+
+#else
+
+# define SCLIB_STRACE_DEBUG(fmt, ...)
+# define SCLIB_LOCK_CHECK_INIT
+# define SCLIB_LOCK_CHECK_STEP
+
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef int16_t sclib_fd_t;
+
+typedef struct sclib_file_entry_s {
+	sclib_fd_t dfd;
+	sclib_fd_t aux[SYSCALL_SYSIDS];
+	uint8_t ectl_doms;
+	int8_t sysid;
+	uint8_t flags;
+	uint8_t _pad;
+	uint32_t counter;
+	uint32_t flags_counter;
+} sclib_file_entry_t;
+
+typedef struct sclib_file_table_s {
+	sclib_file_entry_t fds[SCLIB_FILE_TABLE_LENGTH];
+	unsigned long bitmap[SCLIB_FILE_TABLE_LENGTH / (sizeof(long) * 8)];
+	long fd[SYSCALL_SYSIDS];
+	char curdir[PATH_MAX];
+	size_t curdir_size;
+} sclib_file_table_t;
+
+void sclib_file_replace(sclib_file_table_t *file, long fd, long dfd, int sysid,
+	sclib_fd_t *aux);
+libc_hidden_proto(sclib_file_replace)
+
+long sclib_file_close(sclib_file_table_t *file, long fd);
+libc_hidden_proto(sclib_file_close)
+
+static inline long sclib_bitmap_find(unsigned long *bitmap, size_t size,
+	size_t start)
+{
+	unsigned long val;
+	size_t i, shift, mask = (sizeof(long) * 8) - 1;
+
+	i = (start & ~mask) / 8;
+	shift = start & mask;
+	if (!__builtin_constant_p(start) || shift) {
+		val = (*(unsigned long *) ((char *) bitmap + i)) & (ULONG_MAX << shift);
+		if (val != 0)
+			return __builtin_ctzl(val) + i * 8;
+		i += sizeof(long);
+	}
+
+	for (; i != size; i += sizeof(long)) {
+		val = *(unsigned long *) ((char *) bitmap + i);
+		if (val != 0)
+			return __builtin_ctzl(val) + i * 8;
+	}
+	return -EMFILE;
+}
+
+static inline void sclib_bitmap_toggle(unsigned long *bitmap, size_t pos)
+{
+	size_t i = pos / (sizeof(long) * 8);
+	size_t shift = pos % (sizeof(long) * 8);
+	__sync_fetch_and_xor(bitmap + i, 1UL << shift);
+}
+
+static inline bool sclib_replace_lock_fd(sclib_file_table_t *file, long fd)
+{
+	uint32_t val;
+	SCLIB_LOCK_CHECK_INIT
+	do {
+		SCLIB_LOCK_CHECK_STEP
+		val = __sync_val_compare_and_swap(&file->fds[fd].counter, 3, 1);
+		if (val == 0) {
+			if (__sync_bool_compare_and_swap(&file->fds[fd].counter, 0, 1))
+				return false;
+		}
+	} while (val != 3);
+
+	return true;
+}
+
+static inline void sclib_replace_unlock_fd(sclib_file_table_t *file, long fd)
+{
+	__sync_fetch_and_add(&file->fds[fd].counter, 2); /* Counter = 3 (ready) */
+}
+
+static inline bool sclib_incref_fd(sclib_file_table_t *file, long fd)
+{
+	uint32_t val;
+
+	/* Increment if file is in ready state */
+	do {
+		val = file->fds[fd].counter;
+		if (val <= 2)
+			return false;
+	} while (!__sync_bool_compare_and_swap(&file->fds[fd].counter, val, val + 1));
+	return true;
+}
+
+static inline void sclib_putref_fd(sclib_file_table_t *file, long fd, uint32_t step)
+{
+	if (__sync_sub_and_fetch(&file->fds[fd].counter, step) == 2) {
+		sclib_file_close(file, fd);
+		file->fds[fd].dfd = -1;
+		sclib_bitmap_toggle(file->bitmap, fd);
+		__sync_fetch_and_sub(&file->fds[fd].counter, 2);
+	}
+}
+
+static inline void sclib_write_lock_fd_flags(sclib_file_table_t *file, long fd)
+{
+	SCLIB_LOCK_CHECK_INIT
+	/* Move from ready state (1) to write state (0) */
+	while (!__sync_bool_compare_and_swap(&file->fds[fd].flags_counter, 1, 0)) {
+		SCLIB_LOCK_CHECK_STEP
+	}
+}
+
+static inline void sclib_write_unlock_fd_flags(sclib_file_table_t *file, long fd)
+{
+	__sync_fetch_and_add(&file->fds[fd].flags_counter, 1);
+}
+
+static inline void sclib_read_lock_fd_flags(sclib_file_table_t *file, long fd)
+{
+	uint32_t val;
+	SCLIB_LOCK_CHECK_INIT
+
+	/* Move from ready state (1) to read state (> 1) */
+	do {
+		SCLIB_LOCK_CHECK_STEP
+		val = file->fds[fd].flags_counter;
+	} while (val == 0 || !__sync_bool_compare_and_swap(&file->fds[fd].flags_counter, val, val + 1));
+}
+
+static inline void sclib_read_unlock_fd_flags(sclib_file_table_t *file, long fd)
+{
+	__sync_fetch_and_sub(&file->fds[fd].flags_counter, 1);
+}
+
+static inline long sclib_file_add(sclib_file_table_t *file,
+	unsigned long start_fd)
+{
+	long fd;
+	SCLIB_LOCK_CHECK_INIT
+
+	do {
+		SCLIB_LOCK_CHECK_STEP
+		/* Optimistic search */
+		fd = sclib_bitmap_find(file->bitmap, sizeof(file->bitmap), start_fd);
+		if (unlikely(fd < 0))
+			return fd;
+	} while (!__sync_bool_compare_and_swap(&file->fds[fd].counter, 0, 1));
+	sclib_bitmap_toggle(file->bitmap, fd);
+	return fd;
+}
+
+static inline sclib_fd_t *sclib_file_aux(sclib_file_table_t *file, long fd)
+{
+	return file->fds[fd].aux;
+}
+
+static inline void sclib_file_add_fail(sclib_file_table_t *file, long fd)
+{
+	sclib_bitmap_toggle(file->bitmap, fd); /* Cancel allocation */
+	__sync_fetch_and_sub(&file->fds[fd].counter, 1); /* Counter = 0 (free) */
+}
+
+static inline void sclib_file_add_ok(sclib_file_table_t *file, long fd, long dfd, int sysid, uint8_t flags, uint8_t ectl_doms)
+{
+	file->fds[fd].dfd = dfd;
+	file->fds[fd].sysid = sysid;
+	file->fds[fd].flags = flags;
+	file->fds[fd].ectl_doms = ectl_doms;
+	__sync_fetch_and_add(&file->fds[fd].counter, 2); /* Counter = 3 (ready) */
+}
+
+static inline void sclib_file_add_done(sclib_file_table_t *file, long fd, long dfd, int sysid, uint8_t flags, uint8_t ectl_doms)
+{
+	if (SCLIB_IS_ERR(dfd)) {
+		sclib_file_add_fail(file, fd);
+	} else {
+		sclib_file_add_ok(file, fd, dfd, sysid, flags, ectl_doms);
+	}
+}
+
+static inline long sclib_file_get(sclib_file_table_t *file, long fd, int sysid)
+{
+	int id;
+	long dfd;
+
+	if (unlikely((unsigned long) fd >= SCLIB_FILE_TABLE_LENGTH
+			|| !sclib_incref_fd(file, fd)))
+		return -EBADF;
+	id = file->fds[fd].sysid;
+	dfd = file->fds[fd].dfd;
+	if (unlikely(sysid != id)) {
+		sclib_putref_fd(file, fd, 1);
+		return -EINVAL;
+	}
+	return dfd;
+}
+
+static inline long sclib_file_getid(sclib_file_table_t *file, long fd, int *sysid)
+{
+	long dfd;
+
+	*sysid = SYSCALL_SYSID_LOCAL;
+	if (unlikely((unsigned long) fd >= SCLIB_FILE_TABLE_LENGTH
+			|| !sclib_incref_fd(file, fd)))
+		return -EBADF;
+	dfd = file->fds[fd].dfd;
+	*sysid = file->fds[fd].sysid;
+	return dfd;
+}
+
+static inline long sclib_file_touch(sclib_file_table_t *file, long fd, int *sysid)
+{
+	long dfd;
+
+	dfd = file->fds[fd].dfd;
+	*sysid = file->fds[fd].sysid;
+	return dfd;
+}
+
+static inline void sclib_file_put(sclib_file_table_t *file, long fd)
+{
+	sclib_putref_fd(file, fd, 1);
+}
+
+static inline void sclib_file_release(sclib_file_table_t *file, long fd)
+{
+	sclib_putref_fd(file, fd, 2);
+}
+
+static inline long sclib_file_reverse_lookup(sclib_file_table_t *file, unsigned long dfd)
+{
+	size_t fd;
+	int found = 0;
+
+	for (fd = 0; fd < SCLIB_FILE_TABLE_LENGTH; fd++) {
+		if (!sclib_incref_fd(file, fd))
+			continue;
+		if ((unsigned long) file->fds[fd].dfd == dfd)
+			found = 1;
+		sclib_putref_fd(file, fd, 1);
+		if (found)
+			return fd;
+	}
+	return -EINVAL;
+}
+
+struct sclib_memory_list_s;
+typedef struct sclib_memory_list_s sclib_memory_list_t;
+
+struct sclib_memory_list_s {
+	sclib_memory_list_t *pred;
+	sclib_memory_list_t *succ;
+};
+
+typedef struct sclib_buffer_s {
+	syscall_wake_page_t wake_page;
+	syscall_page_t page;
+	char data[0];
+} sclib_buffer_t;
+
+typedef struct sclib_data_s {
+	sclib_buffer_t *buffer;
+	long memoff;
+	sclib_memory_list_t memory;
+	char *map_start;
+	char *map_end;
+	unsigned long map_pos;
+	long sysid;
+} sclib_data_t;
+
+typedef struct sclib_thread_data {
+	long efd[SYSCALL_SYSIDS+1];
+	unsigned int task_id;
+	unsigned int seq_num;
+} sclib_thread_data_t;
+
+extern sclib_data_t sclib_data[SYSCALL_SYSIDS];
+libc_hidden_proto(sclib_data)
+
+typedef struct sclib_miscdata_s {
+	long membase;
+	long domfd;
+} sclib_miscdata_t;
+
+extern sclib_miscdata_t sclib_miscdata[SYSCALL_SYSIDS];
+libc_hidden_proto(sclib_miscdata)
+
+extern sclib_file_table_t sclib_file;
+libc_hidden_proto(sclib_file)
+
+#ifdef __UCLIBC_HAS_TLS__
+extern __thread sclib_thread_data_t sclib_thread;
+#else
+# error "Need TLS support for SCLIB thread data"
+#endif
+
+void *sclib_memory_alloc(sclib_data_t *data, size_t size);
+libc_hidden_proto(sclib_memory_alloc)
+
+void sclib_memory_free(sclib_data_t *data, void *addr);
+libc_hidden_proto(sclib_memory_free)
+
+ssize_t sclib_iovec_length(const struct iovec *iov, size_t count);
+libc_hidden_proto(sclib_iovec_length)
+
+void *sclib_copy_from_iovec(void *to, struct sclib_iovc *from, size_t count);
+libc_hidden_proto(sclib_copy_from_iovec)
+
+void sclib_copy_to_iovec(struct sclib_iovc *to, const void *from, size_t length);
+libc_hidden_proto(sclib_copy_to_iovec)
+
+struct msghdr *sclib_init_msghdr(struct msghdr *to, const struct msghdr *from,
+								 size_t total_iovlen, struct msghdr *rto);
+libc_hidden_proto(sclib_init_msghdr)
+
+void sclib_copy_from_msghdr(struct msghdr *to, const struct msghdr *msg,
+							 size_t total_iovlen);
+libc_hidden_proto(sclib_copy_from_msghdr)
+
+void sclib_copy_to_msghdr(struct msghdr *msg, const struct msghdr *from,
+						size_t length, size_t total_iovlen,
+						size_t controllen, size_t namelen);
+libc_hidden_proto(sclib_copy_to_msghdr)
+
+long sclib_copy_file(long in_dfd, __off_t *in_off, long out_dfd, __off_t *out_off, size_t len, int in_sysid, int out_sysid);
+libc_hidden_proto(sclib_copy_file)
+
+long sclib_copy64_file(long in_dfd, __off64_t *in_off, long out_dfd, __off64_t *out_off, size_t len, int in_sysid, int out_sysid);
+libc_hidden_proto(sclib_copy64_file)
+
+static inline syscall_entry_t *sclib_get_entry(sclib_data_t *data)
+{
+	SCLIB_LOCK_CHECK_INIT
+	syscall_page_t *page = &data->buffer->page;
+	size_t eidx;
+
+	while (1) {
+		SCLIB_LOCK_CHECK_STEP
+		eidx = syscall_stack_pop(page->next, &page->free_top, SYSCALL_MAX_ENTRIES);
+		if (unlikely(eidx == SYSCALL_ERROR_ENTRY)) {
+			fprintf(stderr, "ERROR: fatal (free) dequeue error!\n");
+			_exit(1);
+		}
+		if (eidx != SYSCALL_NULL_ENTRY)
+			return &page->entry[eidx];
+		sched_yield();
+	}
+}
+
+static inline void sclib_put_entry(int sysid, syscall_entry_t *entry)
+{
+	uint64_t running_threads;
+	syscall_wake_page_t *wake_page = &sclib_data[sysid].buffer->wake_page;
+	syscall_page_t *page = &sclib_data[sysid].buffer->page;
+
+	syscall_stack_push(page->next, &page->alloc_top, (size_t) (entry - page->entry));
+	/* Notify the other side if necessary */
+	running_threads = wake_page->running_threads;
+	if ((running_threads & (SYSCALL_WAKE_REQUESTED | SYSCALL_WAKE_IN_PROGRESS)) == SYSCALL_WAKE_REQUESTED)
+		SCLIB_LOCAL_CALL(ioctl, 3, sclib_miscdata[sysid].domfd, SYSCALL_DRIVER_IOCTL_WAKE, 0);
+}
+
+static inline void sclib_wait_efd(struct syscall_efd *param, long efd)
+{
+	uint64_t val;
+	size_t efd_num;
+
+	efd_num = param->efd_num;
+	if (efd_num == 0)
+		return;
+	if ((ssize_t) efd_num < 0) {
+		efd_num = SCLIB_LOCAL_CALL(syscall_service_notify, 1, param);
+		if (efd_num == 0)
+			return;
+	}
+
+	do {
+		if (SCLIB_LOCAL_CALL(read, 3, efd, &val, sizeof(uint64_t)) == sizeof(uint64_t))
+			efd_num--;
+	} while (efd_num != 0);
+}
+
+#define __SCLIB_DECLARE_GET_RESULT(rwidth, _type)						\
+static inline _type sclib_get_result_##rwidth(syscall_page_t *page,		\
+			int sysid, syscall_entry_t *entry)							\
+{																		\
+	_type ret;															\
+	__sclib_schedule(sysid, entry);										\
+	ret  = syscall_entry_result_##rwidth(entry);						\
+	syscall_stack_push(page->next, &page->free_top,						\
+		(size_t) (entry - page->entry));								\
+	return ret;															\
+}
+
+__SCLIB_DECLARE_GET_RESULT(sw, long)
+__SCLIB_DECLARE_GET_RESULT(dw, syscall_sdw_t)
+
+static inline void *sclib_mem(int sysid, void *addr)
+{
+	return (char *) addr + sclib_data[sysid].memoff;
+}
+
+static inline void *sclib_usermem(int sysid, void *addr)
+{
+	return (char *) addr - sclib_data[sysid].memoff;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_SCLIB_PUBLIC_H */
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/bits/sclib_syscalls.h uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/sclib_syscalls.h
--- uClibc-0.9.33/libc/sysdeps/linux/common/bits/sclib_syscalls.h	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/sclib_syscalls.h	2013-09-23 20:39:32.946222861 -0400
@@ -0,0 +1,70 @@
+/**
+ * VM-Syscalls
+ * Copyright (c) 2012 Ruslan Nikolaev <rnikola@vt.edu>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef _SCLIB_SYSCALLS_H
+#define _SCLIB_SYSCALLS_H
+
+#include <inttypes.h>
+#include <sys/types.h>
+#include <libc-symbols.h>
+#include <stdio.h>
+
+#include <bits/sclib.h>
+
+#define SCLIB_CLONE_THREAD	0x7FFFFFFFL
+
+long __internal_sys_read(int fd, void *buf, size_t count);
+libc_hidden_proto(__internal_sys_read)
+
+long __internal_sys_write(int fd, const void *buf, size_t count);
+libc_hidden_proto(__internal_sys_write)
+
+long __internal_sys_open(const char * file, int flags, int mode);
+libc_hidden_proto(__internal_sys_open)
+
+long __internal_sys_close(int fd);
+libc_hidden_proto(__internal_sys_close)
+
+long __internal_sys_clone_begin(long flags);
+libc_hidden_proto(__internal_sys_clone_begin)
+
+static inline void __internal_sys_clone_thread(void)
+{
+	sclib_memory_prealloc_init();
+	/* Better way to handle error? */
+	if (SCLIB_IS_ERR(sclib_efds_open(false))) {
+		fprintf(stderr, "ERROR: Cannot initialize EFDS!\n");
+		exit(1);
+	}
+}
+
+void __internal_sys_clone_child(long param);
+libc_hidden_proto(__internal_sys_clone_child)
+
+long __internal_sys_clone_parent(long ret, long param);
+libc_hidden_proto(__internal_sys_clone_parent)
+
+long __internal_sys_fork(void);
+libc_hidden_proto(__internal_sys_fork)
+
+#endif /* !_SCLIB_SYSCALLS_H */
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/bits/_syscall_defs.h uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/_syscall_defs.h
--- uClibc-0.9.33/libc/sysdeps/linux/common/bits/_syscall_defs.h	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/_syscall_defs.h	2013-09-23 20:40:57.766226376 -0400
@@ -0,0 +1,53 @@
+/**
+ * VM-Syscalls
+ * Copyright (c) 2013 Ruslan Nikolaev <rnikola@vt.edu>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef _SYSCALL_COMMON_DEFS_H
+#define _SYSCALL_COMMON_DEFS_H 1
+
+typedef struct syscall_ptr {
+	size_t index; /* Must be first! */
+	size_t stamp;
+} __attribute__ ((aligned(sizeof(size_t) * 2))) syscall_ptr_t;
+
+#define SYSCALL_NULL_ENTRY			(size_t) (-1L)
+#define SYSCALL_ERROR_ENTRY			(size_t) (-2L)
+#define SYSCALL_REPEAT_ENTRY		(size_t) (-3L)
+
+#define VOLATILE_READ(x)		(*(volatile __typeof__(x) *) &(x))
+#define VOLATILE_READ_FAULT(x) ({		\
+	__typeof__(x) __r;					\
+	if (__get_user(__r, &(x)) != 0)		\
+		goto error_fault;				\
+	__r;								\
+})
+
+#define VOLATILE_READ_FAULT_PTR(x) ({				\
+	__typeof__(x) __r;								\
+	if (__get_user(__r.index, &(x).index) != 0)		\
+		goto error_fault;							\
+	if (__get_user(__r.stamp, &(x).stamp) != 0)		\
+		goto error_fault;							\
+	__r;											\
+})
+
+#endif /* !_SYSCALL_COMMON_DEFS_H */
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/bits/_syscall.h uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/_syscall.h
--- uClibc-0.9.33/libc/sysdeps/linux/common/bits/_syscall.h	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/_syscall.h	2013-09-23 20:39:32.946222861 -0400
@@ -0,0 +1,243 @@
+/**
+ * VM-Syscalls
+ * Copyright (c) 2012 Ruslan Nikolaev <rnikola@vt.edu>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef _SYSCALL_COMMON_SYSCALL_H
+#define _SYSCALL_COMMON_SYSCALL_H 1
+
+#include "_syscall_defs.h"
+
+/* Hypercall parameters */
+#define SYSCALL_SERVICE_PREPARE			0
+#define SYSCALL_SERVICE_CANCEL			1
+#define SYSCALL_SERVICE_CONNECT			2
+#define SYSCALL_SERVICE_DISCONNECT		3
+#define SYSCALL_SERVICE_CLEANUP			4
+#define SYSCALL_SERVICE_REGISTER		5
+#define SYSCALL_SERVICE_UNREGISTER		6
+
+/* Syscall service states */
+#define SYSCALL_STATE_TERMINATED		0
+#define SYSCALL_STATE_RUNNING			(unsigned long) (LONG_MIN)
+
+/* Main ring buffer requests */
+#define SYSCALL_ACTION_INIT				0
+#define SYSCALL_ACTION_ADD				1
+#define SYSCALL_ACTION_REMOVE			2
+#define SYSCALL_ACTION_EXPAND_MAP		3
+#define SYSCALL_ACTION_SHRINK_MAP		4
+
+#define SYSCALL_PREALLOC_PROCESSES		8
+
+#define SYSCALL_SYSID_NETWORK			0
+#define SYSCALL_SYSID_STORAGE			1
+#define SYSCALL_SYSIDS					2
+
+#define SYSCALL_QUEUE_ORDER				3
+#define SYSCALL_QUEUE_PAGES				(1U << SYSCALL_QUEUE_ORDER)
+#define SYSCALL_CALL_PAGES				8
+#define SYSCALL_PAGES					(SYSCALL_CALL_PAGES + 1)
+#define SYSCALL_DATA_SHARED_PAGES		8192
+#define SYSCALL_TOTAL_SHARED_PAGES		(SYSCALL_PAGES + SYSCALL_DATA_SHARED_PAGES)
+#define SYSCALL_MAX_EXPAND_MAP_GREFS		80
+#define SYSCALL_MAX_GROUPS					16
+#define SYSCALL_FDTABLE_PATH				"/tmp/sclib_"
+
+#define SYSCALL_IOCTL_MAGIC					0x81
+#define SYSCALL_DRIVER_IOCTL_REGISTER		_IO(SYSCALL_IOCTL_MAGIC, 0)
+#define SYSCALL_DRIVER_IOCTL_EXPAND_BUFFER	_IO(SYSCALL_IOCTL_MAGIC, 1)
+#define SYSCALL_DRIVER_IOCTL_SHRINK_BUFFER	_IO(SYSCALL_IOCTL_MAGIC, 2)
+#define SYSCALL_DRIVER_IOCTL_WAKE			_IO(SYSCALL_IOCTL_MAGIC, 3)
+#define SYSCALL_SERVICE_IOCTL_CONNECT		_IO(SYSCALL_IOCTL_MAGIC, 8)
+#define SYSCALL_SERVICE_IOCTL_DISCONNECT	_IO(SYSCALL_IOCTL_MAGIC, 9)
+#define SYSCALL_SERVICE_IOCTL_CLEANUP		_IO(SYSCALL_IOCTL_MAGIC, 10)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct syscall_connect {
+	uint32_t	domid;
+	uint32_t	main_port;
+	uint32_t	ring_port;
+	uint32_t	disconnect_port;
+	uint32_t	wake_port;
+	uint32_t	main_gref;
+	uint32_t	front_ring_gref;
+	uint32_t	back_ring_gref;
+	uint32_t	wake_gref;
+} syscall_connect_t;
+
+//#define SYSCALL_DEBUG
+
+#ifdef __KERNEL__
+
+#include <xen/interface/io/ring.h>
+
+typedef struct syscall_prealloc {
+	uint32_t	id;
+	uint32_t	gref[SYSCALL_CALL_PAGES];
+} syscall_prealloc_t;
+
+typedef struct syscall_prealloc_process {
+	syscall_ptr_t alloc_top;
+	syscall_ptr_t free_top;
+	size_t next[SYSCALL_PREALLOC_PROCESSES];
+	syscall_prealloc_t entry[SYSCALL_PREALLOC_PROCESSES];
+} syscall_prealloc_process_t;
+
+struct sccom_request_add {
+	uint32_t	id;
+	uint32_t	ptgid;
+	uint32_t	gref[SYSCALL_QUEUE_PAGES];
+	struct cred_move	cm;
+	gid_t	_pad[SYSCALL_MAX_GROUPS];	/* Groups for credentials */
+};
+
+struct sccom_request_memory {
+	uint32_t	num;
+};
+
+struct sccom_response {
+	uint32_t	tgid;
+	uint32_t	num;
+	union {
+		syscall_prealloc_t	prealloc[SYSCALL_PREALLOC_PROCESSES];
+		uint32_t			grefs[SYSCALL_MAX_EXPAND_MAP_GREFS];
+	};
+};
+
+struct sccom_request {
+	int			id;
+	uint32_t	tgid;
+	union {
+		struct sccom_request_add	add;
+		struct sccom_request_memory	mem;
+	};
+};
+
+struct screq_response {
+	int			id;
+	uint32_t	tgid;
+	uint32_t	pid;
+};
+
+struct screq_request {
+	char		pad[0]; /* Just a stub */
+};
+
+#define RING_FULL_RSP(_r)	\
+	(RING_SIZE(_r) - ((_r)->rsp_prod_pvt - (_r)->sring->rsp_event) == 1)
+
+DEFINE_RING_TYPES(sccom, struct sccom_request, struct sccom_response);
+DEFINE_RING_TYPES(screq, struct screq_request, struct screq_response);
+
+#ifdef SYSCALL_DEBUG
+# define SYSCALL_TRACE(fmt, ...)	printk(KERN_INFO "[SC-CALL:%u:%u] " fmt, current->tgid, current->pid, ##__VA_ARGS__)
+#else
+# define SYSCALL_TRACE(fmt, ...)
+#endif
+
+#define SYSCALL_WARNING(fmt, ...)		printk(KERN_WARNING "[SC-WARNING:%u:%u] " fmt, current->tgid, current->pid, ##__VA_ARGS__)
+
+#define SYSCALL_ERROR(fmt, ...)		printk(KERN_ERR "[SC-ERROR:%u:%u] " fmt, current->tgid, current->pid, ##__VA_ARGS__)
+
+#endif /* __KERNEL__ */
+
+#define SYSCALL_REQUEST_FD			0x7FFFFFFF
+#define SYSCALL_REQUEST_NOTIFY		0x7FFFFFFF
+#define SYSCALL_REQUEST_SIGNAL(x)	((x) | 0x80000000)
+
+#define SYSCALL_ENTRY_RQUEUE		0x80U
+#define SYSCALL_ENTRY_DONE			0xFFU
+
+/* Double word definition */
+#if defined(__x86_64__)
+typedef __int128_t syscall_sdw_t;
+typedef __uint128_t syscall_udw_t;
+# define SYSCALL_INT_PTR(x)				((int *) (x))	/* Little Endian */
+#elif defined(__i386__)
+typedef int64_t syscall_sdw_t;
+typedef uint64_t syscall_udw_t;
+# define SYSCALL_INT_PTR(x)				((int *) (x))	/* Little Endian */
+#endif
+
+#define syscall_entry_result_lower(x)	((x)->args[0])
+#define syscall_entry_result_upper(x)	((x)->args[1])
+
+#define syscall_entry_result_sw(x)		((x)->args[0])
+#define syscall_entry_result_dw(x)	\
+	(((syscall_udw_t) (x)->args[1] << (sizeof(long) * 8)) | (x)->args[0])
+
+#define syscall_result_lower(x)			((unsigned long) (x))
+#define syscall_result_upper(x)			((unsigned long) ((syscall_udw_t) (x) >> (sizeof(long) * 8)))
+
+struct pthread;
+
+typedef struct syscall_entry {
+	unsigned char id;
+	unsigned char signal;
+	unsigned short seq_num;
+	unsigned int task_id;
+	struct pthread *pd;
+	unsigned long args[6];
+} syscall_entry_t;
+
+#define SYSCALL_MAX_PTHREADS	((SYSCALL_QUEUE_PAGES * PAGE_SIZE - 4 * sizeof(syscall_ptr_t) - 2 * sizeof(long)) / (sizeof(syscall_ptr_t) + sizeof(void *)))
+#define SYSCALL_MAX_RQUEUE_SIZE	(SYSCALL_MAX_PTHREADS * (sizeof(syscall_ptr_t) + sizeof(void *)) + 4 * sizeof(syscall_ptr_t) + 2 * sizeof(long))
+
+struct syscall_queue {
+	syscall_ptr_t alloc_head;
+	syscall_ptr_t alloc_tail;
+	syscall_ptr_t free_head;
+	syscall_ptr_t free_tail;
+	syscall_ptr_t next[SYSCALL_MAX_PTHREADS];
+	void *entries[SYSCALL_MAX_PTHREADS];
+	unsigned long waiters;
+	unsigned long nkthreads;
+	char _pad[SYSCALL_QUEUE_PAGES * PAGE_SIZE - SYSCALL_MAX_RQUEUE_SIZE];
+};
+
+#define SYSCALL_MAX_ENTRIES		((SYSCALL_CALL_PAGES * PAGE_SIZE - 2 * sizeof(syscall_ptr_t)) / (sizeof(syscall_entry_t) + sizeof(size_t)))
+#define SYSCALL_MAX_CALL_SIZE	(SYSCALL_MAX_ENTRIES * sizeof(syscall_entry_t) + 2 * sizeof(syscall_ptr_t) + SYSCALL_MAX_ENTRIES * sizeof(size_t))
+
+typedef struct syscall_page {
+	syscall_entry_t	entry[SYSCALL_MAX_ENTRIES];
+	syscall_ptr_t alloc_top;
+	syscall_ptr_t free_top;
+	size_t next[SYSCALL_MAX_ENTRIES];
+	char _pad[SYSCALL_CALL_PAGES * PAGE_SIZE - SYSCALL_MAX_CALL_SIZE];
+} syscall_page_t;
+
+#define SYSCALL_WAKE_REQUESTED		0x100000000ULL
+#define SYSCALL_WAKE_IN_PROGRESS	0x80000000U
+
+typedef struct syscall_wake_page {
+	volatile uint64_t running_threads;
+	char _pad[PAGE_SIZE - sizeof(uint64_t)];
+} syscall_wake_page_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_SYSCALL_COMMON_SYSCALL_H */
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/bits/_syscall_num.h uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/_syscall_num.h
--- uClibc-0.9.33/libc/sysdeps/linux/common/bits/_syscall_num.h	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/_syscall_num.h	2013-09-23 20:39:32.946222861 -0400
@@ -0,0 +1,139 @@
+/**
+ * VM-Syscalls
+ * Copyright (c) 2012 Ruslan Nikolaev
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef _SYSCALL_COMMON_SYSCALL_NUM_H
+#define _SYSCALL_COMMON_SYSCALL_NUM_H 			1
+
+#define __NRR_socket							0
+#define __NRR_accept							1
+#define __NRR_accept4							2
+#define __NRR_bind								3
+#define __NRR_listen							4
+#define __NRR_connect							5
+#define __NRR_getsockname						6
+#define __NRR_getpeername						7
+#define __NRR_getsockopt						8
+#define __NRR_setsockopt						9
+#define __NRR_sendto							10
+#define __NRR_recvfrom							11
+#define __NRR_sendmsg							12
+#define __NRR_recvmsg							13
+#define __NRR_shutdown							14
+#define __NRR_uname								15
+#define __NRR_sethostname						16
+#define __NRR_setdomainname						17
+#define __NRR_read								18
+#define __NRR_write								19
+#define __NRR_pread64							20
+#define __NRR_pwrite64							21
+#define __NRR_splice							22
+#define __NRR_sendfile							23
+#define __NRR_fsync								24
+#define __NRR_fdatasync							25
+#define __NRR_flock								26
+#define __NRR_fadvise64							27
+#define __NRR_fstat								28
+#define __NRR_newfstatat						29
+#define __NRR_syscall_service_select			30
+#define __NRR_syscall_service_poll				31
+#define __NRR_syscall_service_epoll_wait		32
+#define __NRR_dup								33
+#define __NRR_close								34
+#define __NRR_fcntl								35
+#define __NRR_ioctl								36
+#define __NRR_syscall_service_init				37
+#define __NRR_eventfd							38
+#define __NRR_eventfd2							39
+#define __NRR_epoll_create						40
+#define __NRR_epoll_create1						41
+#define __NRR_epoll_ctl							42
+#define __NRR_io_setup							43
+#define __NRR_io_destroy						44
+#define __NRR_io_cancel							45
+#define __NRR_io_submit							46
+#define __NRR_setuid							47
+#define __NRR_setgid							48
+#define __NRR_setreuid							49
+#define __NRR_setregid							50
+#define __NRR_setresuid							51
+#define __NRR_setresgid							52
+#define __NRR_setgroups							53
+#define __NRR_capset							54
+#define __NRR_prctl								55
+#define __NRR_syscall_service_chdir				56
+#define __NRR_syscall_service_fchdir			57
+#define __NRR_symlink							58
+#define __NRR_readlink							59
+#define __NRR_link								60
+#define __NRR_rename							61
+#define __NRR_chmod								62
+#define __NRR_fchmod							63
+#define __NRR_truncate							64
+#define __NRR_ftruncate							65
+#define __NRR_stat								66
+#define __NRR_lstat								67
+#define __NRR_open								68
+#define __NRR_chown								69
+#define __NRR_fchown							70
+#define __NRR_lseek								71
+#define __NRR_statfs							72
+#define __NRR_fstatfs							73
+#define __NRR_unlink							74
+#define __NRR_mknod								75
+#define __NRR_mkdir								76
+#define __NRR_rmdir								77
+#define __NRR_faccessat							78
+#define __NRR_fchmodat							79
+#define __NRR_fchownat							80
+#define __NRR_futimesat							81
+#define __NRR_mkdirat							82
+#define __NRR_mknodat							83
+#define __NRR_unlinkat							84
+#define __NRR_readlinkat						85
+#define __NRR_symlinkat							86
+#define __NRR_linkat							87
+#define __NRR_renameat							88
+#define __NRR_utimensat							89
+#define __NRR_utime								90
+#define __NRR_utimes							91
+#define __NRR_access							92
+#define __NRR_removexattr						93
+#define __NRR_lremovexattr						94
+#define __NRR_fremovexattr						95
+#define __NRR_listxattr							96
+#define __NRR_llistxattr						97
+#define __NRR_flistxattr						98
+#define __NRR_getxattr							99
+#define __NRR_lgetxattr							100
+#define __NRR_fgetxattr							101
+#define __NRR_setxattr							102
+#define __NRR_lsetxattr							103
+#define __NRR_fsetxattr							104
+#define __NRR_lchown							105
+#define __NRR_getdents64						106
+
+/* Aliases */
+#define __NRR_fstatat64							__NRR_newfstatat
+#define __NRR_posix_fadvise						__NRR_fadvise64
+
+#endif /* !_SYSCALL_COMMON_SYSCALL_NUM_H */
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/bits/_syscall_queue.h uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/_syscall_queue.h
--- uClibc-0.9.33/libc/sysdeps/linux/common/bits/_syscall_queue.h	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/_syscall_queue.h	2013-09-23 21:04:27.582284823 -0400
@@ -0,0 +1,237 @@
+/**
+ * VM-Syscalls
+ * Copyright (c) 2013 Ruslan Nikolaev
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef _SYSCALL_COMMON_SYSCALL_QUEUE_H
+#define _SYSCALL_COMMON_SYSCALL_QUEUE_H 1
+
+#include "_dcmpxchg.h"
+#include "_syscall_defs.h"
+
+/* This implements FIFO queue. */
+static inline size_t syscall_queue_enqueue(syscall_ptr_t *next,
+	syscall_ptr_t *tail, size_t eidx, size_t max, bool mark)
+{
+	syscall_ptr_t last, succ, tmp;
+
+	/* Initialize new entry */
+	do {
+		succ = VOLATILE_READ(next[eidx]);
+	} while (!dcmpxchg(&next[eidx].index, succ.index, succ.stamp,
+		SYSCALL_NULL_ENTRY, succ.stamp + 1));
+
+	while (1) {
+		last = VOLATILE_READ(*tail);
+		if (unlikely(last.index >= max))
+			return SYSCALL_ERROR_ENTRY;
+		succ = VOLATILE_READ(next[last.index]);
+		tmp = VOLATILE_READ(*tail);
+		if (last.index != tmp.index || last.stamp != tmp.stamp)
+			continue;
+		if ((ssize_t) succ.index < 0) {
+			if (mark && succ.index != SYSCALL_NULL_ENTRY) {
+				if (dcmpxchg(&next[last.index].index, succ.index, succ.stamp,
+					succ.index + 1, succ.stamp + 1)) {
+					return SYSCALL_NULL_ENTRY;
+				}
+			} else if (dcmpxchg(&next[last.index].index, succ.index, succ.stamp,
+				eidx, succ.stamp + 1))
+			{
+				dcmpxchg(&tail->index, last.index, last.stamp,
+					eidx, last.stamp + 1);
+				return 0;
+			}
+		} else {
+			dcmpxchg(&tail->index, last.index, last.stamp, succ.index,
+				last.stamp + 1);
+		}
+	}
+}
+
+#define syscall_queue_enqueue_fault(next, tail, eidx, max, mark) ({	\
+	syscall_ptr_t *__next = (next), *__tail = (tail); \
+	size_t __ret, __eidx = (eidx), __max = (max); \
+	bool __mark = (mark), __dret; \
+	syscall_ptr_t __last, __succ, __tmp; \
+	do { \
+		__succ = VOLATILE_READ_FAULT_PTR(__next[__eidx]); \
+		if (__dcmpxchg_user(__dret, __succ.index, __succ.stamp, \
+			SYSCALL_NULL_ENTRY, __succ.stamp + 1, &__next[__eidx].index)) \
+			goto error_fault; \
+	} while (!__dret); \
+	while (1) { \
+		__last = VOLATILE_READ_FAULT_PTR(*__tail); \
+		if (unlikely(__last.index >= __max)) { \
+			__ret = SYSCALL_ERROR_ENTRY; \
+			break; \
+		} \
+		__succ = VOLATILE_READ_FAULT_PTR(__next[__last.index]); \
+		__tmp = VOLATILE_READ_FAULT_PTR(*__tail); \
+		if (__last.index != __tmp.index || __last.stamp != __tmp.stamp) \
+			continue; \
+		if ((ssize_t) __succ.index < 0) { \
+			if (__mark && __succ.index != SYSCALL_NULL_ENTRY) { \
+				if (__dcmpxchg_user(__dret, __succ.index, __succ.stamp, \
+					__succ.index + 1, __succ.stamp + 1, \
+					&__next[__last.index].index)) \
+					goto error_fault; \
+				if (__dret) { \
+					__ret = SYSCALL_NULL_ENTRY; \
+					break; \
+				} \
+			} else { \
+				if (__dcmpxchg_user(__dret, __succ.index, __succ.stamp, \
+					__eidx, __succ.stamp + 1, &__next[__last.index].index)) \
+					goto error_fault; \
+				if (__dret) { \
+					if (__dcmpxchg_user(__dret, __last.index, __last.stamp, \
+						__eidx, __last.stamp + 1, &__tail->index)) \
+						goto error_fault; \
+					__ret = 0; \
+					break; \
+				} \
+			} \
+		} else { \
+			if (__dcmpxchg_user(__dret, __last.index, __last.stamp, \
+				__succ.index, __last.stamp + 1, &__tail->index)) \
+				goto error_fault; \
+		} \
+	} \
+__ret; })
+
+#define syscall_queue_dequeue(next, entries, head, tail, result, max, mark) ({ \
+	syscall_ptr_t *__next, *__head, *__tail; \
+	syscall_ptr_t __first, __last, __succ, __tmp; \
+	size_t __eidx; \
+	__next = (next); \
+	__head = (head); \
+	__tail = (tail); \
+	while (1) { \
+		__first = VOLATILE_READ(*__head); \
+		__last = VOLATILE_READ(*__tail); \
+		if (unlikely(__first.index >= max)) { \
+			__eidx = SYSCALL_ERROR_ENTRY; \
+			break; \
+		} \
+		__succ = VOLATILE_READ(__next[__first.index]); \
+		__tmp = VOLATILE_READ(*__head); \
+		if (__first.index != __tmp.index || __first.stamp != __tmp.stamp) \
+			continue; \
+		if (__first.index == __last.index) { \
+			if ((ssize_t) __succ.index < 0) { \
+				if (mark) { \
+					if (!dcmpxchg(&__next[__first.index].index, __succ.index, __succ.stamp, __succ.index - 1, __succ.stamp + 1)) \
+						continue; \
+				} \
+				__eidx = SYSCALL_NULL_ENTRY; \
+				break; \
+			} \
+			dcmpxchg(&__tail->index, __last.index, __last.stamp, __succ.index, __last.stamp + 1); \
+		} else { \
+			if (unlikely(__succ.index >= max)) { \
+				__eidx = SYSCALL_ERROR_ENTRY; \
+				break; \
+			} \
+			*(result) = (entries)[__succ.index]; \
+			if (dcmpxchg(&__head->index, __first.index, __first.stamp, \
+				__succ.index, __first.stamp + 1)) { \
+				__eidx = __first.index; \
+				break; \
+			} \
+		} \
+	} \
+__eidx; })
+
+#define syscall_queue_dequeue_fault(next, entries, head, tail, result, max, mark) ({ \
+	syscall_ptr_t *__next, *__head, *__tail; \
+	syscall_ptr_t __first, __last, __succ, __tmp; \
+	size_t __eidx; \
+	bool __dret; \
+	__next = (next); \
+	__head = (head); \
+	__tail = (tail); \
+	while (1) { \
+		__first = VOLATILE_READ_FAULT_PTR(*__head); \
+		__last = VOLATILE_READ_FAULT_PTR(*__tail); \
+		if (unlikely(__first.index >= max)) { \
+			__eidx = SYSCALL_ERROR_ENTRY; \
+			break; \
+		} \
+		__succ = VOLATILE_READ_FAULT_PTR(__next[__first.index]); \
+		__tmp = VOLATILE_READ_FAULT_PTR(*__head); \
+		if (__first.index != __tmp.index || __first.stamp != __tmp.stamp) \
+			continue; \
+		if (__first.index == __last.index) { \
+			if ((ssize_t) __succ.index < 0) { \
+				if (mark) { \
+					if (__dcmpxchg_user(__dret, __succ.index, __succ.stamp, __succ.index - 1, __succ.stamp + 1, &__next[__first.index].index))	\
+						goto error_fault;	\
+					if (!__dret) \
+						continue; \
+				} \
+				__eidx = SYSCALL_NULL_ENTRY; \
+				break; \
+			} \
+			if (__dcmpxchg_user(__dret, __last.index, __last.stamp, __succ.index, __last.stamp + 1, &__tail->index)) \
+				goto error_fault; \
+		} else { \
+			if (unlikely(__succ.index >= max)) { \
+				__eidx = SYSCALL_ERROR_ENTRY; \
+				break; \
+			} \
+			if (__get_user(*(result), &(entries)[__succ.index])) \
+				goto error_fault; \
+			if (__dcmpxchg_user(__dret, __first.index, __first.stamp, \
+				__succ.index, __first.stamp + 1, &__head->index)) \
+					goto error_fault; \
+			if (__dret) { \
+				__eidx = __first.index; \
+				break; \
+			} \
+		} \
+	} \
+__eidx; })
+
+static inline size_t syscall_queue_check(syscall_ptr_t *next,
+	syscall_ptr_t *head, syscall_ptr_t *tail, size_t max)
+{
+	syscall_ptr_t first, last, succ, tmp;
+
+	while (1) {
+		first = VOLATILE_READ(*head);
+		last = VOLATILE_READ(*tail);
+		if (unlikely(first.index >= max))
+			return SYSCALL_ERROR_ENTRY;
+		succ = VOLATILE_READ(next[first.index]);
+		tmp = VOLATILE_READ(*head);
+		if (tmp.index != first.index || tmp.stamp != first.stamp)
+			continue;
+		if (first.index != last.index)
+			return 0;
+		if ((ssize_t) succ.index < 0)
+			return SYSCALL_NULL_ENTRY;
+		dcmpxchg(&tail->index, last.index, last.stamp, succ.index,
+			last.stamp + 1);
+	}
+}
+
+#endif /* !_SYSCALL_COMMON_SYSCALL_QUEUE_H */
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/bits/_syscall_stack.h uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/_syscall_stack.h
--- uClibc-0.9.33/libc/sysdeps/linux/common/bits/_syscall_stack.h	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/_syscall_stack.h	2013-09-23 20:39:32.946222861 -0400
@@ -0,0 +1,74 @@
+/**
+ * VM-Syscalls
+ * Copyright (c) 2012-2013 Ruslan Nikolaev
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef _SYSCALL_COMMON_SYSCALL_STACK_H
+#define _SYSCALL_COMMON_SYSCALL_STACK_H 1
+
+#include "_dcmpxchg.h"
+#include "_syscall_defs.h"
+
+/* This implements LIFO queue. */
+static inline void syscall_stack_push(size_t *next, syscall_ptr_t *top, size_t eidx)
+{
+	syscall_ptr_t prev_top;
+
+	do {
+		prev_top = VOLATILE_READ(*top);
+		next[eidx] = prev_top.index;
+	} while (!dcmpxchg(&top->index, prev_top.index, prev_top.stamp, eidx, prev_top.stamp + 1));
+}
+
+static inline size_t syscall_stack_pop(size_t *next, syscall_ptr_t *top, size_t max)
+{
+	syscall_ptr_t prev_top;
+	size_t next_top;
+
+	do {
+		prev_top = VOLATILE_READ(*top);
+		if (prev_top.index == SYSCALL_NULL_ENTRY) {
+			return SYSCALL_NULL_ENTRY;
+		}
+		if (unlikely(prev_top.index >= max)) {
+			return SYSCALL_ERROR_ENTRY;
+		}
+		next_top = VOLATILE_READ(next[prev_top.index]);
+	} while (!dcmpxchg(&top->index, prev_top.index, prev_top.stamp, next_top, prev_top.stamp + 1));
+
+	return prev_top.index;
+}
+
+static inline size_t syscall_stack_check(syscall_ptr_t *top, size_t max)
+{
+	syscall_ptr_t cur_top;
+
+	cur_top = VOLATILE_READ(*top);
+	if (cur_top.index == SYSCALL_NULL_ENTRY) {
+		return SYSCALL_NULL_ENTRY;
+	}
+	if (unlikely(cur_top.index >= max)) {
+		return SYSCALL_ERROR_ENTRY;
+	}
+	return 0;
+}
+
+#endif /* !_SYSCALL_COMMON_SYSCALL_STACK_H */
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/bits/uClibc_mutex.h uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/uClibc_mutex.h
--- uClibc-0.9.33/libc/sysdeps/linux/common/bits/uClibc_mutex.h	2013-09-23 20:39:08.262221838 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/uClibc_mutex.h	2013-09-23 20:39:32.946222861 -0400
@@ -14,25 +14,27 @@
 
 #include <pthread.h>
 #include <bits/uClibc_pthread.h>
+#include <schedule_defsP.h>
+#include <bits/stdio-lock.h>
 
-#define __UCLIBC_MUTEX_TYPE				pthread_mutex_t
+#define __UCLIBC_MUTEX_TYPE				struct __sclib_mutex_auto
 
-#define __UCLIBC_MUTEX(M)				pthread_mutex_t M
-#define __UCLIBC_MUTEX_INIT(M,I)			pthread_mutex_t M = I
-#define __UCLIBC_MUTEX_STATIC(M,I)			static pthread_mutex_t M = I
-#define __UCLIBC_MUTEX_EXTERN(M)			extern pthread_mutex_t M
+#define __UCLIBC_MUTEX(M)				struct __sclib_mutex_auto M
+#define __UCLIBC_MUTEX_INIT(M,I)			struct __sclib_mutex_auto M = { .kind = I, .value = 0, .owner = 0, .recur_count = 0 }
+#define __UCLIBC_MUTEX_STATIC(M,I)			static struct __sclib_mutex_auto M = { .kind = I, .value = 0, .owner = 0, .recur_count = 0 }
+#define __UCLIBC_MUTEX_EXTERN(M)			extern struct __sclib_mutex_auto M
 
 #define __UCLIBC_MUTEX_INIT_VAR(M)								\
-		((M) = (pthread_mutex_t) PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP)
+		__sclib_mutex_auto_init(&(M), __SCLIB_MUTEX_RECURSIVE)
 
 #define __UCLIBC_MUTEX_LOCK_CANCEL_UNSAFE(M)								\
-		__pthread_mutex_lock(&(M))
+		__sclib_mutex_auto_lock(&(M))
 
 #define __UCLIBC_MUTEX_UNLOCK_CANCEL_UNSAFE(M)								\
-		__pthread_mutex_unlock(&(M))
+		__sclib_mutex_auto_unlock(&(M))
 
 #define __UCLIBC_MUTEX_TRYLOCK_CANCEL_UNSAFE(M)								\
-		__pthread_mutex_trylock(&(M))
+		__sclib_mutex_auto_trylock(&(M))
 
 #define __UCLIBC_MUTEX_CONDITIONAL_LOCK(M,C)								\
 	do {												\
@@ -40,9 +42,9 @@
 		int __infunc_need_locking = (C);							\
 		if (__infunc_need_locking) {								\
 			_pthread_cleanup_push_defer(&__infunc_pthread_cleanup_buffer,			\
-					   (void (*) (void *))__pthread_mutex_unlock,			\
+					   (void (*) (void *))__sclib_mutex_auto_unlock,		\
 										&(M));			\
-			__pthread_mutex_lock(&(M));							\
+			__sclib_mutex_auto_lock(&(M));							\
 		}											\
 		((void)0)
 
@@ -66,7 +68,7 @@
 #define __UCLIBC_MUTEX_UNLOCK(M)									\
         __UCLIBC_MUTEX_CONDITIONAL_UNLOCK(M, 1)
 
-#ifdef __USE_STDIO_FUTEXES__
+#if 0
 
 #include <bits/stdio-lock.h>
 
@@ -102,7 +104,7 @@
 #define __UCLIBC_IO_MUTEX_LOCK(M)                   __UCLIBC_MUTEX_CONDITIONAL_LOCK(M, 1)
 #define __UCLIBC_IO_MUTEX_UNLOCK(M)                 __UCLIBC_MUTEX_CONDITIONAL_UNLOCK(M, 1)
 #define __UCLIBC_IO_MUTEX_TRYLOCK(M)                __UCLIBC_MUTEX_TRYLOCK_CANCEL_UNSAFE(M)
-#define __UCLIBC_IO_MUTEX_INIT(M)                   __UCLIBC_MUTEX_INIT(M, PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP)
+#define __UCLIBC_IO_MUTEX_INIT(M)                   __UCLIBC_MUTEX_INIT(M, __SCLIB_MUTEX_RECURSIVE)
 #define __UCLIBC_IO_MUTEX_EXTERN(M)                 __UCLIBC_MUTEX_EXTERN(M)
 #define __UCLIBC_IO_MUTEX_AUTO_LOCK(M,A,V)          __UCLIBC_MUTEX_AUTO_LOCK(M,A,V)
 #define __UCLIBC_IO_MUTEX_AUTO_UNLOCK(M,A)          __UCLIBC_MUTEX_AUTO_UNLOCK(M,A)
@@ -140,7 +142,7 @@
 #define __UCLIBC_IO_MUTEX_LOCK(M)                   __UCLIBC_MUTEX_CONDITIONAL_LOCK(M, 1)
 #define __UCLIBC_IO_MUTEX_UNLOCK(M)                 __UCLIBC_MUTEX_CONDITIONAL_UNLOCK(M, 1)
 #define __UCLIBC_IO_MUTEX_TRYLOCK(M)                __UCLIBC_MUTEX_TRYLOCK_CANCEL_UNSAFE(M)
-#define __UCLIBC_IO_MUTEX_INIT(M)                   __UCLIBC_MUTEX_INIT(M, PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP)
+#define __UCLIBC_IO_MUTEX_INIT(M)                   __UCLIBC_MUTEX_INIT(M, __SCLIB_MUTEX_RECURSIVE)
 #define __UCLIBC_IO_MUTEX_EXTERN(M)                 __UCLIBC_MUTEX_EXTERN(M)
 #define __UCLIBC_IO_MUTEX_AUTO_LOCK(M,A,V)          __UCLIBC_MUTEX_AUTO_LOCK(M,A,V)
 #define __UCLIBC_IO_MUTEX_AUTO_UNLOCK(M,A)          __UCLIBC_MUTEX_AUTO_UNLOCK(M,A)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/bits/uClibc_pthread.h uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/uClibc_pthread.h
--- uClibc-0.9.33/libc/sysdeps/linux/common/bits/uClibc_pthread.h	2013-09-23 20:39:08.238221836 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/uClibc_pthread.h	2013-09-23 20:39:32.946222861 -0400
@@ -35,6 +35,7 @@
  * weak so that we can elide them from single-threaded processes.  */
 extern int weak_function __pthread_mutex_init (pthread_mutex_t *__mutex,
 		__const pthread_mutexattr_t *__mutex_attr);
+extern int weak_function __pthread_mutex_reinit (pthread_mutex_t *__mutex);
 extern int weak_function __pthread_mutex_destroy (pthread_mutex_t *__mutex);
 extern int weak_function __pthread_mutex_lock (pthread_mutex_t *__mutex);
 extern int weak_function __pthread_mutex_unlock (pthread_mutex_t *__mutex);
@@ -46,6 +47,20 @@
 		struct _pthread_cleanup_buffer *__buffer,
 		int __execute);
 
+struct __sclib_mutex;
+struct __sclib_mutex_auto;
+struct syscall_entry;
+
+extern long weak_function __sclib_futex_wait(int *ptr, int val);
+extern long weak_function __sclib_futex_wake(int *ptr, int val);
+extern void weak_function __sclib_schedule(int sysid, struct syscall_entry *entry);
+extern long weak_function __sclib_mutex_auto_init(struct __sclib_mutex_auto *mutex, int kind);
+extern long weak_function __sclib_mutex_auto_reinit(struct __sclib_mutex_auto *mutex);
+extern void weak_function __sclib_mutex_auto_destroy(struct __sclib_mutex_auto *mutex);
+extern long weak_function __sclib_mutex_auto_lock(struct __sclib_mutex_auto *mutex);
+extern long weak_function __sclib_mutex_auto_trylock(struct __sclib_mutex_auto *mutex);
+extern long weak_function __sclib_mutex_auto_unlock(struct __sclib_mutex_auto *mutex);
+
 #endif
 
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/bits/uClibc_stdio.h uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/uClibc_stdio.h
--- uClibc-0.9.33/libc/sysdeps/linux/common/bits/uClibc_stdio.h	2013-09-23 20:39:08.238221836 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/bits/uClibc_stdio.h	2013-09-23 20:39:32.946222861 -0400
@@ -162,7 +162,7 @@
 #endif
 
 #ifdef __UCLIBC_HAS_THREADS__
-#ifdef __USE_STDIO_FUTEXES__
+#if 0
 #define STDIO_INIT_MUTEX(M) _IO_lock_init(M)
 #else
 #define STDIO_INIT_MUTEX(M) __stdio_init_mutex(& M)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/capset.c uClibc-0.9.33-new/libc/sysdeps/linux/common/capset.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/capset.c	2013-09-23 20:39:08.218221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/capset.c	2013-09-23 20:39:32.946222861 -0400
@@ -3,13 +3,56 @@
  * capset() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
 
 #include <sys/syscall.h>
+#include <unistd.h>
+#include <linux/capability.h>
+#include <bits/sclib.h>
 
 int capset(void *header, const void *data);
 #ifdef __NR_capset
-_syscall2(int, capset, void *, header, const void *, data)
+int capset(void *_header, const void *_data)
+{
+	cap_user_header_t mem_header[SYSCALL_SYSIDS], header = (cap_user_header_t) _header;
+	cap_user_data_t mem_data;
+	const cap_user_data_t data = (const cap_user_data_t) _data;
+	syscall_entry_t *pos[SYSCALL_SYSIDS];
+	long ret, rret;
+	size_t sysid;
+
+	/* With VFS support only */
+	if (header->pid != getpid() && header->pid != 0) {
+		__set_errno(EINVAL);
+		return -1;
+	}
+
+	for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+		mem_header[sysid] = (cap_user_header_t) sclib_memory_alloc(&sclib_data[sysid], sizeof(struct __user_cap_header_struct) + sizeof(struct __user_cap_data_struct) * 2);
+		SCLIB_MEM_RET(mem_header[sysid], ret);
+		mem_header[sysid]->version = header->version;
+		mem_header[sysid]->pid = 0;
+		mem_data = (cap_user_data_t) (mem_header[sysid] + 1);
+		mem_data[0] = data[0];
+		if (header->version > _LINUX_CAPABILITY_VERSION_1)
+			mem_data[1] = data[1];
+		pos[sysid] = SCLIB_REMOTE_CALL_ASYNC(sysid, capset, 2, sclib_mem(sysid, mem_header[sysid]), sclib_mem(sysid, mem_data));
+	}
+
+	ret = SCLIB_LOCAL_CALL(capset, 2, header, data);
+
+error_mem:
+	while (sysid != 0) {
+		sysid--;
+		rret = SCLIB_REMOTE_CALL_RESULT(sysid, capset, pos[sysid]);
+		if (SCLIB_IS_ERR(rret))
+			ret = rret;
+		sclib_memory_free(&sclib_data[sysid], mem_header[sysid]);
+	}
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/chdir.c uClibc-0.9.33-new/libc/sysdeps/linux/common/chdir.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/chdir.c	2013-09-23 20:39:08.222221835 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/chdir.c	2013-09-23 20:39:32.946222861 -0400
@@ -3,6 +3,7 @@
  * chdir() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -12,11 +13,36 @@
 #include <unistd.h>
 #include <sys/param.h>
 
+#include <bits/sclib.h>
 
-#define __NR___syscall_chdir __NR_chdir
-static __inline__ _syscall1(int, __syscall_chdir, const char *, path)
 int chdir(const char *path)
 {
-	return __syscall_chdir(path);
+	char abspath[PATH_MAX];
+	char *dpath;
+	long ret;
+	int sysid;
+	void *rbuf, *off;
+	size_t sz;
+
+	dpath = sclib_get_path(abspath, path, &sysid, &sz);
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		rbuf = sclib_memory_alloc(&sclib_data[sysid], PATH_MAX);
+		SCLIB_MEM_RET(rbuf, ret);
+		rbuf = memcpy(rbuf, dpath, sz);
+		off = sclib_mem(sysid, rbuf);
+		ret = SCLIB_REMOTE_CALL(sysid, syscall_service_chdir, 3, off, off, PATH_MAX - sizeof(SCLIB_STORAGE_PREFIX) + 1);
+		if (!SCLIB_IS_ERR(ret)) {
+			memcpy(mempcpy(sclib_file.curdir, SCLIB_STORAGE_PREFIX, sizeof(SCLIB_STORAGE_PREFIX) - 1), rbuf, ret);
+			ret += sizeof(SCLIB_STORAGE_PREFIX) - 1;
+		}
+		sclib_memory_free(&sclib_data[sysid], rbuf);
+	} else {
+		ret = SCLIB_LOCAL_CALL(syscall_service_chdir, 3, dpath, sclib_file.curdir, PATH_MAX);
+	}
+
+error_mem:
+	SCLIB_ERR_RET(ret);
+	sclib_file.curdir_size = ret;
+	return 0;
 }
 libc_hidden_def(chdir)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/chmod.c uClibc-0.9.33-new/libc/sysdeps/linux/common/chmod.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/chmod.c	2013-09-23 20:39:08.174221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/chmod.c	2013-09-23 20:39:32.946222861 -0400
@@ -9,13 +9,10 @@
 
 #include <sys/syscall.h>
 #include <sys/stat.h>
-
-
-#define __NR___syscall_chmod __NR_chmod
-static __inline__ _syscall2(int, __syscall_chmod, const char *, path, __kernel_mode_t, mode)
+#include <bits/sclib.h>
 
 int chmod(const char *path, mode_t mode)
 {
-	return __syscall_chmod(path, mode);
+	return SCLIB_PATH_CALL(chmod, 2, path, mode);
 }
 libc_hidden_def(chmod)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/chown.c uClibc-0.9.33-new/libc/sysdeps/linux/common/chown.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/chown.c	2013-09-23 20:39:08.278221837 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/chown.c	2013-09-23 20:39:32.946222861 -0400
@@ -11,6 +11,7 @@
 #include <unistd.h>
 #include <bits/wordsize.h>
 
+#include <bits/sclib.h>
 
 #if (__WORDSIZE == 32 && defined(__NR_chown32)) || __WORDSIZE == 64
 # ifdef __NR_chown32
@@ -18,7 +19,10 @@
 #  define __NR_chown __NR_chown32
 # endif
 
-_syscall3(int, chown, const char *, path, uid_t, owner, gid_t, group)
+int chown(const char *path, uid_t owner, gid_t group)
+{
+	return SCLIB_PATH_CALL(chown, 3, path, owner, group);
+}
 
 #else
 
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/close.c uClibc-0.9.33-new/libc/sysdeps/linux/common/close.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/close.c	2013-09-23 20:39:08.190221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/close.c	2013-09-23 20:39:32.946222861 -0400
@@ -10,7 +10,15 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
-_syscall1(int, close, int, fd)
+#include <bits/sclib.h>
+#include <bits/sclib_syscalls.h>
+
+int close(int fd)
+{
+	long ret = __internal_sys_close(fd);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
 #ifndef __LINUXTHREADS_OLD__
 libc_hidden_def(close)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/dup2.c uClibc-0.9.33-new/libc/sysdeps/linux/common/dup2.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/dup2.c	2013-09-23 20:39:08.178221833 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/dup2.c	2013-09-23 20:39:32.946222861 -0400
@@ -3,6 +3,7 @@
  * dup2() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -10,6 +11,62 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
+#include <bits/sclib.h>
+
+int dup2(int fd, int dup_fd)
+{
+	int sysid;
+	long dfd, dup_dfd;
+	sclib_fd_t dup_aux[SYSCALL_SYSIDS];
+
+	if (unlikely((unsigned int) dup_fd >= SCLIB_FILE_TABLE_LENGTH)) {
+		__set_errno(EBADF);
+		return -1;
+	}
+	if (fd == dup_fd)
+		return fd;
+	dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+	SCLIB_ERR_RET(dfd);
+
+	__sync_fetch_and_or(&sclib_file.fds[fd].ectl_doms, 0xFF);
+
+	switch (sysid)
+	{
+	default:
+		dup_dfd = SCLIB_REMOTE_CALL(sysid, dup, 1, dfd);
+		break;
+
+	case SYSCALL_SYSID_LOCAL:
+		dup_dfd = SCLIB_LOCAL_CALL(dup, 1, dfd);
+		break;
+
+	case SYSCALL_SYSID_ALL:
+	{
+		sclib_fd_t *aux;
+		size_t n, i;
+
+		aux = sclib_file_aux(&sclib_file, fd);
+		for (n = 0; n < SYSCALL_SYSIDS; n++) {
+			dup_aux[n] = SCLIB_REMOTE_CALL(n, dup, 1, aux[n]);
+			if (SCLIB_IS_ERR(dup_aux[n])) {
+				dup_dfd = dup_aux[n];
+				goto error_aux;
+			}
+		}
+		dup_dfd = SCLIB_LOCAL_CALL(dup, 1, dfd);
+		if (SCLIB_IS_ERR(dup_dfd)) {
+error_aux:
+			for (i = 0; i < n; i++)
+				SCLIB_REMOTE_CALL(i, close, 1, dup_aux[i]);
+		}
+		break;
+	}
+	}
+
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(dup_dfd);
+	sclib_file_replace(&sclib_file, dup_fd, dup_dfd, sysid, dup_aux);
+	return dup_fd;
+}
 
-_syscall2(int, dup2, int, oldfd, int, newfd)
 libc_hidden_def(dup2)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/dup.c uClibc-0.9.33-new/libc/sysdeps/linux/common/dup.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/dup.c	2013-09-23 20:39:08.230221837 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/dup.c	2013-09-23 20:39:32.946222861 -0400
@@ -2,10 +2,66 @@
 /*
  * dup() for uClibc
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
 
 #include <sys/syscall.h>
 #include <unistd.h>
-_syscall1(int, dup, int, oldfd)
+
+#include <bits/sclib.h>
+
+int dup(int fd)
+{
+	int sysid;
+	long dup_fd, dup_dfd, dfd;
+
+	dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+	SCLIB_ERR_RET(dfd);
+	dup_fd = sclib_file_add(&sclib_file, 0);
+	SCLIB_VAL_RET(dup_fd, dup_dfd);
+
+	__sync_fetch_and_or(&sclib_file.fds[fd].ectl_doms, 0xFF);
+
+	switch (sysid)
+	{
+	default:
+		dup_dfd = SCLIB_REMOTE_CALL(sysid, dup, 1, dfd);
+		break;
+
+	case SYSCALL_SYSID_LOCAL:
+		dup_dfd = SCLIB_LOCAL_CALL(dup, 1, dfd);
+		break;
+
+	case SYSCALL_SYSID_ALL:
+	{
+		sclib_fd_t *aux, *dup_aux;
+		size_t n, i;
+
+		aux = sclib_file_aux(&sclib_file, fd);
+		dup_aux = sclib_file_aux(&sclib_file, dup_fd);
+		for (n = 0; n < SYSCALL_SYSIDS; n++) {
+			dup_aux[n] = SCLIB_REMOTE_CALL(n, dup, 1, aux[n]);
+			if (SCLIB_IS_ERR(dup_aux[n])) {
+				dup_dfd = dup_aux[n];
+				goto error_aux;
+			}
+		}
+		dup_dfd = SCLIB_LOCAL_CALL(dup, 1, dfd);
+		if (SCLIB_IS_ERR(dup_dfd)) {
+error_aux:
+			for (i = 0; i < n; i++)
+				SCLIB_REMOTE_CALL(i, close, 1, dup_aux[i]);
+		}
+		break;
+	}
+	}
+
+	sclib_file_add_done(&sclib_file, dup_fd, dup_dfd, sysid, 0, 0xFF);
+
+error_val:
+	sclib_file_put(&sclib_file, fd);	
+	SCLIB_ERR_RET(dup_dfd);
+	return dup_fd;
+}
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/epoll.c uClibc-0.9.33-new/libc/sysdeps/linux/common/epoll.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/epoll.c	2013-09-23 20:39:08.186221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/epoll.c	2013-09-23 20:39:32.946222861 -0400
@@ -2,6 +2,7 @@
 /*
  * epoll_create() / epoll_ctl() / epoll_wait() for uClibc
  *
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
@@ -15,40 +16,291 @@
 # define SINGLE_THREAD_P 1
 #endif
 
+#include <assert.h>
+#include <bits/sclib.h>
+
 /*
  * epoll_create()
  */
 #ifdef __NR_epoll_create
-_syscall1(int, epoll_create, int, size)
+int epoll_create(int size)
+{
+	long lfd, fd = sclib_file_add(&sclib_file, 0);
+	sclib_fd_t *aux;
+	size_t i, n;
+
+	SCLIB_ERR_RET(fd);
+	aux = sclib_file_aux(&sclib_file, fd);
+	for (n = 0; n < SYSCALL_SYSIDS; n++) {
+		aux[n] = SCLIB_REMOTE_CALL(n, epoll_create, 1, size);
+		if (SCLIB_IS_ERR(aux[n])) {
+			lfd = aux[n];
+			goto error_aux;
+		}
+	}
+	lfd = SCLIB_LOCAL_CALL(epoll_create, 1, size);
+	if (SCLIB_IS_ERR(lfd)) {
+error_aux:
+		for (i = 0; i < n; i++)
+			SCLIB_REMOTE_CALL(i, close, 1, aux[i]);
+	}
+	sclib_file_add_done(&sclib_file, fd, lfd, SYSCALL_SYSID_ALL, 0, 0);
+	SCLIB_ERR_RET(lfd);
+	return fd;
+}
 #endif
 
 /*
  * epoll_create1()
  */
 #ifdef __NR_epoll_create1
-_syscall1(int, epoll_create1, int, flags)
+int epoll_create1(int flags)
+{
+	long lfd, fd = sclib_file_add(&sclib_file, 0);
+	sclib_fd_t *aux;
+	size_t i, n;
+
+	SCLIB_ERR_RET(fd);
+	aux = sclib_file_aux(&sclib_file, fd);
+	for (n = 0; n < SYSCALL_SYSIDS; n++) {
+		aux[n] = SCLIB_REMOTE_CALL(n, epoll_create1, 1, flags);
+		if (SCLIB_IS_ERR(aux[n])) {
+			lfd = aux[n];
+			goto error_aux;
+		}
+	}
+	lfd = SCLIB_LOCAL_CALL(epoll_create1, 1, flags);
+	if (SCLIB_IS_ERR(lfd)) {
+error_aux:
+		for (i = 0; i < n; i++)
+			SCLIB_REMOTE_CALL(i, close, 1, aux[i]);
+		sclib_file_add_fail(&sclib_file, fd);
+	} else {
+		uint8_t lfd_flags = 0;
+		if (flags & EPOLL_CLOEXEC)
+			lfd_flags |= SCLIB_FD_EXEC;
+		sclib_file_add_ok(&sclib_file, fd, lfd, SYSCALL_SYSID_ALL, lfd_flags, 0);
+	}
+	SCLIB_ERR_RET(lfd);
+	return fd;
+}
 #endif
 
+static inline void __epoll_ctl_debug(int epfd, int op, int fd, uint32_t events, uint64_t u64)
+{
+    const char *str;
+
+	if (op == EPOLL_CTL_ADD)
+		str = "ECTL_ADD";
+	else if (op == EPOLL_CTL_MOD)
+		str = "ECTL_MOD";
+	else
+		str = "ECTL_DEL";
+	SCLIB_STRACE_DEBUG("%s [EFD=%i, FD=%i, EVT=0x%x, 0x%llx]", str, epfd, fd, events, u64);
+}
+
 /*
  * epoll_ctl()
  */
 #ifdef __NR_epoll_ctl
-_syscall4(int,epoll_ctl, int, epfd, int, op, int, fd, struct epoll_event *, event)
+int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)
+{
+	int sysid;
+	long lepfd, dfd, ret;
+	sclib_fd_t *epaux;
+
+	//__epoll_ctl_debug(epfd, op, fd, event->events, event->data.u64);
+	lepfd = sclib_file_get(&sclib_file, epfd, SYSCALL_SYSID_ALL);
+	SCLIB_ERR_RET(lepfd);
+	epaux = sclib_file_aux(&sclib_file, epfd);
+	dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+	SCLIB_VAL_RET(dfd, ret);
+
+	switch (sysid)
+	{
+	default:
+	{
+		long net_events;
+		uint64_t net_data;
+
+		__sync_fetch_and_or(&sclib_file.fds[epfd].ectl_doms, 1U << sysid);
+		if (op == EPOLL_CTL_DEL) {
+			net_events = 0;
+			net_data = 0;
+		} else {
+			net_events = event->events;
+			net_data = event->data.u64;
+		}
+		ret = SCLIB_REMOTE_CALL(sysid, epoll_ctl, 5, epaux[sysid],
+				op, dfd, net_events, net_data);
+		break;
+	}
+
+	case SYSCALL_SYSID_LOCAL:
+		__sync_fetch_and_or(&sclib_file.fds[epfd].ectl_doms, 1U << SYSCALL_SYSID_LOCAL);
+		ret = SCLIB_LOCAL_CALL(epoll_ctl, 4, lepfd, op, dfd, event);
+		break;
+
+	case SYSCALL_SYSID_ALL: /* For nested epoll */
+	{
+		long net_events;
+		size_t n;
+		uint64_t net_data;
+		sclib_fd_t *aux = sclib_file_aux(&sclib_file, fd);
+
+		__sync_fetch_and_or(&sclib_file.fds[epfd].ectl_doms, 0xFF);
+		if (op == EPOLL_CTL_DEL) {
+			net_events = 0;
+			net_data = 0;
+		} else {
+			net_events = event->events;
+			net_data = event->data.u64;
+		}
+
+		ret = SCLIB_LOCAL_CALL(epoll_ctl, 4, lepfd, op, dfd, event);
+		if (!SCLIB_IS_ERR(ret)) {
+			for (n = 0; n < SYSCALL_SYSIDS; n++) {
+				ret = SCLIB_REMOTE_CALL(n, epoll_ctl, 5, epaux[n],
+										op, aux[n], net_events,
+										net_data);
+				assert(ret == 0); /* Better way to recover? */
+			}
+		}
+		break;
+	}
+	}
+
+	sclib_file_put(&sclib_file, fd);
+error_val:
+	sclib_file_put(&sclib_file, epfd);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 #endif
 
+static inline void __epoll_wait_debug(int epfd, struct epoll_event *events, int maxevents, long ret)
+{
+	char buf[256];
+	char *buf_str;
+	int i;
+
+	buf_str = buf;
+	buf_str += sprintf(buf_str, "EPOLL_WAIT EFD=%i ", epfd);
+	for (i = 0; i < maxevents; i++) {
+		buf_str += sprintf(buf_str, "[EVT=0x%x, 0x%llx] ", events[i].events, (unsigned long long) events[i].data.u64);
+	}
+	buf_str += sprintf(buf_str, "R: %li\n", ret);
+	SCLIB_LOCAL_CALL(write, 3, -1, buf, strlen(buf));
+}
+
 /*
  * epoll_wait()
  */
 #ifdef __NR_epoll_wait
+
+static int __syscall_epoll_wait(int epfd, struct epoll_event *events,
+	int maxevents, int timeout)
+{
+	struct epoll_event *rem_events[SYSCALL_SYSIDS];
+	struct syscall_efd param;
+	sclib_fd_t *epaux;
+	long num, ret, eplfd, efd, efd_packed;
+	syscall_entry_t *pos[SYSCALL_SYSIDS];
+	size_t sysid;
+	uint8_t ectl_doms, mask;
+
+//	__epoll_wait_debug(epfd, events, maxevents, num);
+
+	eplfd = sclib_file_get(&sclib_file, epfd, SYSCALL_SYSID_ALL);
+	SCLIB_ERR_RET(eplfd);
+	if ((unsigned int) maxevents > 1024)
+		maxevents = 1024;
+	epaux = sclib_file_aux(&sclib_file, epfd);
+	ectl_doms = sclib_file.fds[epfd].ectl_doms;
+
+	mask = 0xFF;
+	efd = sclib_thread.efd[SYSCALL_SYSIDS];
+	for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+		rem_events[sysid] = sclib_memory_alloc(&sclib_data[sysid],
+								sizeof(struct epoll_event) * maxevents);
+		SCLIB_MEM_RET(rem_events[sysid], num);
+		if (ectl_doms & (1U << sysid)) {
+			mask = ~(1U << sysid);
+			if (ectl_doms & mask) {
+				efd_packed = sclib_thread.efd[sysid] | (efd << 10);
+			} else {
+				efd_packed = 0xFFFFF;
+			}
+			efd_packed |= ((long) epaux[sysid] << 20);
+			pos[sysid] = SCLIB_REMOTE_CALL_ASYNC(sysid, syscall_service_epoll_wait, 4, efd_packed, sclib_mem(sysid, rem_events[sysid]), maxevents, timeout);
+		}
+	}
+
+	num = 0;
+	if ((ectl_doms & mask) || ectl_doms == 0) {
+		param.efd[SYSCALL_SYSIDS] = efd;
+		param.n = eplfd;
+		if (ectl_doms & ~(1U << SYSCALL_SYSID_LOCAL)) {
+			param.efd_num = -1;
+			for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+				if (ectl_doms & (1U << sysid)) {
+					param.efd[sysid] = sclib_thread.efd[sysid];
+				} else {
+					param.efd[sysid] = -1; /* CHECK!!! */
+				}
+			}
+		} else {
+			param.efd_num = 0;
+			efd = -1;
+		}
+		num = SCLIB_LOCAL_CALL(syscall_service_epoll_wait, 4, &param,
+			events, maxevents, timeout);
+		if (likely(num != -EFAULT))
+			sclib_wait_efd(&param, efd);
+	}
+
+	SCLIB_VAL_RET(num, num);
+	events += num;
+	while (sysid != 0) {
+		sysid--;
+		if (ectl_doms & (1U << sysid)) {
+			ret = SCLIB_REMOTE_CALL_RESULT(sysid, syscall_service_epoll_wait, pos[sysid]);
+			SCLIB_VAL_RET(ret, num);
+			if (num + ret > maxevents)
+				ret = maxevents - num;
+			events = mempcpy(events, rem_events[sysid], ret * sizeof(struct epoll_event));
+			sclib_memory_free(&sclib_data[sysid], rem_events[sysid]);
+			num += ret;
+		}
+	}
+
+error:
+	sclib_file_put(&sclib_file, epfd);
+
+//	__epoll_wait_debug(epfd, events, maxevents, num);
+
+	SCLIB_ERR_RET(num);
+	return num;
+
+error_mem:
+error_val:
+	while (sysid != 0) {
+		sysid--;
+		SCLIB_REMOTE_CALL_RESULT(sysid, syscall_service_epoll_wait, pos[sysid]);
+		sclib_memory_free(&sclib_data[sysid], rem_events[sysid]);
+	}
+	goto error;
+}
+
 extern __typeof(epoll_wait) __libc_epoll_wait;
 int __libc_epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)
 {
 	if (SINGLE_THREAD_P)
-		return INLINE_SYSCALL(epoll_wait, 4, epfd, events, maxevents, timeout);
+		return __syscall_epoll_wait(epfd, events, maxevents, timeout);
 # ifdef __UCLIBC_HAS_THREADS_NATIVE__
 	else {
 		int oldtype = LIBC_CANCEL_ASYNC ();
-		int result = INLINE_SYSCALL(epoll_wait, 4, epfd, events, maxevents, timeout);
+		int result = __syscall_epoll_wait(epfd, events, maxevents, timeout);
 		LIBC_CANCEL_RESET (oldtype);
 		return result;
 	}
@@ -60,20 +312,43 @@
 /*
  * epoll_pwait()
  */
-#ifdef __NR_epoll_pwait
+#ifdef __NR_epoll_wait
 # include <signal.h>
 
+static int __syscall_epoll_pwait(int epfd, struct epoll_event *events,
+	int maxevents, int timeout, const sigset_t *sigmask)
+{
+  int retval;
+  sigset_t savemask;
+
+  /* The setting and restoring of the signal mask and the epoll_wait call
+     should be an atomic operation.  This can't be done without kernel
+     help.  */
+  if (sigmask != NULL)
+    sigprocmask (SIG_SETMASK, sigmask, &savemask);
+
+  /* Note the epoll_pwait() is a cancellation point.  But since we call
+     epoll_wait() which itself is a cancellation point we do not have
+     to do anything here.  */
+  retval = epoll_wait (epfd, events, maxevents, timeout);
+
+  if (sigmask != NULL)
+    sigprocmask (SIG_SETMASK, &savemask, NULL);
+
+  return retval;
+}
+
+
 extern __typeof(epoll_pwait) __libc_epoll_pwait;
 int __libc_epoll_pwait(int epfd, struct epoll_event *events, int maxevents,
 						int timeout, const sigset_t *set)
 {
-    int nsig = _NSIG / 8;
 	if (SINGLE_THREAD_P)
-		return INLINE_SYSCALL(epoll_pwait, 6, epfd, events, maxevents, timeout, set, nsig);
+		return __syscall_epoll_pwait(epfd, events, maxevents, timeout, set);
 # ifdef __UCLIBC_HAS_THREADS_NATIVE__
 	else {
 		int oldtype = LIBC_CANCEL_ASYNC ();
-		int result = INLINE_SYSCALL(epoll_pwait, 6, epfd, events, maxevents, timeout, set, nsig);
+		int result = __syscall_epoll_pwait(epfd, events, maxevents, timeout, set);
 		LIBC_CANCEL_RESET (oldtype);
 		return result;
 	}
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/eventfd.c uClibc-0.9.33-new/libc/sysdeps/linux/common/eventfd.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/eventfd.c	2013-09-23 20:39:08.186221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/eventfd.c	2013-09-23 20:39:32.946222861 -0400
@@ -3,6 +3,7 @@
  * eventfd() for uClibc
  *
  * Copyright (C) 2011 Jean-Christian de Rivaz <jc@eclis.ch>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -10,9 +11,21 @@
 #include <sys/syscall.h>
 #include <sys/eventfd.h>
 
+#include <bits/sclib.h>
+
 /*
  * eventfd()
  */
 #ifdef __NR_eventfd
-_syscall2(int, eventfd, int, count, int, flags)
+int eventfd(int count, int flags)
+{
+	long lfd, fd = sclib_file_add(&sclib_file, 0);
+
+	SCLIB_ERR_RET(fd);
+	flags = 0; /* Not used for eventfd, only for eventfd2 */
+	lfd = SCLIB_LOCAL_CALL(eventfd, 2, count, flags);
+	sclib_file_add_done(&sclib_file, fd, lfd, SYSCALL_SYSID_LOCAL, 0, 0);
+	SCLIB_ERR_RET(lfd);
+	return fd;
+}
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/execve.c uClibc-0.9.33-new/libc/sysdeps/linux/common/execve.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/execve.c	2013-09-23 20:39:08.182221833 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/execve.c	2013-09-23 20:39:32.946222861 -0400
@@ -3,6 +3,7 @@
  * execve() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -12,6 +13,42 @@
 #include <string.h>
 #include <sys/param.h>
 
-_syscall3(int, execve, const char *, filename,
-		  char *const *, argv, char *const *, envp)
+#include <bits/sclib.h>
+
+int execve(const char *filename, char *const *argv, char *const *envp)
+{
+	static const char *lib_path = "LD_LIBRARY_PATH=" SCLIB_LIB_PATH;
+	char **envcur, **nenvp;
+	size_t envlen;
+	long ret;
+
+	for (envcur = (char **) envp; *envcur != NULL; envcur++) {
+		if (strstr(*envcur, "LD_LIBRARY_PATH=") != NULL) {
+			nenvp = (char **) envp;
+			goto skip;
+		}
+	}
+
+	envlen = (size_t) ((char *) envcur - (char *) envp);
+	nenvp = malloc(envlen + 2);
+	SCLIB_MEM_RET(nenvp, ret);
+	envcur = mempcpy(nenvp, envp, envlen);
+	envcur[0] = (char *) lib_path;
+	envcur[1] = NULL;
+
+skip:
+	ret = sclib_fds_save();
+	SCLIB_VAL_RET(ret, ret);
+	ret = SCLIB_LOCAL_CALL(execve, 3, filename, argv, nenvp);
+	SCLIB_VAL_RET(ret, ret);
+	return ret;
+
+error_val:
+	if (envp != nenvp)
+		free(nenvp);
+error_mem:
+	__set_errno(-ret);
+	return -1;
+}
+
 libc_hidden_def(execve)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/faccessat.c uClibc-0.9.33-new/libc/sysdeps/linux/common/faccessat.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/faccessat.c	2013-09-23 20:39:08.182221833 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/faccessat.c	2013-09-23 20:39:32.946222861 -0400
@@ -9,8 +9,13 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_faccessat
-_syscall4(int, faccessat, int, fd, const char *, file, int, type, int, flag)
+int faccessat(int fd, const char *file, int type, int flag)
+{
+	return SCLIB_DFD_SYSCALL_AT(faccessat, 4, fd, file, type, flag);
+}
 #else
 /* should add emulation with faccess() and /proc/self/fd/ ... */
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/fchdir.c uClibc-0.9.33-new/libc/sysdeps/linux/common/fchdir.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/fchdir.c	2013-09-23 20:39:08.226221836 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/fchdir.c	2013-09-23 20:39:32.946222861 -0400
@@ -3,6 +3,7 @@
  * fchdir() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -10,6 +11,34 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
+#include <bits/sclib.h>
+
+int fchdir(int fd)
+{
+	long ret, dfd;
+	int sysid;
+	void *rbuf;
+
+	dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+	SCLIB_ERR_RET(dfd);
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		rbuf = sclib_memory_alloc(&sclib_data[sysid], PATH_MAX - sizeof(SCLIB_STORAGE_PREFIX) + 1);
+		SCLIB_MEM_RET(rbuf, ret);
+		ret = SCLIB_REMOTE_CALL(sysid, syscall_service_fchdir, 3, dfd, sclib_mem(sysid, rbuf), PATH_MAX - sizeof(SCLIB_STORAGE_PREFIX) + 1);
+		if (!SCLIB_IS_ERR(ret)) {
+			memcpy(mempcpy(sclib_file.curdir, SCLIB_STORAGE_PREFIX, sizeof(SCLIB_STORAGE_PREFIX) - 1), rbuf, ret);
+			ret += sizeof(SCLIB_STORAGE_PREFIX) - 1;
+		}
+		sclib_memory_free(&sclib_data[sysid], rbuf);
+	} else {
+		ret = SCLIB_LOCAL_CALL(syscall_service_fchdir, 3, dfd, sclib_file.curdir, PATH_MAX);
+	}
+
+error_mem:
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(ret);
+	sclib_file.curdir_size = ret;
+	return 0;
+}
 
-_syscall1(int, fchdir, int, fd)
 libc_hidden_def(fchdir)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/fchmodat.c uClibc-0.9.33-new/libc/sysdeps/linux/common/fchmodat.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/fchmodat.c	2013-09-23 20:39:08.194221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/fchmodat.c	2013-09-23 20:39:32.950222860 -0400
@@ -9,8 +9,15 @@
 #include <sys/syscall.h>
 #include <sys/stat.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_fchmodat
-_syscall4(int, fchmodat, int, fd, const char *, file, mode_t, mode, int, flag)
+
+int fchmodat(int dirfd, const char *file, mode_t mode, int flags)
+{
+	return SCLIB_DFD_SYSCALL_AT(fchmodat, 4, dirfd, file, mode, flags);
+}
+
 #else
 /* should add emulation with fchmod() and /proc/self/fd/ ... */
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/fchmod.c uClibc-0.9.33-new/libc/sysdeps/linux/common/fchmod.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/fchmod.c	2013-09-23 20:39:08.198221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/fchmod.c	2013-09-23 20:39:32.950222860 -0400
@@ -10,11 +10,9 @@
 #include <sys/syscall.h>
 #include <sys/stat.h>
 
-#define __NR___syscall_fchmod __NR_fchmod
-static __inline__ _syscall2(int, __syscall_fchmod,
-		int, fildes, __kernel_mode_t, mode)
+#include <bits/sclib.h>
 
 int fchmod(int fildes, mode_t mode)
 {
-	return (__syscall_fchmod(fildes, mode));
+	return SCLIB_DFD_SYSCALL(fchmod, 2, fildes, mode);
 }
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/fchownat.c uClibc-0.9.33-new/libc/sysdeps/linux/common/fchownat.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/fchownat.c	2013-09-23 20:39:08.194221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/fchownat.c	2013-09-23 20:39:32.950222860 -0400
@@ -9,8 +9,13 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_fchownat
-_syscall5(int, fchownat, int, fd, const char *, file, uid_t, owner, gid_t, group, int, flag)
+int fchownat(int fd, const char *file, uid_t owner, gid_t group, int flag)
+{
+	return SCLIB_DFD_SYSCALL_AT(fchownat, 5, fd, file, owner, group, flag);
+}
 #else
 /* should add emulation with fchown() and /proc/self/fd/ ... */
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/fchown.c uClibc-0.9.33-new/libc/sysdeps/linux/common/fchown.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/fchown.c	2013-09-23 20:39:08.198221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/fchown.c	2013-09-23 20:39:32.950222860 -0400
@@ -11,13 +11,18 @@
 #include <unistd.h>
 #include <bits/wordsize.h>
 
+#include <bits/sclib.h>
+
 #if (__WORDSIZE == 32 && defined(__NR_fchown32)) || __WORDSIZE == 64
 # ifdef __NR_fchown32
 #  undef __NR_fchown
 #  define __NR_fchown __NR_fchown32
 # endif
 
-_syscall3(int, fchown, int, fd, uid_t, owner, gid_t, group)
+int fchown(int fd, uid_t owner, gid_t group)
+{
+	return SCLIB_DFD_SYSCALL(fchown, 3, fd, owner, group);
+}
 
 #else
 
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/fdatasync.c uClibc-0.9.33-new/libc/sysdeps/linux/common/fdatasync.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/fdatasync.c	2013-09-23 20:39:08.174221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/fdatasync.c	2013-09-23 20:39:32.950222860 -0400
@@ -3,6 +3,7 @@
  * fdatasync() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -10,6 +11,8 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
+#include <bits/sclib.h>
+
 #if !defined __NR_fdatasync && defined __NR_osf_fdatasync
 # define __NR_fdatasync __NR_osf_fdatasync
 #endif
@@ -22,10 +25,18 @@
 # define SINGLE_THREAD_P 1
 # endif
 
-#define __NR___syscall_fdatasync __NR_fdatasync
-
 static __always_inline
-_syscall1(int, __syscall_fdatasync, int, fd)
+int __syscall_fdatasync(int fd)
+{
+	int sysid;
+	long ret, dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	SCLIB_ERR_RET(dfd);
+	ret = SCLIB_SYSID_CALL(sysid, fdatasync, 1, dfd);
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
 int fdatasync(int fd)
 {
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/flock.c uClibc-0.9.33-new/libc/sysdeps/linux/common/flock.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/flock.c	2013-09-23 20:39:08.218221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/flock.c	2013-09-23 20:39:32.950222860 -0400
@@ -3,6 +3,7 @@
  * flock() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -10,8 +11,20 @@
 #include <sys/syscall.h>
 #include <sys/file.h>
 
-#define __NR___syscall_flock __NR_flock
-static __inline__ _syscall2(int, __syscall_flock, int, fd, int, operation)
+#include <bits/sclib.h>
+
+static __inline__
+int __syscall_flock(int fd, int operation)
+{
+	int sysid;
+	long err, dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	SCLIB_ERR_RET(dfd);
+	err = SCLIB_SYSID_CALL(sysid, flock, 2, dfd, operation);
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(err);
+	return err;
+}
 
 int flock(int fd, int operation)
 {
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/fstat64.c uClibc-0.9.33-new/libc/sysdeps/linux/common/fstat64.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/fstat64.c	2013-09-23 20:39:08.278221837 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/fstat64.c	2013-09-23 20:39:32.950222860 -0400
@@ -3,6 +3,7 @@
  * fstat64() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -14,21 +15,34 @@
 #include <sys/stat.h>
 #include "xstatconv.h"
 
-
-#define __NR___syscall_fstat64 __NR_fstat64
-static __inline__ _syscall2(int, __syscall_fstat64,
-		int, filedes, struct kernel_stat64 *, buf)
+#include <bits/sclib.h>
 
 int fstat64(int fd, struct stat64 *buf)
 {
-	int result;
-	struct kernel_stat64 kbuf;
+	int sysid;
+	long ret, dfd = sclib_file_getid(&sclib_file, fd, &sysid);
 
-	result = __syscall_fstat64(fd, &kbuf);
-	if (result == 0) {
-		__xstat64_conv(&kbuf, buf);
+	SCLIB_ERR_RET(dfd);
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		void *mem = sclib_memory_alloc(&sclib_data[sysid], sizeof(struct kernel_stat64));
+
+		SCLIB_MEM_RET(mem, ret);
+		ret = SCLIB_REMOTE_CALL(sysid, fstat64, 2, dfd, sclib_mem(sysid, mem));
+		if (!SCLIB_IS_ERR(ret))
+			__xstat64_conv(mem, buf);
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		struct kernel_stat64 kbuf;
+		ret = SCLIB_LOCAL_CALL(fstat64, 2, dfd, &kbuf);
+		if (!SCLIB_IS_ERR(ret))
+			__xstat64_conv(&kbuf, buf);
 	}
-	return result;
+
+error_mem:
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(ret);
+	return 0;
 }
+
 libc_hidden_def(fstat64)
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/fstatat64.c uClibc-0.9.33-new/libc/sysdeps/linux/common/fstatat64.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/fstatat64.c	2013-09-23 20:39:08.178221833 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/fstatat64.c	2013-09-23 20:39:32.950222860 -0400
@@ -2,6 +2,7 @@
  * fstatat64() for uClibc
  *
  * Copyright (C) 2009 Analog Devices Inc.
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -10,6 +11,8 @@
 #include <sys/stat.h>
 #include "xstatconv.h"
 
+#include <bits/sclib.h>
+
 #ifdef __UCLIBC_HAS_LFS__
 
 /* 64bit ports tend to favor newfstatat() */
@@ -20,14 +23,45 @@
 #ifdef __NR_fstatat64
 int fstatat64(int fd, const char *file, struct stat64 *buf, int flag)
 {
-	int ret;
-	struct kernel_stat64 kbuf;
-
-	ret = INLINE_SYSCALL(fstatat64, 4, fd, file, &kbuf, flag);
-	if (ret == 0)
-		__xstat64_conv(&kbuf, buf);
+	int sysid;
+	long ret, dfd;
 
-	return ret;
+	if (fd == AT_FDCWD) {
+		sysid = SYSCALL_SYSID_LOCAL;
+		dfd = fd; /* AT_FDCWD is negative */
+	} else if (file && *file == '/') {
+		sysid = SYSCALL_SYSID_LOCAL;
+		dfd = -1;
+	} else {
+		dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+		SCLIB_ERR_RET(dfd);
+	}
+
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		void *mem;
+		if (unlikely(file && *file != '\0')) {
+			ret = -EINVAL;
+			goto error_path;
+		}
+		mem = sclib_memory_alloc(&sclib_data[sysid], sizeof(struct kernel_stat64));
+		SCLIB_MEM_RET(mem, ret);
+		ret = SCLIB_REMOTE_CALL(sysid, fstatat64, 4, dfd, 0, sclib_mem(sysid, mem), flag);
+		if (!SCLIB_IS_ERR(ret))
+			__xstat64_conv(mem, buf);
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		struct kernel_stat64 kbuf;
+		ret = SCLIB_LOCAL_CALL(fstatat64, 4, dfd, file, &kbuf, flag);
+		if (!SCLIB_IS_ERR(ret))
+			__xstat64_conv(&kbuf, buf);
+	}
+
+error_mem:
+error_path:
+	if (dfd >= 0)
+		sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(ret);
+	return 0;
 }
 #else
 /* should add emulation with fstat64() and /proc/self/fd/ ... */
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/fstatat.c uClibc-0.9.33-new/libc/sysdeps/linux/common/fstatat.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/fstatat.c	2013-09-23 20:39:08.222221835 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/fstatat.c	2013-09-23 20:39:32.950222860 -0400
@@ -2,6 +2,7 @@
  * fstatat() for uClibc
  *
  * Copyright (C) 2009 Analog Devices Inc.
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -10,6 +11,8 @@
 #include <sys/stat.h>
 #include "xstatconv.h"
 
+#include <bits/sclib.h>
+
 /* 64bit ports tend to favor newfstatat() */
 #ifdef __NR_newfstatat
 # define __NR_fstatat64 __NR_newfstatat
@@ -18,14 +21,45 @@
 #ifdef __NR_fstatat64
 int fstatat(int fd, const char *file, struct stat *buf, int flag)
 {
-	int ret;
-	struct kernel_stat64 kbuf;
+	int sysid;
+	long ret, dfd;
+
+	if (fd == AT_FDCWD) {
+		sysid = SYSCALL_SYSID_LOCAL;
+		dfd = fd; /* AT_FDCWD is negative */
+	} else if (file && *file == '/') {
+		sysid = SYSCALL_SYSID_LOCAL;
+		dfd = -1;
+	} else {
+		dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+		SCLIB_ERR_RET(dfd);
+	}
 
-	ret = INLINE_SYSCALL(fstatat64, 4, fd, file, &kbuf, flag);
-	if (ret == 0)
-		__xstat32_conv(&kbuf, buf);
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		void *mem;
+		if (unlikely(file && *file != '\0')) {
+			ret = -EINVAL;
+			goto error_path;
+		}
+		mem = sclib_memory_alloc(&sclib_data[sysid], sizeof(struct kernel_stat64));
+		SCLIB_MEM_RET(mem, ret);
+		ret = SCLIB_REMOTE_CALL(sysid, fstatat64, 4, dfd, -1, sclib_mem(sysid, mem), flag);
+		if (!SCLIB_IS_ERR(ret))
+			__xstat32_conv(mem, buf);
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		struct kernel_stat64 kbuf;
+		ret = SCLIB_LOCAL_CALL(fstatat64, 4, dfd, file, &kbuf, flag);
+		if (!SCLIB_IS_ERR(ret))
+			__xstat32_conv(&kbuf, buf);
+	}
 
-	return ret;
+error_mem:
+error_path:
+	if (dfd >= 0)
+		sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(ret);
+	return 0;
 }
 #else
 /* should add emulation with fstat() and /proc/self/fd/ ... */
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/fstat.c uClibc-0.9.33-new/libc/sysdeps/linux/common/fstat.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/fstat.c	2013-09-23 20:39:08.174221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/fstat.c	2013-09-23 20:39:32.950222860 -0400
@@ -12,20 +12,35 @@
 #include <sys/stat.h>
 #include "xstatconv.h"
 
-#define __NR___syscall_fstat __NR_fstat
-static __inline__ _syscall2(int, __syscall_fstat, int, fd, struct kernel_stat *, buf)
+#include <bits/sclib.h>
 
 int fstat(int fd, struct stat *buf)
 {
-	int result;
-	struct kernel_stat kbuf;
+	int sysid;
+	long ret, dfd = sclib_file_getid(&sclib_file, fd, &sysid);
 
-	result = __syscall_fstat(fd, &kbuf);
-	if (result == 0) {
-		__xstat_conv(&kbuf, buf);
+	SCLIB_ERR_RET(dfd);
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		void *mem = sclib_memory_alloc(&sclib_data[sysid], sizeof(struct kernel_stat));
+
+		SCLIB_MEM_RET(mem, ret);
+		ret = SCLIB_REMOTE_CALL(sysid, fstat, 2, dfd, sclib_mem(sysid, mem));
+		if (!SCLIB_IS_ERR(ret))
+			__xstat_conv(mem, buf);
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		struct kernel_stat kbuf;
+		ret = SCLIB_LOCAL_CALL(fstat, 2, dfd, &kbuf);
+		if (!SCLIB_IS_ERR(ret))
+			__xstat_conv(&kbuf, buf);
 	}
-	return result;
+
+error_mem:
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(ret);
+	return 0;
 }
+
 libc_hidden_def(fstat)
 
 #if ! defined __NR_fstat64 && defined __UCLIBC_HAS_LFS__
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/fstatfs.c uClibc-0.9.33-new/libc/sysdeps/linux/common/fstatfs.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/fstatfs.c	2013-09-23 20:39:08.278221837 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/fstatfs.c	2013-09-23 20:39:32.950222860 -0400
@@ -10,6 +10,8 @@
 #include <sys/syscall.h>
 #include <sys/vfs.h>
 
+#include <bits/sclib.h>
+
 #ifndef __USE_FILE_OFFSET64
 extern int fstatfs (int __fildes, struct statfs *__buf)
      __THROW __nonnull ((2));
@@ -23,8 +25,10 @@
 #endif
 
 extern __typeof(fstatfs) __libc_fstatfs attribute_hidden;
-#define __NR___libc_fstatfs __NR_fstatfs
-_syscall2(int, __libc_fstatfs, int, fd, struct statfs *, buf)
+int __libc_fstatfs(int fd, struct statfs *buf)
+{
+	return SCLIB_DFD_OUTBUFSZ_SYSCALL(fstatfs, sizeof(struct statfs), 2, fd, buf);
+}
 
 #if defined __UCLIBC_LINUX_SPECIFIC__
 weak_alias(__libc_fstatfs,fstatfs)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/fsync.c uClibc-0.9.33-new/libc/sysdeps/linux/common/fsync.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/fsync.c	2013-09-23 20:39:08.186221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/fsync.c	2013-09-23 20:39:32.950222860 -0400
@@ -3,6 +3,7 @@
  * fsync() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -10,14 +11,26 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
+#include <bits/sclib.h>
+
 #ifdef __UCLIBC_HAS_THREADS_NATIVE__
 #include "sysdep-cancel.h"
 #else
 #define SINGLE_THREAD_P 1
 #endif
 
-#define __NR___syscall_fsync __NR_fsync
-static inline _syscall1(int, __syscall_fsync, int, fd)
+static __always_inline
+int __syscall_fsync(int fd)
+{
+	int sysid;
+	long ret, dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	SCLIB_ERR_RET(dfd);
+	ret = SCLIB_SYSID_CALL(sysid, fsync, 1, dfd);
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
 extern __typeof(fsync) __libc_fsync;
 
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/ftruncate64.c uClibc-0.9.33-new/libc/sysdeps/linux/common/ftruncate64.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/ftruncate64.c	2013-09-23 20:39:08.230221837 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/ftruncate64.c	2013-09-23 20:39:32.950222860 -0400
@@ -27,7 +27,10 @@
 #  if __WORDSIZE == 64
 
 /* For a 64 bit machine, life is simple... */
-_syscall2(int, ftruncate64, int, fd, __off64_t, length)
+int ftruncate64(int fd, __off64_t length)
+{
+	return SCLIB_DFD_SYSCALL(ftruncate64, 2, fd, length);
+}
 
 #  elif __WORDSIZE == 32
 
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/ftruncate.c uClibc-0.9.33-new/libc/sysdeps/linux/common/ftruncate.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/ftruncate.c	2013-09-23 20:39:08.266221839 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/ftruncate.c	2013-09-23 20:39:32.950222860 -0400
@@ -10,6 +10,11 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
+#include <bits/sclib.h>
+
+int ftruncate(int fd, off_t length)
+{
+	return SCLIB_DFD_SYSCALL(ftruncate, 2, fd, length);
+}
 
-_syscall2(int, ftruncate, int, fd, __off_t, length)
 libc_hidden_def(ftruncate)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/futimesat.c uClibc-0.9.33-new/libc/sysdeps/linux/common/futimesat.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/futimesat.c	2013-09-23 20:39:08.218221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/futimesat.c	2013-09-23 20:39:32.950222860 -0400
@@ -9,8 +9,13 @@
 #include <sys/syscall.h>
 #include <sys/time.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_futimesat
-_syscall3(int, futimesat, int, fd, const char *, file, const struct timeval *, tvp)
+int futimesat(int fd, const char *file, const struct timeval *tvp)
+{
+	return SCLIB_DFD_INBUF_SYSCALL_AT(futimesat, sizeof(struct timeval) * 2, 3, fd, file, tvp);
+}
 #else
 /* should add emulation with futimes() and /proc/self/fd/ ... */
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/getcwd.c uClibc-0.9.33-new/libc/sysdeps/linux/common/getcwd.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/getcwd.c	2013-09-23 20:39:08.198221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/getcwd.c	2013-09-23 20:39:32.950222860 -0400
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -15,13 +16,20 @@
 #include <sys/param.h>
 #include <sys/syscall.h>
 
+#include <bits/sclib.h>
 
+#if 1 //ifdef __NR_getcwd
 
-#ifdef __NR_getcwd
-
-# define __NR___syscall_getcwd __NR_getcwd
-static __always_inline
-_syscall2(int, __syscall_getcwd, char *, buf, unsigned long, size)
+static __always_inline int __syscall_getcwd(char *buf, unsigned long size)
+{
+	unsigned long cur_size = sclib_file.curdir_size;
+	if (unlikely(size < cur_size))
+		return -ERANGE;
+	if (size > cur_size)
+		size = cur_size;
+	memcpy(buf, sclib_file.curdir, size);
+	return size;
+}
 
 #else
 
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/getdents64.c uClibc-0.9.33-new/libc/sysdeps/linux/common/getdents64.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/getdents64.c	2013-09-23 20:39:08.182221833 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/getdents64.c	2013-09-23 20:39:32.950222860 -0400
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -18,6 +19,8 @@
 #include <bits/kernel_types.h>
 #include <bits/uClibc_alloc.h>
 
+#include <bits/sclib.h>
+
 #if defined __UCLIBC_HAS_LFS__ && defined __NR_getdents64
 
 # ifndef offsetof
@@ -33,8 +36,100 @@
     char		d_name[256];
 };
 
-# define __NR___syscall_getdents64 __NR_getdents64
-static __inline__ _syscall3(int, __syscall_getdents64, int, fd, unsigned char *, dirp, size_t, count)
+static __always_inline int __syscall_getdents64(int fd, unsigned char *kdirp,
+	size_t count)
+{
+	long dfd, ret;
+	int sysid;
+	void *rbuf;
+	uint8_t flags;
+
+	dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+	SCLIB_ERR_RET(dfd);
+	sclib_read_lock_fd_flags(&sclib_file, fd);
+	flags = sclib_file.fds[fd].flags;
+
+	if (unlikely(flags & SCLIB_FD_TRAN)) {
+		const size_t alignment = __alignof__ (struct kernel_dirent64);
+		struct kernel_dirent64 *tran_cur, *tran_end, *kdirp_cur;
+		size_t tran_count;
+		long tran_ret, tran_fd;
+		int tran_dfd;
+
+		/* Each file descriptor will require expansion of at most 4 digits;
+			an alignment is at least 4 bytes. Therefore, we at most expand
+			each entry by an alignment unit. */
+		tran_count = (count / offsetof(struct kernel_dirent64, d_name))
+						* alignment;
+		if (count <= tran_count) {
+			ret = -EINVAL;
+			goto error_mem;
+		}
+		tran_count = count - tran_count;
+		if (sysid == SYSCALL_SYSID_LOCAL) {
+			rbuf = malloc(tran_count);
+			SCLIB_MEM_RET(rbuf, ret);
+			tran_ret = SCLIB_LOCAL_CALL(getdents64, 3, dfd, rbuf, tran_count);
+		} else {
+			rbuf = sclib_memory_alloc(&sclib_data[sysid], tran_count);
+			SCLIB_MEM_RET(rbuf, ret);
+			tran_ret = SCLIB_REMOTE_CALL(sysid, getdents64, 3, dfd, sclib_mem(sysid, rbuf), tran_count);
+		}
+
+		if (!SCLIB_IS_ERR(tran_ret)) { /* Translate */
+			tran_cur = rbuf;
+			tran_end = rbuf + tran_ret;
+			kdirp_cur = (void *) kdirp;
+			for (; tran_cur < tran_end;
+					tran_cur = (void *) tran_cur + tran_cur->d_reclen) {
+				if (tran_cur->d_name[0] == '.') { /* Not a file descriptor */
+					kdirp_cur = mempcpy(kdirp_cur, tran_cur,
+						tran_cur->d_reclen);
+					continue;
+				}
+				kdirp_cur->d_ino = tran_cur->d_ino;
+				kdirp_cur->d_off = tran_cur->d_off;
+				kdirp_cur->d_type = tran_cur->d_type;
+				if (sscanf(tran_cur->d_name, "%d", &tran_dfd) != 1 ||
+					(tran_fd = sclib_file_reverse_lookup(&sclib_file,
+						tran_dfd)) < 0) {
+					continue;
+				}
+				kdirp_cur->d_reclen = sprintf(kdirp_cur->d_name, "%d",
+					(int) tran_fd) + 1; /* Null-character */
+				kdirp_cur->d_reclen = (kdirp_cur->d_reclen +
+					offsetof(struct kernel_dirent64, d_name) +
+						alignment - 1) & ~(alignment - 1);
+				kdirp_cur = (void *) kdirp_cur + kdirp_cur->d_reclen;
+			}
+			ret = (size_t) ((void *) kdirp_cur - (void *) kdirp);
+		} else {
+			ret = tran_ret;
+		}
+		if (sysid == SYSCALL_SYSID_LOCAL) {
+			free(rbuf);
+		} else {
+			sclib_memory_free(&sclib_data[sysid], rbuf);
+		}
+	} else {
+		if (sysid != SYSCALL_SYSID_LOCAL) {
+			rbuf = sclib_memory_alloc(&sclib_data[sysid], count);
+			SCLIB_MEM_RET(rbuf, ret);
+			ret = SCLIB_REMOTE_CALL(sysid, getdents64, 3, dfd, sclib_mem(sysid, rbuf), count);
+			if (!SCLIB_IS_ERR(ret))
+				memcpy(kdirp, rbuf, ret);
+			sclib_memory_free(&sclib_data[sysid], rbuf);
+		} else {
+			ret = SCLIB_LOCAL_CALL(getdents64, 3, dfd, kdirp, count);
+		}
+	}
+
+error_mem:
+	sclib_read_unlock_fd_flags(&sclib_file, fd);
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
 ssize_t __getdents64 (int fd, char *buf, size_t nbytes) attribute_hidden;
 ssize_t __getdents64 (int fd, char *buf, size_t nbytes)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/inotify.c uClibc-0.9.33-new/libc/sysdeps/linux/common/inotify.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/inotify.c	2013-09-23 20:39:08.178221833 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/inotify.c	2013-09-23 20:39:32.950222860 -0400
@@ -11,18 +11,52 @@
 #include <sys/syscall.h>
 #include <sys/inotify.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_inotify_init
-_syscall0(int, inotify_init)
+int inotify_init(void)
+{
+	long lfd, fd = sclib_file_add(&sclib_file, 0);
+
+	SCLIB_ERR_RET(fd);
+	lfd = SCLIB_LOCAL_CALL(inotify_init, 0);
+	sclib_file_add_done(&sclib_file, fd, lfd, SYSCALL_SYSID_LOCAL, 0, 0);
+	SCLIB_ERR_RET(lfd);
+	return fd;
+}
 #endif
 
 #ifdef __NR_inotify_init1
-_syscall1(int, inotify_init1, int, flags)
+int inotify_init1(int flags)
+{
+	long lfd, fd = sclib_file_add(&sclib_file, 0);
+
+	SCLIB_ERR_RET(fd);
+	lfd = SCLIB_LOCAL_CALL(inotify_init1, 1, flags);
+	if (SCLIB_IS_ERR(lfd)) {
+		sclib_file_add_fail(&sclib_file, fd);
+		fd = lfd;
+	} else {
+		uint8_t lfd_flags = 0;
+		if (flags & IN_CLOEXEC)
+			lfd_flags |= SCLIB_FD_EXEC;
+		sclib_file_add_ok(&sclib_file, fd, lfd, SYSCALL_SYSID_LOCAL, lfd_flags, 0);
+	}
+	SCLIB_ERR_RET(lfd);
+	return fd;
+}
 #endif
 
 #ifdef __NR_inotify_add_watch
-_syscall3(int, inotify_add_watch, int, fd, const char *, path, uint32_t, mask)
+int inotify_add_watch(int fd, const char * path, uint32_t mask)
+{
+	return SCLIB_LFDPATH_SYSCALL(inotify_add_watch, 3, fd, path, mask);
+}
 #endif
 
 #ifdef __NR_inotify_rm_watch
-_syscall2(int, inotify_rm_watch, int, fd, uint32_t, wd)
+int inotify_rm_watch(int fd, uint32_t wd)
+{
+	return SCLIB_LFD_SYSCALL(inotify_rm_watch, 2, fd, wd);
+}
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/ioctl.c uClibc-0.9.33-new/libc/sysdeps/linux/common/ioctl.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/ioctl.c	2013-09-23 20:39:08.182221833 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/ioctl.c	2013-09-23 20:39:32.950222860 -0400
@@ -3,6 +3,7 @@
  * ioctl() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -10,6 +11,9 @@
 #include <sys/syscall.h>
 #include <stdarg.h>
 #include <sys/ioctl.h>
+#include <string.h>
+
+#include <bits/sclib.h>
 
 #ifdef __UCLIBC_HAS_THREADS_NATIVE__
 #include <sysdep-cancel.h>
@@ -19,9 +23,41 @@
 
 libc_hidden_proto(ioctl)
 
-#define __NR___syscall_ioctl __NR_ioctl
-static __always_inline
-_syscall3(int, __syscall_ioctl, int, fd, unsigned long int, request, void *, arg)
+static int __syscall_ioctl(int fd, unsigned long int request, void *arg)
+{
+	int sysid;
+	long ret, dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	SCLIB_ERR_RET(dfd);
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		void *mem = NULL;
+		void *rarg = arg;
+		unsigned dir;
+		size_t size;
+
+		sclib_ioctl_decode(request, &dir, &size);
+		if (size > 0) {
+			mem = sclib_memory_alloc(&sclib_data[sysid], size);
+			SCLIB_MEM_RET(mem, ret);
+			if (dir & _IOC_WRITE)
+				mem = memcpy(mem, arg, size);
+			rarg = sclib_mem(sysid, mem);
+		}
+		ret = SCLIB_REMOTE_CALL(sysid, ioctl, 3, dfd, request, rarg);
+		if (mem) {
+			if ((dir & _IOC_READ) && !SCLIB_IS_ERR(ret))
+				memcpy(arg, mem, size);
+			sclib_memory_free(&sclib_data[sysid], mem);
+		}
+	} else {
+		ret = SCLIB_LOCAL_CALL(ioctl, 3, dfd, request, arg);
+	}
+
+error_mem:
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
 int ioctl(int fd, unsigned long int request, ...)
 {
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/lchown.c uClibc-0.9.33-new/libc/sysdeps/linux/common/lchown.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/lchown.c	2013-09-23 20:39:08.182221833 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/lchown.c	2013-09-23 20:39:32.950222860 -0400
@@ -11,13 +11,18 @@
 #include <unistd.h>
 #include <bits/wordsize.h>
 
+#include <bits/sclib.h>
+
 #if (__WORDSIZE == 32 && defined(__NR_lchown32)) || __WORDSIZE == 64
 # ifdef __NR_lchown32
 #  undef __NR_lchown
 #  define __NR_lchown __NR_lchown32
 # endif
 
-_syscall3(int, lchown, const char *, path, uid_t, owner, gid_t, group)
+int lchown(const char *path, uid_t owner, gid_t group)
+{
+	return SCLIB_PATH_CALL(lchown, 3, path, owner, group);
+}
 
 #else
 
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/linkat.c uClibc-0.9.33-new/libc/sysdeps/linux/common/linkat.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/linkat.c	2013-09-23 20:39:08.218221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/linkat.c	2013-09-23 20:39:32.950222860 -0400
@@ -9,8 +9,13 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_linkat
-_syscall5(int, linkat, int, fromfd, const char *, from, int, tofd, const char *, to, int, flags)
+int linkat(int fromfd, const char *from, int tofd, const char *to, int flags)
+{
+	return SCLIB_DFD_SYSCALL_AT2(linkat, 5, fromfd, from, tofd, to, flags);
+}
 #else
 /* should add emulation with link() and /proc/self/fd/ ... */
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/link.c uClibc-0.9.33-new/libc/sysdeps/linux/common/link.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/link.c	2013-09-23 20:39:08.222221835 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/link.c	2013-09-23 20:39:32.954222860 -0400
@@ -9,4 +9,11 @@
 
 #include <sys/syscall.h>
 #include <unistd.h>
-_syscall2(int, link, const char *, oldpath, const char *, newpath)
+
+#include <bits/sclib.h>
+
+int link(const char *oldpath, const char *newpath)
+{
+	return SCLIB_PATH_CALL2(link, 2, oldpath, newpath);
+}
+
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/lseek.c uClibc-0.9.33-new/libc/sysdeps/linux/common/lseek.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/lseek.c	2013-09-23 20:39:08.186221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/lseek.c	2013-09-23 20:39:32.954222860 -0400
@@ -10,8 +10,15 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_lseek
-_syscall3(__off_t, lseek, int, fildes, __off_t, offset, int, whence)
+
+__off_t lseek(int fd, __off_t offset, int whence)
+{
+	return SCLIB_DFD_SYSCALL(lseek, 3, fd, offset, whence);
+}
+
 #else
 
 __off_t lseek(int fildes, __off_t offset, int whence)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/lstat.c uClibc-0.9.33-new/libc/sysdeps/linux/common/lstat.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/lstat.c	2013-09-23 20:39:08.218221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/lstat.c	2013-09-23 20:39:32.954222860 -0400
@@ -3,6 +3,7 @@
  * lstat() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -12,20 +13,35 @@
 #include <sys/stat.h>
 #include "xstatconv.h"
 
-#define __NR___syscall_lstat __NR_lstat
-static __inline__ _syscall2(int, __syscall_lstat,
-		const char *, file_name, struct kernel_stat *, buf)
+#include <bits/sclib.h>
 
 int lstat(const char *file_name, struct stat *buf)
 {
-	int result;
 	struct kernel_stat kbuf;
+	char abspath[PATH_MAX], *dpath;
+	long ret;
+	int sysid;
+	void *rbuf, *off;
+	size_t sz;
 
-	result = __syscall_lstat(file_name, &kbuf);
-	if (result == 0) {
-		__xstat_conv(&kbuf, buf);
+    dpath = sclib_get_path(abspath, file_name, &sysid, &sz);
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		rbuf = sclib_memory_alloc(&sclib_data[sysid], sizeof(struct kernel_stat) + sz);
+		SCLIB_MEM_RET(rbuf, ret);
+		memcpy(rbuf + sizeof(struct kernel_stat), dpath, sz);
+		off = sclib_mem(sysid, rbuf);
+		ret = SCLIB_REMOTE_CALL(sysid, lstat, 2, off + sizeof(struct kernel_stat), off);
+		if (ret == 0)
+			__xstat_conv(rbuf, buf);
+		sclib_memory_free(&sclib_data[sysid], rbuf);
+	} else {
+		ret = SCLIB_LOCAL_CALL(lstat, 2, dpath, &kbuf);
+		if (ret == 0)
+			__xstat_conv(&kbuf, buf);
 	}
-	return result;
+error_mem:
+	SCLIB_ERR_RET(ret);
+	return ret;
 }
 libc_hidden_def(lstat)
 
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/mkdirat.c uClibc-0.9.33-new/libc/sysdeps/linux/common/mkdirat.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/mkdirat.c	2013-09-23 20:39:08.194221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/mkdirat.c	2013-09-23 20:39:32.954222860 -0400
@@ -9,8 +9,13 @@
 #include <sys/syscall.h>
 #include <sys/stat.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_mkdirat
-_syscall3(int, mkdirat, int, fd, const char *, path, mode_t, mode)
+int mkdirat(int fd, const char *path, mode_t mode)
+{
+	return SCLIB_DFD_SYSCALL_AT(mkdirat, 3, fd, path, mode);
+}
 #else
 /* should add emulation with mkdir() and /proc/self/fd/ ... */
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/mkdir.c uClibc-0.9.33-new/libc/sysdeps/linux/common/mkdir.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/mkdir.c	2013-09-23 20:39:08.266221839 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/mkdir.c	2013-09-23 20:39:32.954222860 -0400
@@ -10,13 +10,10 @@
 #include <sys/syscall.h>
 #include <sys/stat.h>
 
-
-#define __NR___syscall_mkdir __NR_mkdir
-static __inline__ _syscall2(int, __syscall_mkdir, const char *, pathname,
-		__kernel_mode_t, mode)
+#include <bits/sclib.h>
 
 int mkdir(const char *pathname, mode_t mode)
 {
-	return (__syscall_mkdir(pathname, mode));
+	return SCLIB_PATH_CALL(mkdir, 2, pathname, mode);
 }
 libc_hidden_def(mkdir)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/mknodat.c uClibc-0.9.33-new/libc/sysdeps/linux/common/mknodat.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/mknodat.c	2013-09-23 20:39:08.194221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/mknodat.c	2013-09-23 20:39:32.954222860 -0400
@@ -9,6 +9,8 @@
 #include <sys/syscall.h>
 #include <sys/stat.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_mknodat
 int mknodat(int fd, const char *path, mode_t mode, dev_t dev)
 {
@@ -17,7 +19,7 @@
 	/* We must convert the value to dev_t type used by the kernel.  */
 	k_dev = (dev) & ((1ULL << 32) - 1);
 
-	return INLINE_SYSCALL(mknodat, 4, fd, path, mode, (unsigned int)k_dev);
+	return SCLIB_DFD_SYSCALL_AT(mknodat, 4, fd, path, mode, (unsigned int)k_dev);
 }
 libc_hidden_def(mknodat)
 #else
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/mknod.c uClibc-0.9.33-new/libc/sysdeps/linux/common/mknod.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/mknod.c	2013-09-23 20:39:08.278221837 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/mknod.c	2013-09-23 20:39:32.954222860 -0400
@@ -10,6 +10,8 @@
 #include <sys/syscall.h>
 #include <sys/stat.h>
 
+#include <bits/sclib.h>
+
 int mknod(const char *path, mode_t mode, dev_t dev)
 {
 	unsigned long long int k_dev;
@@ -17,6 +19,6 @@
 	/* We must convert the value to dev_t type used by the kernel.  */
 	k_dev = (dev) & ((1ULL << 32) - 1);
 
-	return INLINE_SYSCALL(mknod, 3, path, mode, (unsigned int)k_dev);
+	return SCLIB_PATH_CALL(mknod, 3, path, mode, (unsigned int)k_dev);
 }
 libc_hidden_def(mknod)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/mmap64.c uClibc-0.9.33-new/libc/sysdeps/linux/common/mmap64.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/mmap64.c	2013-09-23 20:39:08.266221839 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/mmap64.c	2013-09-23 20:39:32.954222860 -0400
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -15,6 +16,7 @@
 #include <sys/syscall.h>
 #include <bits/uClibc_page.h>
 
+#include <bits/sclib.h>
 
 # if !defined __NR_mmap2
 
@@ -39,10 +41,23 @@
 
 # else
 
-#  define __NR___syscall_mmap2	    __NR_mmap2
-static __inline__ _syscall6(__ptr_t, __syscall_mmap2, __ptr_t, addr,
-			size_t, len, int, prot, int, flags, int, fd,
-			off_t, offset)
+__ptr_t __syscall_mmap2(__ptr_t addr, size_t length, int prot, int flags,
+	int fd, off_t offset)
+{
+	long ret, lfd = -1;
+
+	if (!(flags & MAP_ANONYMOUS)) {
+		lfd = sclib_file_get(&sclib_file, fd, SYSCALL_SYSID_LOCAL);
+		if (SCLIB_IS_ERR(lfd)) {
+			__set_errno(-lfd);
+			return (void *) -1;
+		}
+	}
+	ret = INLINE_SYSCALL(mmap2, 6, addr, length, prot, flags, lfd, offset);
+	if (!(flags & MAP_ANONYMOUS))
+		sclib_file_put(&sclib_file, fd);
+	return (__ptr_t) ret;
+}
 
 /* Some architectures always use 12 as page shift for mmap2() eventhough the
  * real PAGE_SHIFT != 12.  Other architectures use the same value as
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/not-cancel.h uClibc-0.9.33-new/libc/sysdeps/linux/common/not-cancel.h
--- uClibc-0.9.33/libc/sysdeps/linux/common/not-cancel.h	2013-09-23 20:39:08.270221839 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/not-cancel.h	2013-09-23 20:39:32.954222860 -0400
@@ -20,31 +20,54 @@
 
 #include <sysdep.h>
 
+#include <bits/sclib.h>
+#include <bits/sclib_syscalls.h>
+
 /* Uncancelable open.  */
-#define open_not_cancel(name, flags, mode) \
-   INLINE_SYSCALL (open, 3, (const char *) (name), (flags), (mode))
-#define open_not_cancel_2(name, flags) \
-   INLINE_SYSCALL (open, 2, (const char *) (name), (flags))
+static __always_inline int open_not_cancel(const char *name, int flags, mode_t mode)
+{
+	long ret = __internal_sys_open(name, flags, mode);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
+
+static __always_inline int open_not_cancel_2(const char *name, int flags)
+{
+	long ret = __internal_sys_open(name, flags, 0);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
 /* Uncancelable close.  */
-#define close_not_cancel(fd) \
-  INLINE_SYSCALL (close, 1, fd)
-#define close_not_cancel_no_status(fd) \
-  (void) ({ INTERNAL_SYSCALL_DECL (err);				      \
-	    INTERNAL_SYSCALL (close, err, 1, (fd)); })
+static __always_inline int close_not_cancel(int fd)
+{
+	long ret = __internal_sys_close(fd);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
+
+static __always_inline void close_not_cancel_no_status(int fd)
+{
+	__internal_sys_close(fd);
+}
 
 /* Uncancelable read.  */
-#define read_not_cancel(fd, buf, n) \
-  INLINE_SYSCALL (read, 3, (fd), (buf), (n))
+static __always_inline ssize_t read_not_cancel(int fd, void *buf, size_t n)
+{
+	return SCLIB_LFD_SYSCALL(read, 3, fd, buf, n);
+}
 
 /* Uncancelable write.  */
-#define write_not_cancel(fd, buf, n) \
-  INLINE_SYSCALL (write, 3, (fd), (buf), (n))
+static __always_inline ssize_t write_not_cancel(int fd, const void *buf, size_t n)
+{
+	return SCLIB_LFD_SYSCALL(write, 3, fd, buf, n);
+}
 
 /* Uncancelable writev.  */
-#define writev_not_cancel_no_status(fd, iov, n) \
-  (void) ({ INTERNAL_SYSCALL_DECL (err);				      \
-	    INTERNAL_SYSCALL (writev, err, 3, (fd), (iov), (n)); })
+static __always_inline void writev_not_cancel_no_status(int fd, const struct iovec *iov, int n)
+{
+	SCLIB_LFD_SYSCALL_NOSTATUS(writev, 3, fd, iov, n);
+}
 
 /* Uncancelable fcntl.  */
 #define fcntl_not_cancel(fd, cmd, val) \
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/open64.c uClibc-0.9.33-new/libc/sysdeps/linux/common/open64.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/open64.c	2013-09-23 20:39:08.194221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/open64.c	2013-09-23 20:39:32.954222860 -0400
@@ -12,12 +12,22 @@
 #include <sysdep-cancel.h>
 #endif
 
+#include <bits/sclib.h>
+#include <bits/sclib_syscalls.h>
+
 #ifdef __UCLIBC_HAS_LFS__
 
 #ifndef O_LARGEFILE
 # define O_LARGEFILE	0100000
 #endif
 
+static __inline__ int __syscall_open(const char *file, int flags, int mode)
+{
+	long ret = __internal_sys_open(file, flags, mode);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
+
 /* Open FILE with access OFLAG.  If OFLAG includes O_CREAT,
    a third argument is the file protection.  */
 int open64 (const char *file, int oflag, ...)
@@ -34,11 +44,11 @@
 
 #ifdef __UCLIBC_HAS_THREADS_NATIVE__
   if (SINGLE_THREAD_P)
-    return INLINE_SYSCALL (open, 3, file, oflag | O_LARGEFILE, mode);
+    return __syscall_open(file, oflag | O_LARGEFILE, mode);
 
   int oldtype = LIBC_CANCEL_ASYNC ();
 
-  int result = INLINE_SYSCALL (open, 3, file, oflag | O_LARGEFILE, mode);
+  int result = __syscall_open(file, oflag | O_LARGEFILE, mode);
 
   LIBC_CANCEL_RESET (oldtype);
 
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/openat.c uClibc-0.9.33-new/libc/sysdeps/linux/common/openat.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/openat.c	2013-09-23 20:39:08.194221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/openat.c	2013-09-23 20:39:32.954222860 -0400
@@ -2,6 +2,7 @@
  * openat() for uClibc
  *
  * Copyright (C) 2009 Analog Devices Inc.
+ * Copyright (C) 2012-2013 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -11,6 +12,8 @@
 #include <fcntl.h>
 #undef openat
 
+#include <bits/sclib.h>
+
 #ifdef __NR_openat
 /* The openat() prototype is varargs based, but we don't care about that
  * here, so need to provide our own dedicated signature.
@@ -18,7 +21,38 @@
 extern int openat(int fd, const char *file, int oflag, mode_t mode);
 libc_hidden_proto(openat)
 
-_syscall4(int, openat, int, fd, const char *, file, int, oflag, mode_t, mode)
+int openat(int dirfd, const char *file, int oflag, mode_t mode)
+{
+	long ldirfd, lfd, fd;
+
+	if (dirfd == AT_FDCWD) {
+		ldirfd = dirfd; /* AT_FDCWD is negative */
+	} else if (file && *file == '/') {
+		ldirfd = -1;
+	} else {
+		ldirfd = sclib_file_get(&sclib_file, dirfd, SYSCALL_SYSID_LOCAL);
+		SCLIB_ERR_RET(ldirfd);
+	}
+	fd = sclib_file_add(&sclib_file, 0);
+	if (SCLIB_IS_ERR(fd)) {
+		lfd = fd;
+		goto fd_error;
+	}
+	lfd = SCLIB_LOCAL_CALL(openat, 4, ldirfd, file, oflag, mode);
+	if (SCLIB_IS_ERR(lfd)) {
+		sclib_file_add_fail(&sclib_file, fd);
+	} else {
+		uint8_t lfd_flags = 0;
+		if (oflag & O_CLOEXEC)
+			lfd_flags |= SCLIB_FD_EXEC;
+		sclib_file_add_ok(&sclib_file, fd, lfd, SYSCALL_SYSID_LOCAL, lfd_flags, 0);
+	}
+fd_error:
+	if (ldirfd >= 0)
+		sclib_file_put(&sclib_file, dirfd);
+	SCLIB_ERR_RET(lfd);
+	return fd;
+}
 libc_hidden_def(openat)
 #else
 /* should add emulation with open() and /proc/self/fd/ ... */
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/open.c uClibc-0.9.33-new/libc/sysdeps/linux/common/open.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/open.c	2013-09-23 20:39:08.178221833 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/open.c	2013-09-23 20:39:32.954222860 -0400
@@ -14,12 +14,12 @@
 #include <string.h>
 #include <sys/param.h>
 
-#define __NR___syscall_open __NR_open
-static __inline__ _syscall3(int, __syscall_open, const char *, file,
-		int, flags, __kernel_mode_t, mode)
+#include <bits/sclib.h>
+#include <bits/sclib_syscalls.h>
 
 int open(const char *file, int oflag, ...)
 {
+	long ret;
 	mode_t mode = 0;
 
 	if (oflag & O_CREAT) {
@@ -29,7 +29,9 @@
 		va_end(arg);
 	}
 
-	return __syscall_open(file, oflag, mode);
+	ret = __internal_sys_open(file, oflag, mode);
+	SCLIB_ERR_RET(ret);
+	return ret;
 }
 #ifndef __LINUXTHREADS_OLD__
 libc_hidden_def(open)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/pipe2.c uClibc-0.9.33-new/libc/sysdeps/linux/common/pipe2.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/pipe2.c	2013-09-23 20:39:08.222221835 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/pipe2.c	2013-09-23 20:39:32.954222860 -0400
@@ -3,6 +3,7 @@
  * pipe2() for uClibc
  *
  * Copyright (C) 2011 Bernhard Reutner-Fischer <uclibc@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -10,7 +11,45 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_pipe2
-_syscall2(int, pipe2, int *, filedes, int, flags)
+
+int pipe2(int *fd, int flags)
+{
+	long ret;
+	int lfd[2];
+
+	ret = sclib_file_add(&sclib_file, 0);
+	if (SCLIB_IS_ERR(ret))
+		goto lfd_err2;
+	fd[0] = ret;
+	ret = sclib_file_add(&sclib_file, 0);
+	if (SCLIB_IS_ERR(ret))
+		goto lfd_err1;
+	fd[1] = ret;
+	ret = SCLIB_LOCAL_CALL(pipe2, 2, lfd, flags);
+	if (SCLIB_IS_ERR(ret)) {
+		sclib_file_add_fail(&sclib_file, fd[1]);
+	} else {
+		uint8_t lfd_flags = 0;
+		if (flags & O_CLOEXEC)
+			lfd_flags |= SCLIB_FD_EXEC;
+		sclib_file_add_ok(&sclib_file, fd[1], lfd[1], SYSCALL_SYSID_LOCAL, lfd_flags, 0);
+	}
+lfd_err1:
+	if (SCLIB_IS_ERR(ret)) {
+		sclib_file_add_fail(&sclib_file, fd[0]);
+	} else {
+		uint8_t lfd_flags = 0;
+		if (flags & O_CLOEXEC)
+			lfd_flags |= SCLIB_FD_EXEC;
+		sclib_file_add_ok(&sclib_file, fd[0], lfd[0], SYSCALL_SYSID_LOCAL, lfd_flags, 0);
+	}
+lfd_err2:
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
+
 libc_hidden_def(pipe2)
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/pipe.c uClibc-0.9.33-new/libc/sysdeps/linux/common/pipe.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/pipe.c	2013-09-23 20:39:08.266221839 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/pipe.c	2013-09-23 20:39:32.954222860 -0400
@@ -3,6 +3,7 @@
  * pipe() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -10,6 +11,36 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
+#include <bits/sclib.h>
+
+int pipe(int *fd)
+{
+	long ret;
+	int lfd[2];
+
+	ret = sclib_file_add(&sclib_file, 0);
+	if (SCLIB_IS_ERR(ret))
+		goto lfd_err2;
+	fd[0] = ret;
+	ret = sclib_file_add(&sclib_file, 0);
+	if (SCLIB_IS_ERR(ret))
+		goto lfd_err1;
+	fd[1] = ret;
+	ret = SCLIB_LOCAL_CALL(pipe, 1, lfd);
+	if (SCLIB_IS_ERR(ret)) {
+		sclib_file_add_fail(&sclib_file, fd[1]);
+	} else {
+		sclib_file_add_ok(&sclib_file, fd[1], lfd[1], SYSCALL_SYSID_LOCAL, 0, 0);
+	}
+lfd_err1:
+	if (SCLIB_IS_ERR(ret)) {
+		sclib_file_add_fail(&sclib_file, fd[0]);
+	} else {
+		sclib_file_add_ok(&sclib_file, fd[0], lfd[0], SYSCALL_SYSID_LOCAL, 0, 0);
+	}
+lfd_err2:
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
-_syscall1(int, pipe, int *, filedes)
 libc_hidden_def(pipe)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/poll.c uClibc-0.9.33-new/libc/sysdeps/linux/common/poll.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/poll.c	2013-09-23 20:39:08.178221833 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/poll.c	2013-09-23 20:39:32.954222860 -0400
@@ -1,4 +1,5 @@
 /* Copyright (C) 1994,1996,1997,1998,1999,2001,2002
+   Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
    Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -21,6 +22,8 @@
 #include <sys/poll.h>
 #include <bits/kernel-features.h>
 
+#include <bits/sclib.h>
+
 #ifdef __UCLIBC_HAS_THREADS_NATIVE__
 #include <sysdep-cancel.h>
 #else
@@ -31,9 +34,185 @@
 
 #if defined __ASSUME_POLL_SYSCALL && defined __NR_poll
 
-#define __NR___syscall_poll __NR_poll
-static inline _syscall3(int, __syscall_poll, struct pollfd *, fds,
-			unsigned long int, nfds, int, timeout);
+#include <string.h>
+
+static inline void __syscall_poll_debug(struct pollfd *fds, unsigned long nfds, long num)
+{
+	char buf[256], *buf_ptr;
+    unsigned long i;
+
+	if (num != -4096) {
+		SCLIB_STRACE_DEBUG("POLL, return %li", num);
+	} else {
+		SCLIB_STRACE_DEBUG("POLL %lu", nfds);
+	}
+	buf_ptr = buf;
+	for (i = 0; i < nfds; i++) {
+		buf_ptr += sprintf(buf_ptr, "{FD=%i", fds[i].fd);
+		if (fds[i].events & POLLIN)
+			buf_ptr = stpcpy(buf_ptr, " I:IN");
+		if (fds[i].events & POLLOUT)
+			buf_ptr = stpcpy(buf_ptr, " I:OUT");
+		if (fds[i].events & POLLPRI)
+			buf_ptr = stpcpy(buf_ptr, " I:PRI");
+		if (fds[i].events & POLLRDHUP)
+			buf_ptr = stpcpy(buf_ptr, " I:RDHUP");
+		if (num == -4096) {
+			if (fds[i].revents & POLLIN)
+				buf_ptr = stpcpy(buf_ptr, " R:IN");
+			if (fds[i].revents & POLLOUT)
+				buf_ptr = stpcpy(buf_ptr, " R:OUT");
+			if (fds[i].revents & POLLERR)
+				buf_ptr = stpcpy(buf_ptr, " R:ERR");
+			if (fds[i].revents & POLLPRI)
+				buf_ptr = stpcpy(buf_ptr, " R:PRI");
+			if (fds[i].revents & POLLRDHUP)
+				buf_ptr = stpcpy(buf_ptr, " R:RDHUP");
+			if (fds[i].revents & POLLNVAL)
+				buf_ptr = stpcpy(buf_ptr, " R:NVAL");
+			if (fds[i].revents & POLLHUP)
+				buf_ptr = stpcpy(buf_ptr, " R:HUP");
+		}
+		buf_ptr = stpcpy(buf_ptr, "}");
+	}
+	SCLIB_LOCAL_CALL(write, 3, -1, buf, strlen(buf));
+}
+
+static inline long __syscall_poll(struct pollfd *fds, unsigned long nfds,
+	int timeout)
+{
+	struct pollfd loc_fds[1025];
+	struct pollfd *rem_fds[SYSCALL_SYSIDS], *cur_fds;
+	struct syscall_efd param;
+	unsigned long n, i, rem_num[SYSCALL_SYSIDS], cur_num, loc_num = 0;
+	long num, ret, dfd, dom_num;
+	int sysid;
+	syscall_entry_t *pos[SYSCALL_SYSIDS];
+
+	//__syscall_poll_debug(fds, nfds, -4096);
+	if (unlikely((unsigned int) nfds > 1024)) {
+		num = -EINVAL;
+		goto error;
+	}
+
+	memset(rem_fds, 0, sizeof(rem_fds));
+	dom_num = 0;
+	for (n = 0; n < nfds; n++) {
+		dfd = sclib_file_getid(&sclib_file, fds[n].fd, &sysid);
+		if (dfd < 0) {
+			fds[n].revents = POLLNVAL;
+		} else {
+			fds[n].revents = 0;
+			if (sysid != SYSCALL_SYSID_LOCAL) {
+				cur_fds = rem_fds[sysid];
+				if (cur_fds == NULL) {
+					cur_fds = sclib_memory_alloc(&sclib_data[sysid],
+						sizeof(struct pollfd) * (nfds + 1));
+					SCLIB_MEM_RET(cur_fds, num);
+					rem_fds[sysid] = cur_fds;
+					rem_num[sysid] = 0;
+					dom_num++;
+				}
+				cur_num = rem_num[sysid];
+				cur_fds[cur_num].fd = dfd;
+				cur_fds[cur_num].events = fds[n].events;
+				cur_fds[cur_num++].revents = 0; /* Just in case */
+				rem_num[sysid] = cur_num;
+			} else {
+				loc_fds[loc_num].fd = dfd;
+				loc_fds[loc_num].events = fds[n].events;
+				loc_fds[loc_num++].revents = 0; /* Just in case */
+			}
+		}
+	}
+	dom_num += (loc_num != 0);
+
+	for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+		cur_num = rem_num[sysid];
+		cur_fds = rem_fds[sysid];
+		if (cur_fds) {
+			long efd_packed;
+			if (dom_num > 1) {
+				efd_packed = sclib_thread.efd[sysid];
+				cur_fds[cur_num].fd = efd_packed;
+				cur_fds[cur_num].events = POLLIN;
+				cur_fds[cur_num++].revents = 0;
+				rem_num[sysid] = cur_num;
+				efd_packed |= sclib_thread.efd[SYSCALL_SYSIDS] << 10;
+			} else {
+				efd_packed = 0xFFFFF;
+			}
+			efd_packed |= (cur_num << 20);
+			pos[sysid] = SCLIB_REMOTE_CALL_ASYNC(sysid, syscall_service_poll, 3,
+							sclib_mem(sysid, cur_fds), efd_packed, timeout);
+		}
+	}
+
+	ret = 0;
+	if (dom_num != 1 || loc_num != 0) {
+		long efd;
+		if (dom_num > 1) {
+			efd = sclib_thread.efd[SYSCALL_SYSIDS];
+			param.efd[SYSCALL_SYSIDS] = efd;
+			loc_fds[loc_num].fd = efd;
+			loc_fds[loc_num].events = POLLIN;
+			loc_fds[loc_num++].revents = 0;
+			param.efd_num = -1;
+			for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++)
+				param.efd[sysid] = rem_fds[sysid] ? sclib_thread.efd[sysid] : -1;
+		} else {
+			param.efd_num = 0;
+			efd = -1;
+		}
+		param.n = loc_num;
+		ret = SCLIB_LOCAL_CALL(syscall_service_poll, 3, loc_fds, &param,
+			timeout);
+		if (likely(ret != -EFAULT))
+			sclib_wait_efd(&param, efd);
+	}
+
+	/* Get result from the remote domain */
+	for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+		if (!rem_fds[sysid])
+			continue;
+		num = SCLIB_REMOTE_CALL_RESULT(sysid, syscall_service_poll, pos[sysid]);
+		if (SCLIB_IS_ERR(num))
+			ret = num;
+	}
+
+	SCLIB_VAL_RET(ret, num);
+
+	memset(rem_num, 0, sizeof(rem_num));
+	loc_num = 0;
+	num = 0;
+	for (i = 0; i < n; i++) {
+		if (fds[i].revents == 0) {
+			dfd = sclib_file_touch(&sclib_file, fds[i].fd, &sysid);
+			if (sysid != SYSCALL_SYSID_LOCAL) {
+				fds[i].revents = rem_fds[sysid][rem_num[sysid]++].revents;
+			} else {
+				fds[i].revents = loc_fds[loc_num++].revents;
+			}
+		} else if (fds[i].fd < 0) { /* If (fd < 0), we have to set it to 0. */
+			fds[i].revents = 0;
+		}
+		num += (fds[i].revents != 0);
+	}
+
+error_val:
+error_mem:
+	for (i = 0; i < n; i++)
+		sclib_file_put(&sclib_file, fds[i].fd);
+	for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+		cur_fds = rem_fds[sysid];
+		if (cur_fds != NULL)
+			sclib_memory_free(&sclib_data[sysid], cur_fds);
+	}
+error:
+//__syscall_poll_debug(fds, nfds, num);
+	SCLIB_ERR_RET(num);
+	return num;
+}
 
 int poll(struct pollfd *fds, nfds_t nfds, int timeout)
 {
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/posix_fadvise64.c uClibc-0.9.33-new/libc/sysdeps/linux/common/posix_fadvise64.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/posix_fadvise64.c	2013-09-23 20:39:08.218221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/posix_fadvise64.c	2013-09-23 20:39:32.954222860 -0400
@@ -27,16 +27,17 @@
 
 int posix_fadvise64(int fd, __off64_t offset, __off64_t len, int advice)
 {
-  if (len != (off_t) len)
-    return EOVERFLOW;
-  INTERNAL_SYSCALL_DECL (err);
-    int ret = INTERNAL_SYSCALL (posix_fadvise64, err, 5, fd,
-                               __LONG_LONG_PAIR ((long) (offset >> 32),
-                                                 (long) offset),
-                               (off_t) len, advice);
-  if (!INTERNAL_SYSCALL_ERROR_P (ret, err))
-    return 0;
-  return INTERNAL_SYSCALL_ERRNO (ret, err);
+	int sysid;
+	long err, dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	if (len != (off_t) len)
+		return EOVERFLOW;
+
+	SCLIB_ERR_RET(dfd);
+	err = SCLIB_SYSID_CALL(sysid, posix_fadvise64, 5, dfd, __LONG_LONG_PAIR((long) (offset >> 32), (long) offset), (off_t) len, advice);
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(err);
+	return err;
 }
 
 /* 32 bit implementation is kind of a pita */
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/posix_fadvise.c uClibc-0.9.33-new/libc/sysdeps/linux/common/posix_fadvise.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/posix_fadvise.c	2013-09-23 20:39:08.222221835 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/posix_fadvise.c	2013-09-23 20:39:32.954222860 -0400
@@ -11,16 +11,20 @@
 #include <sys/syscall.h>
 #include <fcntl.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_fadvise64
 #define __NR_posix_fadvise __NR_fadvise64
 int posix_fadvise(int fd, off_t offset, off_t len, int advice)
 {
-	INTERNAL_SYSCALL_DECL(err);
-	int ret = (int) (INTERNAL_SYSCALL(posix_fadvise, err, 5, fd,
-	 __LONG_LONG_PAIR (offset >> 31, offset), len, advice));
-    if (INTERNAL_SYSCALL_ERROR_P (ret, err))
-      return INTERNAL_SYSCALL_ERRNO (ret, err);
-    return 0;
+	int sysid;
+	long err, dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	SCLIB_ERR_RET(dfd);
+	err = SCLIB_SYSID_CALL(sysid, posix_fadvise, 5, dfd, __LONG_LONG_PAIR(offset >> 31, offset), len, advice);
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(err);
+	return err;
 }
 
 #if defined __UCLIBC_HAS_LFS__ && !defined __NR_fadvise64_64
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/ppoll.c uClibc-0.9.33-new/libc/sysdeps/linux/common/ppoll.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/ppoll.c	2013-09-23 20:39:08.222221835 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/ppoll.c	2013-09-23 20:39:32.954222860 -0400
@@ -23,33 +23,65 @@
 #define __need_NULL
 #include <stddef.h>
 
-#if defined __NR_ppoll && defined __UCLIBC_LINUX_SPECIFIC__
+#if defined __ASSUME_POLL_SYSCALL && defined __NR_poll
 # ifdef __UCLIBC_HAS_THREADS_NATIVE__
 #  include <sysdep-cancel.h>
 # else
 #  define SINGLE_THREAD_P 1
 # endif
 
-int
-ppoll(struct pollfd *fds, nfds_t nfds, const struct timespec *timeout,
+#ifdef __UCLIBC_HAS_THREADS_NATIVE__
+static int __ppoll
+#else
+int ppoll
+#endif
+	(struct pollfd *fds, nfds_t nfds, const struct timespec *timeout,
        const sigset_t *sigmask)
 {
-	/* The Linux kernel can in some situations update the timeout value.
-	   We do not want that so use a local variable.  */
-	struct timespec tval;
-	if (timeout != NULL) {
-		tval = *timeout;
-		timeout = &tval;
-	}
-  if (SINGLE_THREAD_P)
-		return INLINE_SYSCALL(ppoll, 5, fds, nfds, timeout, sigmask, _NSIG / 8);
+  struct timeval tval;
+  int retval;
+  sigset_t savemask;
+
+  /* Change nanosecond number to microseconds.  This might mean losing
+     precision and therefore the `ppoll` should be available.  But
+     for now it is hardly found.  */
+  if (timeout != NULL)
+    TIMESPEC_TO_TIMEVAL (&tval, timeout);
+
+  /* The setting and restoring of the signal mask and the poll call
+     should be an atomic operation.  This can't be done without kernel
+     help.  */
+  if (sigmask != NULL)
+    sigprocmask (SIG_SETMASK, sigmask, &savemask);
+
+  /* Note the ppoll() is a cancellation point.  But since we call
+     poll() which itself is a cancellation point we do not have
+     to do anything here.  */
+  retval = poll (fds, nfds, timeout != NULL ? &tval : NULL);
+
+  if (sigmask != NULL)
+    sigprocmask (SIG_SETMASK, &savemask, NULL);
+
+  return retval;
+}
+
+#ifdef __UCLIBC_HAS_THREADS_NATIVE__
+int
+ppoll (struct pollfd *fds, nfds_t nfds, const struct timespec *timeout,
+		const sigset_t *sigmask)
+{
+	if (SINGLE_THREAD_P)
+		return __ppoll (fds, nfds, timeout, sigmask);
 
-# ifdef __UCLIBC_HAS_THREADS_NATIVE__
 	int oldtype = LIBC_CANCEL_ASYNC ();
-	int result = INLINE_SYSCALL(ppoll, 5, fds, nfds, timeout, sigmask, _NSIG / 8);
+
+	int result = __ppoll (fds, nfds, timeout, sigmask);
+
 	LIBC_CANCEL_RESET (oldtype);
+
 	return result;
-# endif
 }
+#endif
+
 libc_hidden_def(ppoll)
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/prctl.c uClibc-0.9.33-new/libc/sysdeps/linux/common/prctl.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/prctl.c	2013-09-23 20:39:08.266221839 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/prctl.c	2013-09-23 20:39:32.954222860 -0400
@@ -9,9 +9,25 @@
 
 #include <sys/syscall.h>
 #include <stdarg.h>
+#include <linux/prctl.h>
+#include <bits/sclib.h>
+
 /* psm: including sys/prctl.h would depend on kernel headers */
 
 #ifdef __NR_prctl
 extern int prctl (int, long, long, long, long);
-_syscall5(int, prctl, int, option, long, _a2, long, _a3, long, _a4, long, _a5)
+
+int prctl(int option, long _a2, long _a3, long _a4, long _a5)
+{
+	long ret;
+
+	if (option == PR_CAPBSET_DROP) {
+		ret = SCLIB_ALL_SIMPLE_CALL(prctl, 2, option, _a2);
+	} else {
+		ret = SCLIB_LOCAL_CALL(prctl, 5, option, _a2, _a3, _a4, _a5);
+	}
+	SCLIB_ERR_RET(ret);
+
+	return ret;
+}
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/read.c uClibc-0.9.33-new/libc/sysdeps/linux/common/read.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/read.c	2013-09-23 20:39:08.226221836 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/read.c	2013-09-23 20:39:32.954222860 -0400
@@ -2,6 +2,7 @@
 /*
  * read() for uClibc
  *
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
@@ -9,8 +10,18 @@
 
 #include <sys/syscall.h>
 #include <unistd.h>
+#include <string.h>
+
+#include <bits/sclib.h>
+#include <bits/sclib_syscalls.h>
+
+ssize_t read(int fd, void *buf, size_t count)
+{
+	ssize_t ret = __internal_sys_read(fd, buf, count);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
-_syscall3(ssize_t, read, int, fd, __ptr_t, buf, size_t, count)
 #ifndef __LINUXTHREADS_OLD__
 libc_hidden_def(read)
 #else
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/readlinkat.c uClibc-0.9.33-new/libc/sysdeps/linux/common/readlinkat.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/readlinkat.c	2013-09-23 20:39:08.182221833 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/readlinkat.c	2013-09-23 20:39:32.954222860 -0400
@@ -2,6 +2,7 @@
  * readlinkat() for uClibc
  *
  * Copyright (C) 2009 Analog Devices Inc.
+ * Copyright (C) 2012-2013 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -9,8 +10,49 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_readlinkat
-_syscall4(ssize_t, readlinkat, int, fd, const char *, path, char *, buf, size_t, len)
+ssize_t readlinkat(int fd, const char *path, char *buf, size_t bufsize)
+{
+	const char *__dpath = (const char *) path;
+	char __abspath[PATH_MAX];
+	void *__rbuf = __rbuf, *__off;
+	size_t __sz2;
+	int __sysid;
+	long __ret, __dfd;
+	
+	if (fd == AT_FDCWD) {
+		__dpath = sclib_get_path(__abspath, __dpath ? __dpath : "", &__sysid, &__sz2);
+		__dfd = -1;
+	} else if (__dpath && *__dpath == '/') {
+		__dpath = sclib_get_path(__abspath, __dpath, &__sysid, &__sz2);
+		__dfd = -1;
+	} else {
+		__sz2 = __dpath ? (strlen(__dpath) + 1) : 0;
+		__dfd = sclib_file_getid(&sclib_file, fd, &__sysid);
+		SCLIB_ERR_RET(__dfd);
+	}
+	if (__sysid != SYSCALL_SYSID_LOCAL) {
+		if (bufsize > PATH_MAX)
+			bufsize = PATH_MAX;
+		__rbuf = sclib_memory_alloc(&sclib_data[__sysid], bufsize + __sz2);
+		SCLIB_MEM_RET(__rbuf, __ret);
+		memcpy(__rbuf + bufsize, __dpath, __sz2);
+		__off = sclib_mem(__sysid, __rbuf);
+		__ret = SCLIB_REMOTE_CALL(__sysid, readlinkat, 4, __dfd, __sz2 ? (__off + bufsize) : NULL, __off, bufsize);
+		if (!SCLIB_IS_ERR(__ret))
+			memcpy(buf, __rbuf, __ret);
+		sclib_memory_free(&sclib_data[__sysid], __rbuf);
+	} else {
+		__ret = SCLIB_LOCAL_CALL(readlinkat, 4, __dfd, __dpath, buf, bufsize);
+	}
+error_mem:
+	if (__dfd >= 0)
+		sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(__ret);
+	return __ret;
+}
 #else
 /* should add emulation with readlink() and /proc/self/fd/ ... */
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/readlink.c uClibc-0.9.33-new/libc/sysdeps/linux/common/readlink.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/readlink.c	2013-09-23 20:39:08.170221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/readlink.c	2013-09-23 20:39:32.954222860 -0400
@@ -3,6 +3,7 @@
  * readlink() for uClibc
  *
  * Copyright (C) 2000-2007 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -10,5 +11,34 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
-_syscall3(ssize_t, readlink, const char *, path, char *, buf, size_t, bufsiz)
+#include <bits/sclib.h>
+
+ssize_t readlink(const char *path, char *buf, size_t bufsize)
+{
+	char __abspath[PATH_MAX], *__dpath;
+	long __ret;
+	int __sysid;
+	void *__rbuf, *__off;
+	size_t __sz2;
+
+	__dpath = sclib_get_path(__abspath, path, &__sysid, &__sz2);
+	if (__sysid != SYSCALL_SYSID_LOCAL) {
+		if (bufsize > PATH_MAX)
+			bufsize = PATH_MAX;
+		__rbuf = sclib_memory_alloc(&sclib_data[__sysid], bufsize + __sz2);
+		SCLIB_MEM_RET(__rbuf, __ret);
+		memcpy(__rbuf + bufsize, __dpath, __sz2);
+		__off = sclib_mem(__sysid, __rbuf);
+		__ret = SCLIB_REMOTE_CALL(__sysid, readlink, 3, __off + bufsize, __off, bufsize);
+		if (!SCLIB_IS_ERR(__ret))
+			memcpy(buf, __rbuf, __ret);
+		sclib_memory_free(&sclib_data[__sysid], __rbuf);
+	} else {
+		__ret = SCLIB_LOCAL_CALL(readlink, 3, __dpath, buf, bufsize);
+	}
+error_mem:
+	SCLIB_ERR_RET(__ret);
+	return __ret;
+}
+
 libc_hidden_def(readlink)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/readv.c uClibc-0.9.33-new/libc/sysdeps/linux/common/readv.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/readv.c	2013-09-23 20:39:08.278221837 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/readv.c	2013-09-23 20:39:32.954222860 -0400
@@ -2,6 +2,7 @@
 /*
  * readv() for uClibc
  *
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  * Copyright (C) 2006 by Steven J. Hill <sjhill@realitydiluted.com>
  * Copyright (C) 2000-2004 by Erik Andersen <andersen@codepoet.org>
  *
@@ -11,6 +12,55 @@
 #include <sys/syscall.h>
 #include <sys/uio.h>
 
+#include <bits/sclib.h>
+
+static __inline__ ssize_t __syscall_readv(int fd, const struct iovec *iov, int iovcnt)
+{
+	int sysid;
+	size_t size;
+	long dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	SCLIB_ERR_RET(dfd);
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		struct sclib_iovc iovc;
+		size_t ret, chunk, count = sclib_iovec_length(iov, iovcnt);
+		void *rbuf, *mem;
+
+		SCLIB_VAL2_RET(count, size);
+		chunk = MIN(count, SCLIB_MAX_BUFFER);
+		mem = sclib_memory_alloc(&sclib_data[sysid], chunk);
+		SCLIB_MEM_RET(mem, size);
+		size = 0;
+		iovc.iovc_iov = iov;
+		iovc.iovc_off = 0;
+		rbuf = sclib_mem(sysid, mem);
+
+		for (; count > chunk; count -= chunk) {
+			ret = SCLIB_REMOTE_CALL(sysid, read, 3, dfd, rbuf, chunk);
+			SCLIB_VAL_RET(ret, size);
+			size += ret;
+			sclib_copy_to_iovec(&iovc, mem, ret);
+			if (unlikely(ret < chunk))
+				goto error_val;
+		}
+		ret = SCLIB_REMOTE_CALL(sysid, read, 3, dfd, rbuf, count);
+		SCLIB_VAL_RET(ret, size);
+		size += ret;
+		sclib_copy_to_iovec(&iovc, mem, ret);
+
+error_val:
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		size = SCLIB_LOCAL_CALL(readv, 3, dfd, iov, iovcnt);
+	}
+
+error_val2:
+error_mem:
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(size);
+	return size;
+}
+
 #ifdef __UCLIBC_HAS_THREADS_NATIVE__
 #include <sysdep-cancel.h>
 
@@ -20,7 +70,7 @@
 {
   ssize_t bytes_read;
 
-  bytes_read = INLINE_SYSCALL (readv, 3, fd, vector, count);
+  bytes_read = __syscall_readv (fd, vector, count);
 
   if (bytes_read >= 0 || errno != EINVAL || count <= UIO_FASTIOV)
     return bytes_read;
@@ -45,6 +95,8 @@
   return result;
 }
 #else
-_syscall3(ssize_t, readv, int, filedes, const struct iovec *, vector,
-		  int, count)
+ssize_t readv (int fd, const struct iovec *vector, int count)
+{
+	return __syscall_readv (fd, vector, count);
+}
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/renameat.c uClibc-0.9.33-new/libc/sysdeps/linux/common/renameat.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/renameat.c	2013-09-23 20:39:08.266221839 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/renameat.c	2013-09-23 20:39:32.958222861 -0400
@@ -9,8 +9,13 @@
 #include <sys/syscall.h>
 #include <stdio.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_renameat
-_syscall4(int, renameat, int, oldfd, const char *, old, int, newfd, const char *, new)
+int renameat(int oldfd, const char *old, int newfd, const char *new)
+{
+	return SCLIB_DFD_SYSCALL_AT2(renameat, 4, oldfd, old, newfd, new);
+}
 #else
 /* should add emulation with rename() and /proc/self/fd/ ... */
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/rename.c uClibc-0.9.33-new/libc/sysdeps/linux/common/rename.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/rename.c	2013-09-23 20:39:08.182221833 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/rename.c	2013-09-23 20:39:32.958222861 -0400
@@ -13,12 +13,10 @@
 #include <sys/param.h>
 #include <stdio.h>
 
-#define __NR___syscall_rename __NR_rename
-static __inline__ _syscall2(int, __syscall_rename, const char *, oldpath,
-		const char *, newpath)
+#include <bits/sclib.h>
 
 int rename(const char * oldpath, const char * newpath)
 {
-	return __syscall_rename(oldpath, newpath);
+	return SCLIB_PATH_CALL2(rename, 2, oldpath, newpath);
 }
 
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/rmdir.c uClibc-0.9.33-new/libc/sysdeps/linux/common/rmdir.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/rmdir.c	2013-09-23 20:39:08.218221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/rmdir.c	2013-09-23 20:39:32.958222861 -0400
@@ -10,6 +10,11 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
+#include <bits/sclib.h>
+
+int rmdir(const char *pathname)
+{
+	return SCLIB_PATH_CALL(rmdir, 1, pathname);
+}
 
-_syscall1(int, rmdir, const char *, pathname)
 libc_hidden_def(rmdir)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/sclib.c uClibc-0.9.33-new/libc/sysdeps/linux/common/sclib.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/sclib.c	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/sclib.c	2013-09-23 20:39:32.958222861 -0400
@@ -0,0 +1,775 @@
+/**
+ * VM-Syscalls
+ * Copyright (c) 2012 Ruslan Nikolaev <rnikola@vt.edu>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/param.h>
+#include <sys/mman.h>
+#include <sys/syscall.h>
+#include <sys/eventfd.h>
+#include <string.h>
+#include <sched.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <dirent.h>
+#include <endian.h>
+#include <features.h>
+#include <bits/sclib.h>
+
+struct linux_dirent
+{
+	long int d_ino;
+	__kernel_off_t d_off;
+	unsigned short int d_reclen;
+	char d_name[0];
+};
+
+static const char *sclib_paths[SYSCALL_SYSIDS] = { "/dev/syscall_network",
+	"/dev/syscall_storage" };
+
+sclib_data_t sclib_data[SYSCALL_SYSIDS] = { { .sysid = 0, .buffer = NULL }, { .sysid = 1, .buffer = NULL } };
+libc_hidden_data_def(sclib_data)
+
+sclib_miscdata_t sclib_miscdata[SYSCALL_SYSIDS] = { [ 0 ... SYSCALL_SYSIDS-1] = {.domfd = -1, .membase = 0 } };
+libc_hidden_data_def(sclib_miscdata)
+
+sclib_file_table_t sclib_file = { };
+libc_hidden_data_def(sclib_file)
+
+struct syscall_queue *sclib_rqueue = NULL;
+libc_hidden_data_def(sclib_rqueue);
+
+size_t sclib_wait_iterations = SCLIB_WAIT_ITERATIONS;
+libc_hidden_data_def(sclib_wait_iterations);
+
+#ifdef __UCLIBC_HAS_TLS__
+__thread sclib_thread_data_t sclib_thread = { .efd = { -1, -1 } };
+# ifdef SCLIB_MEMORY_PREALLOC
+__thread sclib_memory_block_t *sclib_memptr[SYSCALL_SYSIDS] = { NULL, NULL };
+# endif
+#else
+# error "Need TLS support for EFDS"
+#endif
+
+long sclib_fd_open(void)
+{
+	long sysid;
+
+	for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+		sclib_miscdata[sysid].domfd = SCLIB_LOCAL_CALL(open, 2, sclib_paths[sysid], O_RDWR);
+		if (sclib_miscdata[sysid].domfd < 0)
+			goto error;
+	}
+	return 0;
+
+error:
+	fprintf(stderr, "ERROR: Cannot open %s\n", sclib_paths[sysid]);
+	while (sysid != 0) {
+		--sysid;
+		SCLIB_LOCAL_CALL(close, 1, sclib_miscdata[sysid].domfd);
+	}
+	return -EFAULT;
+}
+
+libc_hidden_def(sclib_fd_open)
+
+void sclib_fd_close(void)
+{
+	long sysid;
+
+	for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+		SCLIB_LOCAL_CALL(close, 1, sclib_miscdata[sysid].domfd);
+	}
+}
+
+libc_hidden_def(sclib_fd_close)
+
+char *sclib_get_path(char *abspath, const char *path, int *sysid, size_t *sz)
+{
+	char *curpath, *endpath = abspath + PATH_MAX;
+
+	if (*path == '/') { /* Absolute path */
+		do {
+			path++;
+		} while (*path == '/');
+		curpath = abspath;
+	} else { /* Relative path */
+		curpath = mempcpy(abspath, sclib_file.curdir, sclib_file.curdir_size - 1);
+	}
+
+	*curpath = '/';
+	while (*path != '\0') {
+		if (*path == '.') {
+			path++;
+			if (*path == '.') {
+				path++;
+				if (*path == '/') { /* Parent directory */
+					if (curpath != abspath) {
+						do {
+							curpath--;
+						} while (*curpath != '/');
+					}
+					goto next_iteration;
+				} else if (*path == '\0') { /* Parent directory (end) */
+					if (curpath != abspath) {
+						do {
+							curpath--;
+						} while (*curpath != '/');
+					}
+					goto exit_iterations;
+				}
+				path -= 2;
+			} else if (*path == '/') { /* Current directory */
+				goto next_iteration;
+			} else if (*path == '\0') { /* Current directory (end) */
+				goto exit_iterations;
+			} else { /* Ordinary file */
+				path--;
+			}
+		}
+
+		while (*path != '/') {
+			if (*path == '\0')
+				goto exit_iterations;
+			if (++curpath == endpath)
+				goto exit;
+			*curpath = *path++;
+		}
+		if (++curpath == endpath)
+			goto exit;
+		*curpath = '/';
+
+next_iteration:
+		do {
+			path++;
+		} while (*path == '/');
+	}
+
+exit_iterations:
+	if (++curpath != endpath)
+		*curpath = '\0';
+
+exit:
+	if (strncmp(abspath, SCLIB_STORAGE_PREFIX, sizeof(SCLIB_STORAGE_PREFIX) - 1) == 0)
+	{
+		if (abspath[sizeof(SCLIB_STORAGE_PREFIX) - 1] == '\0') {
+			abspath[sizeof(SCLIB_STORAGE_PREFIX) - 1] = '/';
+			abspath[sizeof(SCLIB_STORAGE_PREFIX)] = '\0';
+			*sysid = SYSCALL_SYSID_STORAGE;
+			abspath += sizeof(SCLIB_STORAGE_PREFIX) - 1;
+			curpath = abspath + 1;
+			goto done;
+		} else if (abspath[sizeof(SCLIB_STORAGE_PREFIX) - 1] == '/') {
+			*sysid = SYSCALL_SYSID_STORAGE;
+			abspath += sizeof(SCLIB_STORAGE_PREFIX) - 1;
+			goto done;
+		}
+	}
+	*sysid = SYSCALL_SYSID_LOCAL;
+
+done:
+	*sz = (size_t) (curpath + 1 - abspath);
+	if (*sz == 1) {
+		*sz = 2;
+		abspath[0] = '.';
+		abspath[1] = '\0';
+	}
+	return abspath;
+}
+
+libc_hidden_def(sclib_get_path)
+
+long sclib_efds_open(bool new_process)
+{
+	syscall_udw_t dwret;
+	long ret;
+	size_t sysid;
+	syscall_entry_t *pos[SYSCALL_SYSIDS];
+
+	for (sysid = 0; sysid < SYSCALL_SYSIDS+1; sysid++)
+		sclib_thread.efd[sysid] = -1;
+	/* Get task ID prior to any remote calls */
+	ret = SCLIB_LOCAL_CALL(gettid, 0);
+	if (SCLIB_IS_ERR(ret))
+		goto error;
+	sclib_thread.task_id = ret;
+	if (new_process) {
+		/* Request is already on the stack */
+		sclib_thread.seq_num = 1;
+		for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+			pos[sysid] = (syscall_entry_t *) sclib_data[sysid].buffer->page.entry;
+			pos[sysid]->pd = THREAD_SELF;
+		}
+	} else {
+		/* Create new remote eventfd */
+		sclib_thread.seq_num = 0;
+		for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++)
+			pos[sysid] = SCLIB_REMOTE_CALL_ASYNC(sysid, syscall_service_init, 1, -1);
+	}
+	/* Initialize local FD */
+	ret = SCLIB_LOCAL_CALL(eventfd2, 2, 0, EFD_SEMAPHORE);
+	sclib_thread.efd[SYSCALL_SYSIDS] = ret;
+	/* Wait for remote result */
+	for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+		dwret = SCLIB_REMOTE_CALL_RESULT_DW(sysid, syscall_service_init, pos[sysid]);
+		sclib_thread.efd[sysid] = syscall_result_lower(dwret);
+		ret |= sclib_thread.efd[sysid];
+		if (new_process)
+			sclib_miscdata[sysid].membase = syscall_result_upper(dwret);
+	}
+
+	if (likely(ret >= 0))
+		return 0;
+
+	for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+		if (sclib_thread.efd[sysid] >= 0) {
+			pos[sysid] = SCLIB_REMOTE_CALL_ASYNC(sysid, close, 1, sclib_thread.efd[sysid]);
+			sclib_thread.efd[sysid] = -1;
+		} else {
+			pos[sysid] = NULL;
+		}
+	}
+	if (sclib_thread.efd[SYSCALL_SYSIDS] >= 0) {
+		SCLIB_LOCAL_CALL(close, 1, sclib_thread.efd[SYSCALL_SYSIDS]);
+		sclib_thread.efd[SYSCALL_SYSIDS] = -1;
+	}
+	for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+		if (pos[sysid])
+			SCLIB_REMOTE_CALL_RESULT(sysid, close, pos[sysid]);
+	}
+
+error:
+	return -EFAULT;
+}
+
+libc_hidden_def(sclib_efds_open)
+
+void sclib_efds_close(void)
+{
+	size_t sysid;
+	syscall_entry_t *pos[SYSCALL_SYSIDS];
+
+	for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+		if (sclib_thread.efd[sysid] >= 0) {
+			pos[sysid] = SCLIB_REMOTE_CALL_ASYNC(sysid, close, 1, sclib_thread.efd[sysid]);
+			sclib_thread.efd[sysid] = -1;
+		} else {
+			pos[sysid] = NULL;
+		}
+	}
+	if (sclib_thread.efd[SYSCALL_SYSIDS] >= 0) {
+		SCLIB_LOCAL_CALL(close, 1, sclib_thread.efd[SYSCALL_SYSIDS]);
+		sclib_thread.efd[SYSCALL_SYSIDS] = -1;
+	}
+	for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+		if (pos[sysid])
+			SCLIB_REMOTE_CALL_RESULT(sysid, close, pos[sysid]);
+	}
+}
+
+libc_hidden_def(sclib_efds_close)
+
+static long sclib_fds_init(sclib_file_table_t *file)
+{
+	long dirents[1024 / sizeof(long)]; /* Long is used for alignment */
+	struct linux_dirent *ent;
+	int dir, fd, size;
+	long ret, rc = -EFAULT;
+
+	sclib_file_init(file);
+	ret = SCLIB_LOCAL_CALL(getcwd, 2, file->curdir, PATH_MAX);
+	if (unlikely(ret < 0))
+		return rc;
+	file->curdir_size = ret;
+	dir = SCLIB_LOCAL_CALL(open, 3, "/proc/self/fd", O_RDONLY, 0);
+	if (unlikely(dir < 0))
+		return rc;
+	size = SCLIB_LOCAL_CALL(getdents, 3, dir, dirents, sizeof(dirents));
+	if (unlikely(size < 0))
+		goto done;
+	ent = (struct linux_dirent *) dirents;
+	while (size > 0) {
+		if (ent->d_name[0] != '.') { /* Skip current and parent dirs */
+			if (sscanf(ent->d_name, "%d", &fd) != 1)
+				goto done;
+			if (fd != dir) /* Do not add /proc/self/fd itself */
+				sclib_file_replace(file, fd, fd, SYSCALL_SYSID_LOCAL, NULL);
+		}
+		size -= ent->d_reclen;
+		ent = (struct linux_dirent *) ((char *) ent + ent->d_reclen);
+	}
+	rc = 0;
+
+done:
+	SCLIB_LOCAL_CALL(close, 1, dir);
+
+	if (!rc)
+		return sclib_fd_open();
+
+	return rc;
+}
+
+static long sclib_fds_restore(void)
+{
+	char path[sizeof(SYSCALL_FDTABLE_PATH) + 64];
+	struct iovec iov[3];
+	int fd;
+	long rc = 0;
+
+	sprintf(path, SYSCALL_FDTABLE_PATH "%u", getpid());
+	fd = SCLIB_LOCAL_CALL(open, 3, path, O_RDONLY, 0);
+	if (unlikely(fd < 0))
+		return -EFAULT;
+	iov[0].iov_base = &sclib_file;
+	iov[0].iov_len = sizeof(sclib_file_table_t);
+	iov[1].iov_base = sclib_miscdata;
+	iov[1].iov_len = sizeof(sclib_miscdata);
+	iov[2].iov_base = &sclib_thread;
+	iov[2].iov_len = sizeof(sclib_thread_data_t);
+	if (unlikely(SCLIB_LOCAL_CALL(readv, 3, fd, iov, 3) != sizeof(sclib_file_table_t) + sizeof(sclib_miscdata) + sizeof(sclib_thread_data_t))) {
+		rc = -EFAULT;
+	}
+	SCLIB_LOCAL_CALL(close, 1, fd);
+	SCLIB_LOCAL_CALL(unlink, 1, path);
+	return rc;
+}
+
+long sclib_fds_save(void)
+{
+	char path[sizeof(SYSCALL_FDTABLE_PATH) + 64];
+	struct iovec iov[3];
+	int fd;
+	long rc = 0;
+
+	sprintf(path, SYSCALL_FDTABLE_PATH "%u", getpid());
+	fd = SCLIB_LOCAL_CALL(open, 3, path, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR);
+	if (unlikely(fd < 0)) {
+		return -EFAULT;
+	}
+	iov[0].iov_base = &sclib_file;
+	iov[0].iov_len = sizeof(sclib_file_table_t);
+	iov[1].iov_base = sclib_miscdata;
+	iov[1].iov_len = sizeof(sclib_miscdata);
+	iov[2].iov_base = &sclib_thread;
+	iov[2].iov_len = sizeof(sclib_thread_data_t);
+	if (unlikely(SCLIB_LOCAL_CALL(writev, 3, fd, iov, 3) != sizeof(sclib_file_table_t) + sizeof(sclib_miscdata) + sizeof(sclib_thread_data_t))) {
+		rc = -EFAULT;
+	}
+	SCLIB_LOCAL_CALL(close, 1, fd);
+	return rc;
+}
+
+libc_hidden_def(sclib_fds_save)
+
+long sclib_fd_mmap(void)
+{
+	size_t sysid;
+	long ret;
+
+	/* No error handling since process exits if sclib_fd_mmap() fails */
+	for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+		ret = SCLIB_LOCAL_CALL(ioctl, 3, sclib_miscdata[sysid].domfd, SYSCALL_DRIVER_IOCTL_REGISTER, 0);
+		if (SCLIB_IS_ERR(ret)) {
+			fprintf(stderr, "ERROR: Cannot register with %s\n", sclib_paths[sysid]);
+			return -EFAULT;
+		}
+		sclib_data[sysid].map_pos = (unsigned long) ret - SYSCALL_PAGES;
+		ret = SCLIB_LOCAL_CALL(mmap, 6, NULL, SYSCALL_TOTAL_SHARED_PAGES * PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, sclib_miscdata[sysid].domfd, 0);
+		if (SCLIB_IS_ERR(ret)) {
+			fprintf(stderr, "ERROR: Cannot map a syscall shared buffer\n");
+			return -EFAULT;
+		}
+		sclib_data[sysid].buffer = (void *) ret;
+	}
+
+	return 0;
+}
+
+libc_hidden_def(sclib_fd_mmap)
+
+void sclib_init(void)
+{
+	bool new_process = false;
+	long ret;
+	unsigned long num;
+	const char *str;
+	size_t sysid;
+
+	/* Number of iterations. */
+	str = getenv("SCLIB_WAIT_ITERATIONS");
+	if (str != NULL) {
+		errno = 0;
+		num = strtol(str, NULL, 10);
+		if ((num != 0 && num < ULONG_MAX) || !errno)
+			sclib_wait_iterations = num;
+	}
+	/* Initialize file descriptors first. */
+	if (sclib_fds_restore() != 0) {
+		if (sclib_fds_init(&sclib_file) != 0)
+			exit(1);
+		new_process = true;
+	}
+	/* Initialize other things only when we have file descriptor table. */
+	if (sclib_fd_mmap() != 0) {
+		sclib_fd_close();
+		exit(1);
+	}
+	sclib_memory_init();
+	sclib_memory_prealloc_init();
+	if (new_process) {
+		ret = sclib_efds_open(true);
+		if (SCLIB_IS_ERR(ret)) {
+			sclib_fd_close();
+			exit(1);
+		}
+	}
+	for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+		sclib_data[sysid].memoff = sclib_miscdata[sysid].membase -
+			(long) (&sclib_data[sysid].buffer->page);
+	}
+	/* Close O_CLOEXEC files */
+	sclib_file_exec(&sclib_file);
+}
+
+libc_hidden_def(sclib_init)
+
+void sclib_terminate(void)
+{
+	sclib_fd_close();
+}
+
+libc_hidden_def(sclib_terminate)
+
+ssize_t sclib_iovec_length(const struct iovec *iov, size_t count)
+{
+	size_t overflow = 0;
+	size_t length = 0;
+
+	/* Calculate total length */
+	for (; count != 0; count--) {
+		length += iov->iov_len;
+		if (unlikely((ssize_t) length < 0))
+			return -EINVAL;
+		overflow |= iov->iov_len;
+		iov++;
+	}
+	if (unlikely((ssize_t) overflow < 0))
+		return -EINVAL;
+	return length;
+}
+
+libc_hidden_def(sclib_iovec_length)
+
+void *sclib_copy_from_iovec(void *to, struct sclib_iovc *from, size_t length)
+{
+	const struct iovec *iov = from->iovc_iov;
+	size_t cur, off = from->iovc_off;
+
+	for (; length != 0; length -= cur) {
+		cur = iov->iov_len - off;
+		if (cur > length) {
+			to = mempcpy(to, iov->iov_base + off, length);
+			off += length;
+			break;
+		}
+		to = mempcpy(to, iov->iov_base + off, cur);
+		iov++;
+		off = 0;
+	}
+	from->iovc_iov = iov;
+	from->iovc_off = off;
+	return to;
+}
+
+libc_hidden_def(sclib_copy_from_iovec)
+
+void sclib_copy_to_iovec(struct sclib_iovc *to, const void *from, size_t length)
+{
+	const struct iovec *iov = to->iovc_iov;
+	size_t cur, off = to->iovc_off;
+
+	for (; length != 0; length -= cur) {
+		cur = iov->iov_len - off;
+		if (cur > length) {
+			memcpy(iov->iov_base + off, from, length);
+			off += length;
+			break;
+		}
+		memcpy(iov->iov_base + off, from, cur);
+		from += cur;
+		iov++;
+		off = 0;
+	}
+	to->iovc_iov = iov;
+	to->iovc_off = off;
+}
+
+libc_hidden_def(sclib_copy_to_iovec)
+
+struct msghdr *sclib_init_msghdr(struct msghdr *to, const struct msghdr *from,
+								 size_t total_iovlen, struct msghdr *rto)
+{
+	struct iovec *iov = (struct iovec *) (to + 1);
+
+	to->msg_iov = (struct iovec *) (rto + 1);
+	to->msg_iovlen = 1;
+	iov->iov_base = to->msg_iov + 1;
+	iov->iov_len = total_iovlen;
+	to->msg_control = iov->iov_base + total_iovlen;
+	to->msg_controllen = from->msg_controllen;
+	to->msg_name = NULL;
+	if (from->msg_name != NULL)
+		to->msg_name = to->msg_control + to->msg_controllen;
+	to->msg_namelen = from->msg_namelen;
+	to->msg_flags = from->msg_flags;
+
+	return rto;
+}
+
+libc_hidden_def(sclib_init_msghdr)
+
+void sclib_copy_from_msghdr(struct msghdr *_to, const struct msghdr *msg, size_t total_iovlen)
+{
+	struct sclib_iovc iovc;
+	void *to = (struct iovec *) (_to + 1) + 1;
+
+	iovc.iovc_iov = msg->msg_iov;
+	iovc.iovc_off = 0;
+	to = sclib_copy_from_iovec(to, &iovc, total_iovlen);
+	to = mempcpy(to, msg->msg_control, msg->msg_controllen);
+	if (msg->msg_name != NULL)
+		memcpy(to, msg->msg_name, msg->msg_namelen);
+}
+
+libc_hidden_def(sclib_copy_from_msghdr)
+
+void sclib_copy_to_msghdr(struct msghdr *msg, const struct msghdr *_from,
+						size_t length, size_t total_iovlen,
+						size_t controllen, size_t namelen)
+{
+	struct sclib_iovc iovc;
+	void *from = (struct iovec *) (_from + 1) + 1;
+
+	iovc.iovc_iov = msg->msg_iov;
+	iovc.iovc_off = 0;
+	sclib_copy_to_iovec(&iovc, from, length);
+	from += total_iovlen;
+	memcpy(msg->msg_control, from, MIN(controllen, msg->msg_controllen));
+	from += msg->msg_controllen;
+	msg->msg_controllen = controllen;
+	if (msg->msg_name != NULL)
+		memcpy(msg->msg_name, from, MIN(namelen, msg->msg_namelen));
+	msg->msg_namelen = namelen;
+}
+
+libc_hidden_def(sclib_copy_to_msghdr)
+
+long sclib_copy_file(long in_dfd, __off_t *in_off, long out_dfd, __off_t *out_off, size_t len, int in_sysid, int out_sysid)
+{
+	size_t total = 0, count = MIN(SCLIB_MAX_BUFFER, len);
+	void *in_buffer, *out_buffer;
+	long ret;
+	int inout_sysid;
+
+	if (in_sysid == SYSCALL_SYSID_LOCAL) {
+		in_buffer = sclib_memory_alloc(&sclib_data[out_sysid], count);
+		out_buffer = in_buffer;
+		inout_sysid = out_sysid;
+		if (unlikely(out_buffer == NULL))
+			return -ENOMEM;
+	} else if (out_sysid == SYSCALL_SYSID_LOCAL) {
+		in_buffer = sclib_memory_alloc(&sclib_data[in_sysid], count);
+		out_buffer = in_buffer;
+		inout_sysid = in_sysid;
+		if (unlikely(out_buffer == NULL))
+			return -ENOMEM;
+	} else {
+		out_buffer = sclib_memory_alloc(&sclib_data[out_sysid], count);
+		if (unlikely(out_buffer == NULL))
+			return -ENOMEM;
+		inout_sysid = out_sysid;
+		in_buffer = sclib_memory_alloc(&sclib_data[in_sysid], count);
+		if (unlikely(in_buffer == NULL)) {
+			total = -ENOMEM;
+			goto error;
+		}
+	}
+
+	if (in_off && out_off) {
+		for (; len != 0; len -= count) {
+			if (len < count)
+				count = len;
+			ret = SCLIB_SYSID_CALL_BUFFER(in_sysid, pread64, 4, in_dfd, in_buffer, count, *in_off);
+			SCLIB_VAL_RET(ret, total);
+			*in_off += (unsigned long) ret;
+			if (in_buffer != out_buffer)
+				memcpy(out_buffer, in_buffer, (unsigned long) ret);
+			ret = SCLIB_SYSID_CALL_BUFFER(out_sysid, pwrite64, 4, out_dfd, out_buffer, ret, *out_off);
+			SCLIB_VAL_RET(ret, total);
+			*out_off += (unsigned long) ret;
+			total += (unsigned long) ret;
+		}
+	} else if (in_off) {
+		for (; len != 0; len -= count) {
+			if (len < count)
+				count = len;
+			ret = SCLIB_SYSID_CALL_BUFFER(in_sysid, pread64, 4, in_dfd, in_buffer, count, *in_off);
+			SCLIB_VAL_RET(ret, total);
+			*in_off += (unsigned long) ret;
+			if (in_buffer != out_buffer)
+				memcpy(out_buffer, in_buffer, (unsigned long) ret);
+			ret = SCLIB_SYSID_CALL_BUFFER(out_sysid, write, 3, out_dfd, out_buffer, ret);
+			SCLIB_VAL_RET(ret, total);
+			total += (unsigned long) ret;
+		}
+	} else if (out_off) {
+		for (; len != 0; len -= count) {
+			if (len < count)
+				count = len;
+			ret = SCLIB_SYSID_CALL_BUFFER(in_sysid, read, 3, in_dfd, in_buffer, count);  
+			SCLIB_VAL_RET(ret, total);
+			if (in_buffer != out_buffer)
+				memcpy(out_buffer, in_buffer, (unsigned long) ret);
+			ret = SCLIB_SYSID_CALL_BUFFER(out_sysid, pwrite64, 4, out_dfd, out_buffer, ret, *out_off);
+			SCLIB_VAL_RET(ret, total);
+			*out_off += (unsigned long) ret;
+			total += (unsigned long) ret;
+		}
+	} else {
+		for (; len != 0; len -= count) {
+			if (len < count)
+				count = len;
+			ret = SCLIB_SYSID_CALL_BUFFER(in_sysid, read, 3, in_dfd, in_buffer, count);  
+			SCLIB_VAL_RET(ret, total);
+			if (in_buffer != out_buffer)
+				memcpy(out_buffer, in_buffer, (unsigned long) ret);
+			ret = SCLIB_SYSID_CALL_BUFFER(out_sysid, write, 3, out_dfd, out_buffer, ret);
+			SCLIB_VAL_RET(ret, total);
+			total += (unsigned long) ret;
+		}
+	}
+error_val:
+	if (in_buffer != out_buffer)
+		sclib_memory_free(&sclib_data[in_sysid], in_buffer);
+error:
+	sclib_memory_free(&sclib_data[inout_sysid], out_buffer);
+	return total;
+}
+
+libc_hidden_def(sclib_copy_file)
+
+long sclib_copy64_file(long in_dfd, __off64_t *in_off, long out_dfd, __off64_t *out_off, size_t len, int in_sysid, int out_sysid)
+{
+	size_t total = 0, count = MIN(SCLIB_MAX_BUFFER, len);
+	void *in_buffer, *out_buffer;
+	long ret;
+	int inout_sysid;
+
+	if (in_sysid == SYSCALL_SYSID_LOCAL) {
+		in_buffer = sclib_memory_alloc(&sclib_data[out_sysid], count);
+		out_buffer = in_buffer;
+		inout_sysid = out_sysid;
+		if (unlikely(out_buffer == NULL))
+			return -ENOMEM;
+	} else if (out_sysid == SYSCALL_SYSID_LOCAL) {
+		in_buffer = sclib_memory_alloc(&sclib_data[in_sysid], count);
+		out_buffer = in_buffer;
+		inout_sysid = in_sysid;
+		if (unlikely(out_buffer == NULL))
+			return -ENOMEM;
+	} else {
+		out_buffer = sclib_memory_alloc(&sclib_data[out_sysid], count);
+		if (unlikely(out_buffer == NULL))
+			return -ENOMEM;
+		inout_sysid = out_sysid;
+		in_buffer = sclib_memory_alloc(&sclib_data[in_sysid], count);
+		if (unlikely(in_buffer == NULL)) {
+			total = -ENOMEM;
+			goto error;
+		}
+	}
+
+	if (in_off && out_off) {
+		for (; len != 0; len -= count) {
+			if (len < count)
+				len = count;
+			ret = SCLIB_SYSID_CALL_BUFFER(in_sysid, pread64, 4, in_dfd, in_buffer, count, *in_off);
+			SCLIB_VAL_RET(ret, total);
+			*in_off += (unsigned long) ret;
+			if (in_buffer != out_buffer)
+				memcpy(out_buffer, in_buffer, (unsigned long) ret);
+			ret = SCLIB_SYSID_CALL_BUFFER(out_sysid, pwrite64, 4, out_dfd, out_buffer, ret, *out_off);
+			SCLIB_VAL_RET(ret, total);
+			*out_off += (unsigned long) ret;
+			total += (unsigned long) ret;
+		}
+	} else if (in_off) {
+		for (; len != 0; len -= count) {
+			if (len < count)
+				count = len;
+			ret = SCLIB_SYSID_CALL_BUFFER(in_sysid, pread64, 4, in_dfd, in_buffer, count, *in_off);
+			SCLIB_VAL_RET(ret, total);
+			*in_off += (unsigned long) ret;
+			if (in_buffer != out_buffer)
+				memcpy(out_buffer, in_buffer, (unsigned long) ret);
+			ret = SCLIB_SYSID_CALL_BUFFER(out_sysid, write, 3, out_dfd, out_buffer, ret);
+			SCLIB_VAL_RET(ret, total);
+			total += (unsigned long) ret;
+		}
+	} else if (out_off) {
+		for (; len != 0; len -= count) {
+			if (len < count)
+				count = len;
+			ret = SCLIB_SYSID_CALL_BUFFER(in_sysid, read, 3, in_dfd, in_buffer, count);  
+			SCLIB_VAL_RET(ret, total);
+			if (in_buffer != out_buffer)
+				memcpy(out_buffer, in_buffer, (unsigned long) ret);
+			ret = SCLIB_SYSID_CALL_BUFFER(out_sysid, pwrite64, 4, out_dfd, out_buffer, ret, *out_off);
+			SCLIB_VAL_RET(ret, total);
+			*out_off += (unsigned long) ret;
+			total += (unsigned long) ret;
+		}
+	} else {
+		for (; len != 0; len -= count) {
+			if (len < count)
+				count = len;
+			ret = SCLIB_SYSID_CALL_BUFFER(in_sysid, read, 3, in_dfd, in_buffer, count);  
+			SCLIB_VAL_RET(ret, total);
+			if (in_buffer != out_buffer)
+				memcpy(out_buffer, in_buffer, (unsigned long) ret);
+			ret = SCLIB_SYSID_CALL_BUFFER(out_sysid, write, 3, out_dfd, out_buffer, ret);
+			SCLIB_VAL_RET(ret, total);
+			total += (unsigned long) ret;
+		}
+	}
+error_val:
+	if (in_buffer != out_buffer)
+		sclib_memory_free(&sclib_data[in_sysid], in_buffer);
+error:
+	sclib_memory_free(&sclib_data[inout_sysid], out_buffer);
+	return total;
+}
+
+libc_hidden_def(sclib_copy64_file)
+
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/sclib_file.c uClibc-0.9.33-new/libc/sysdeps/linux/common/sclib_file.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/sclib_file.c	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/sclib_file.c	2013-09-23 20:39:32.958222861 -0400
@@ -0,0 +1,112 @@
+/**
+ * VM-Syscalls
+ * Copyright (c) 2012 Ruslan Nikolaev <rnikola@vt.edu>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <errno.h>
+#include <string.h>
+
+#include <bits/sclib.h>
+
+void sclib_file_init(sclib_file_table_t *file)
+{
+	size_t i;
+
+	for (i = 0; i < SCLIB_FILE_TABLE_LENGTH; i++) {
+		file->fds[i].counter = 0;
+		file->fds[i].flags_counter = 1;
+		file->fds[i].dfd = -1;
+	}
+	memset(file->bitmap, 0xFF, sizeof(file->bitmap));
+	__sync_synchronize();
+}
+
+libc_hidden_def(sclib_file_init)
+
+/* Does not check that fd is in the valid range */
+void sclib_file_replace(sclib_file_table_t *file, long fd, long dfd, int sysid,
+	sclib_fd_t *aux)
+{
+	if (sclib_replace_lock_fd(file, fd)) {
+		sclib_file_close(file, fd); /* Close an existent file descriptor */
+	} else {
+		sclib_bitmap_toggle(file->bitmap, fd);
+	}
+	file->fds[fd].dfd = dfd;
+	file->fds[fd].sysid = sysid;
+	file->fds[fd].flags = 0;
+	file->fds[fd].ectl_doms = 0xFF;
+	if (sysid == SYSCALL_SYSID_ALL)
+		memcpy(file->fds[fd].aux, aux, sizeof(file->fds[fd].aux));
+	sclib_replace_unlock_fd(file, fd);
+}
+
+libc_hidden_def(sclib_file_replace)
+
+void sclib_file_exec(sclib_file_table_t *file)
+{
+	long dfd;
+	size_t fd;
+
+	for (fd = 0; fd < SCLIB_FILE_TABLE_LENGTH; fd++) {
+		file->fds[fd].flags_counter = 1;
+		dfd = file->fds[fd].dfd;
+		if (dfd >= 0) {
+			if (file->fds[fd].flags & SCLIB_FD_EXEC) {
+				if (file->fds[fd].sysid != SYSCALL_SYSID_LOCAL)
+					sclib_file_close(file, fd);
+				file->fds[fd].dfd = -1; /* Removed */
+				sclib_bitmap_toggle(file->bitmap, fd);
+				file->fds[fd].counter = 0;
+			} else {
+				file->fds[fd].counter = 3;
+			}
+		} else {
+			file->fds[fd].counter = 0;
+		}
+	}
+	__sync_synchronize();
+}
+
+libc_hidden_def(sclib_file_exec)
+
+long sclib_file_close(sclib_file_table_t *file, long fd)
+{
+	long ret;
+	syscall_entry_t *pos[SYSCALL_SYSIDS];
+
+	if (file->fds[fd].sysid != SYSCALL_SYSID_ALL) {
+		ret = SCLIB_SYSID_CALL(file->fds[fd].sysid, close, 1, file->fds[fd].dfd);
+	} else {
+		long i;
+		for (i = 0; i < SYSCALL_SYSIDS; i++) {
+			pos[i] = SCLIB_REMOTE_CALL_ASYNC(i, close, 1, file->fds[fd].aux[i]);
+		}
+		ret = SCLIB_LOCAL_CALL(close, 1, file->fds[fd].dfd);
+		for (i = 0; i < SYSCALL_SYSIDS; i++) { /* Ignore errors for others */
+			SCLIB_REMOTE_CALL_RESULT(i, close, pos[i]);
+		}
+	}
+	return ret;
+}
+
+libc_hidden_def(sclib_file_close)
+
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/sclib_memory.c uClibc-0.9.33-new/libc/sysdeps/linux/common/sclib_memory.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/sclib_memory.c	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/sclib_memory.c	2013-09-23 20:39:32.958222861 -0400
@@ -0,0 +1,318 @@
+/**
+ * VM-Syscalls
+ * Copyright (c) 2012 Ruslan Nikolaev <rnikola@vt.edu>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <memory.h>
+#include <sys/ioctl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <errno.h>
+#include <assert.h>
+
+#include <bits/sclib.h>
+#include <bits/uClibc_mutex.h>
+
+#define memory_block_entry(elem,member) ((sclib_memory_block_t *) ((char *) &elem->pred - offsetof(sclib_memory_list_t, pred) - offsetof(sclib_memory_block_t, member)))
+
+__UCLIBC_MUTEX_STATIC(memory_lock, __SCLIB_MUTEX_RECURSIVE);
+
+static inline void memory_do_expand(long domfd, long num)
+{
+	if (SCLIB_LOCAL_CALL(ioctl, 3, domfd,
+		SYSCALL_DRIVER_IOCTL_EXPAND_BUFFER, num) != num) {
+		fprintf(stderr, "ERROR: Cannot expand the data buffer\n");
+		exit(1);
+	}
+}
+
+static inline uint32_t round_up_power2(uint32_t num)
+{
+	num--;
+	num |= num >> 1;
+	num |= num >> 2;
+	num |= num >> 4;
+	num |= num >> 8;
+	num |= num >> 16;
+	num++;
+	return num;
+}
+
+static sclib_memory_block_t * memory_expand(sclib_data_t * data, size_t size)
+{
+	sclib_memory_block_t *node;
+	sclib_memory_binfo_t *foot;
+	sclib_memory_list_t *succ;
+	uint32_t new_pos, old_pos, num;
+
+	node = (sclib_memory_block_t *) data->map_end;
+	old_pos = data->map_pos;
+	new_pos = round_up_power2(old_pos + (size + PAGE_SIZE - 1) / PAGE_SIZE);
+	if (new_pos > SYSCALL_DATA_SHARED_PAGES) {
+		if (old_pos == SYSCALL_DATA_SHARED_PAGES)
+			return NULL;
+		new_pos = SYSCALL_DATA_SHARED_PAGES;
+	}
+	num = new_pos - old_pos;
+	memory_do_expand(sclib_miscdata[data->sysid].domfd, num);
+	data->map_pos = new_pos;
+	size = (size_t) num * PAGE_SIZE;
+	data->map_end += size;
+	/* Coalesce the upper part */
+	foot = (sclib_memory_binfo_t *) node - 1;
+	if ((char *) foot > data->map_start
+		&& foot->magic == SCLIB_MEMORY_MAGIC_FREE) {
+		node = (sclib_memory_block_t *) ((char *) node - foot->size);
+		size += foot->size;
+	} else {
+		succ = data->memory.succ;
+		succ->pred = &node->list;
+		data->memory.succ = &node->list;
+		node->list.succ = succ;
+		node->list.pred = &data->memory;
+		node->block.magic = SCLIB_MEMORY_MAGIC_FREE;
+	}
+	node->block.size = size;
+	foot = (sclib_memory_binfo_t *) ((char *) node + size) - 1;
+	*foot = node->block;
+	return node;
+}
+
+static sclib_memory_block_t *memory_find(sclib_data_t * data, size_t size)
+{
+	sclib_memory_list_t *start = &data->memory;
+	sclib_memory_list_t *cur = data->memory.succ;
+	while (cur != start) {
+		sclib_memory_block_t *ent = memory_block_entry(cur, list);
+		if (ent->block.size >= size)
+			return ent;
+		cur = cur->succ;
+	}
+	return NULL;
+}
+
+static sclib_memory_block_t *memory_place(sclib_data_t * data,
+										  sclib_memory_block_t * node,
+										  size_t size)
+{
+	sclib_memory_list_t * pred, * succ;
+	sclib_memory_block_t * alloc;
+	sclib_memory_binfo_t * foot;
+	size_t remsize;
+
+	remsize = node->block.size - size;
+	if (remsize > sizeof(sclib_memory_block_t) + sizeof(sclib_memory_binfo_t)) {
+		/* Reduce the size of the free block */
+		alloc = (sclib_memory_block_t *) ((char *) node + remsize);
+		node->block.size = remsize;
+		foot = (sclib_memory_binfo_t *) alloc - 1;
+		*foot = node->block;
+		alloc->block.size = size;
+	} else {
+		size = node->block.size;
+		/* Exclude from the list */
+		pred = node->list.pred;
+		succ = node->list.succ;
+		pred->succ = succ;
+		succ->pred = pred;
+		alloc = node;
+	}
+
+	alloc->block.magic = SCLIB_MEMORY_MAGIC_ALLOC;
+	foot = (sclib_memory_binfo_t *) ((char *) alloc + size) - 1;
+	*foot = alloc->block;
+	return alloc;
+}
+
+void sclib_memory_init(void)
+{
+	sclib_data_t *data;
+
+	for (data = &sclib_data[0]; data != &sclib_data[SYSCALL_SYSIDS]; data++) {
+		sclib_memory_block_t *node;
+		sclib_memory_binfo_t *foot;
+		size_t size = data->map_pos * PAGE_SIZE;
+
+		data->map_start = (char *) data->buffer->data;
+		data->map_end = (char *) data->map_start + size;
+		if (size) { /* At least 1 page, already aligned */
+			node = (sclib_memory_block_t *) data->map_start;
+			node->list.succ = &data->memory;
+			node->list.pred = &data->memory;
+			node->block.magic = SCLIB_MEMORY_MAGIC_FREE;
+			node->block.size = size;
+			foot = (sclib_memory_binfo_t *) data->map_end - 1;
+			*foot = node->block;
+			data->memory.pred = &node->list;
+			data->memory.succ = &node->list;
+		} else {
+			data->memory.pred = &data->memory;
+			data->memory.succ = &data->memory;
+		}
+	}
+}
+
+libc_hidden_def(sclib_memory_init)
+
+#ifndef SCLIB_MEMORY_PREALLOC
+inline
+#endif
+static void sclib_do_memory_free(sclib_data_t *data, sclib_memory_block_t *node)
+{
+	sclib_memory_block_t *next;
+	sclib_memory_list_t *pred, *succ;
+	sclib_memory_binfo_t *foot;
+	size_t size;
+	int rc = 0;
+
+	__UCLIBC_MUTEX_LOCK(memory_lock);
+	if (node->block.magic != SCLIB_MEMORY_MAGIC_ALLOC) {
+		rc = 1;
+		goto error;
+	}
+	size = node->block.size;
+	node->block.magic = SCLIB_MEMORY_MAGIC_FREE;
+	foot = (sclib_memory_binfo_t *) ((char *) node + size) - 1;
+	foot->magic = SCLIB_MEMORY_MAGIC_FREE;
+	/* Coalesce the upper part */
+	foot = (sclib_memory_binfo_t *) node - 1;
+	if ((char *) foot > data->map_start
+		&& foot->magic == SCLIB_MEMORY_MAGIC_FREE) {
+		node = (sclib_memory_block_t *) ((char *) node - foot->size);
+		/* Exlude the element from the list */
+		pred = node->list.pred;
+		succ = node->list.succ;
+		pred->succ = succ;
+		succ->pred = pred;
+		/* Coalescing */
+		size += foot->size;
+		node->block.size = size;
+		foot = (sclib_memory_binfo_t *) ((char *) node + size) - 1;
+		foot->size = size;
+	}
+	/* Coalesce the lower part */
+	next = (sclib_memory_block_t *) ((char *) node + size);
+	if ((char *) next < data->map_end
+		&& next->block.magic == SCLIB_MEMORY_MAGIC_FREE) {
+		/* Exclude the element from the list */
+		pred = next->list.pred;
+		succ = next->list.succ;
+		pred->succ = succ;
+		succ->pred = pred;
+		/* Coalescing */
+		size += next->block.size;
+		node->block.size = size;
+		foot = (sclib_memory_binfo_t *) ((char *) node + size) - 1;
+		foot->size = size;
+	}
+	/* Add to the list of free blocks */
+	succ = data->memory.succ;
+	node->list.pred = &data->memory;
+	node->list.succ = succ;
+	succ->pred = &node->list;
+	data->memory.succ = &node->list;
+
+error:
+	__UCLIBC_MUTEX_UNLOCK(memory_lock);
+	if (rc) {
+		fprintf(stderr, "ERROR: Invalid memory reference\n");
+		exit(1);
+	}
+}
+
+void *sclib_memory_alloc(sclib_data_t *data, size_t size)
+{
+	sclib_memory_block_t *node;
+
+	if (size > SYSCALL_DATA_SHARED_PAGES * PAGE_SIZE -
+	    2 * sizeof(sclib_memory_binfo_t))
+		return NULL;
+
+	size = (size + SCLIB_MEMORY_ALIGN - 1) & ~(SCLIB_MEMORY_ALIGN - 1);
+	size += 2 * sizeof(sclib_memory_binfo_t);
+
+#ifdef SCLIB_MEMORY_PREALLOC
+	node = __sync_lock_test_and_set(&sclib_memptr[data->sysid], NULL); 
+
+	if (node != NULL) {
+		if (node->block.size >= size)
+			goto done;
+		sclib_do_memory_free(data, node);
+	}
+#endif
+
+	while (1) {
+		__UCLIBC_MUTEX_LOCK(memory_lock);
+		node = memory_find(data, size);
+		/* Expand the buffer if necessary */
+		if (!node) {
+			node = memory_expand(data, size);
+			if (!node)
+				goto again;
+		}
+		node = memory_place(data, node, size);
+again:
+		__UCLIBC_MUTEX_UNLOCK(memory_lock);
+		if (node)
+			break;
+		sched_yield();
+	}
+
+#ifdef SCLIB_MEMORY_PREALLOC
+done:
+#endif
+	return (char *) node + sizeof(sclib_memory_binfo_t);
+}
+
+libc_hidden_def(sclib_memory_alloc)
+
+void sclib_memory_free(sclib_data_t *data, void *addr)
+{
+	sclib_memory_block_t *node;
+	node = (sclib_memory_block_t *) ((char *) addr - sizeof(sclib_memory_binfo_t));
+#ifdef SCLIB_MEMORY_PREALLOC
+	node = __sync_lock_test_and_set(&sclib_memptr[data->sysid], node); 
+	if (node != NULL)
+		sclib_do_memory_free(data, node);
+#else
+	sclib_do_memory_free(data, node);
+#endif
+}
+
+libc_hidden_def(sclib_memory_free)
+
+#ifdef SCLIB_MEMORY_PREALLOC
+void sclib_memory_prealloc_exit(void)
+{
+	size_t sysid;
+
+	for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+		sclib_memory_block_t *node;
+		node = __sync_lock_test_and_set(&sclib_memptr[sysid], NULL); 
+		if (node != NULL)
+			sclib_do_memory_free(&sclib_data[sysid], node);
+	}
+}
+
+libc_hidden_def(sclib_memory_prealloc_exit)
+#endif
+
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/sclib_syscalls.c uClibc-0.9.33-new/libc/sysdeps/linux/common/sclib_syscalls.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/sclib_syscalls.c	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/sclib_syscalls.c	2013-09-23 20:39:32.958222861 -0400
@@ -0,0 +1,307 @@
+/**
+ * VM-Syscalls
+ * Copyright (c) 2012 Ruslan Nikolaev <rnikola@vt.edu>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <sys/syscall.h>
+#include <unistd.h>
+#include <string.h>
+#include <signal.h>
+#include <stdio.h>
+#include <bits/sclib.h>
+#include <bits/sclib_syscalls.h>
+
+long __internal_sys_read(int fd, void *buf, size_t count)
+{
+	int sysid;
+	size_t size;
+	long dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	SCLIB_SYS_RET(dfd);
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		size_t ret, chunk = MIN(count, SCLIB_MAX_BUFFER);
+		void *rbuf, *mem = sclib_memory_alloc(&sclib_data[sysid], chunk);
+
+		SCLIB_MEM_RET(mem, size);
+		size = 0;
+		rbuf = sclib_mem(sysid, mem);
+
+		for (; count > chunk; count -= chunk) {
+			ret = SCLIB_REMOTE_CALL(sysid, read, 3, dfd, rbuf, chunk);
+			SCLIB_VAL_RET(ret, size);
+			size += ret;
+			buf = mempcpy(buf, mem, ret);
+			if (unlikely(ret < chunk))
+				goto error_val;
+		}
+		ret = SCLIB_REMOTE_CALL(sysid, read, 3, dfd, rbuf, count);
+		SCLIB_VAL_RET(ret, size);
+		size += ret;
+		memcpy(buf, mem, ret);
+
+error_val:
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		size = SCLIB_LOCAL_CALL(read, 3, dfd, buf, count);
+	}
+
+error_mem:
+	sclib_file_put(&sclib_file, fd);
+	return size;
+}
+
+libc_hidden_def(__internal_sys_read)
+
+long __internal_sys_write(int fd, const void *buf, size_t count)
+{
+	int sysid;
+	size_t size;
+	long dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	SCLIB_SYS_RET(dfd);
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		size_t ret, chunk = MIN(count, SCLIB_MAX_BUFFER);
+		void *rbuf, *mem = sclib_memory_alloc(&sclib_data[sysid], chunk);
+
+		SCLIB_MEM_RET(mem, size);
+		size = 0;
+		rbuf = sclib_mem(sysid, mem);
+
+		for (; count > chunk; count -= chunk) {
+			memcpy(mem, buf, chunk);
+			buf += chunk;
+			ret = SCLIB_REMOTE_CALL(sysid, write, 3, dfd, rbuf, chunk);
+			SCLIB_VAL_RET(ret, size);
+			size += ret;
+			if (unlikely(ret < chunk))
+				goto error_val;
+		}
+		memcpy(mem, buf, count);
+		ret = SCLIB_REMOTE_CALL(sysid, write, 3, dfd, rbuf, count);
+		SCLIB_VAL_RET(ret, size);
+		size += ret;
+
+error_val:
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		size = SCLIB_LOCAL_CALL(write, 3, dfd, buf, count);
+	}
+
+error_mem:
+	sclib_file_put(&sclib_file, fd);
+	return size;
+}
+
+libc_hidden_def(__internal_sys_write)
+
+long __internal_sys_open(const char * file, int flags, int mode)
+{
+	long dfd, fd;
+	uint8_t dfd_flags = 0;
+	char abspath[PATH_MAX + 8], *dpath;
+	int sysid;
+	void *rbuf;
+	size_t sz;
+
+	dpath = sclib_get_path(abspath, file, &sysid, &sz);
+	/* Translate /proc/.../{fd,fdinfo} paths */
+	if (unlikely(strncmp(dpath, "/proc/", 6) == 0)) {
+		char *fdstr;
+		int tran_fd;
+		long tran_dfd;
+
+		/* Have both since they may be terminated by '/' */
+		fdstr = dpath + 6;
+		if (strncmp(fdstr, "self/", 5) != 0) {
+			char pid_buf[16];
+			int pid_len = sprintf(pid_buf, "%u/", getpid());
+			if (strncmp(fdstr, pid_buf, pid_len) != 0)
+				goto skip;
+			fdstr += pid_len;
+		} else {
+			fdstr += 5;
+		}
+		if (strncmp(fdstr, "fd", 2) != 0)
+			goto skip;
+		fdstr += 2;
+		if (strncmp(fdstr, "info", 4) == 0)
+			fdstr += 4;
+		if (*fdstr == '\0') {
+			dfd_flags |= SCLIB_FD_TRAN;
+		} else if (*fdstr == '/') {
+			fdstr++;
+			if (*fdstr == '\0') {
+				dfd_flags |= SCLIB_FD_TRAN;
+			} else {
+				if (fdstr[0] != '.') {
+					/* Opening a file rather than directory */
+					if (sscanf(fdstr, "%d", &tran_fd) != 1 ||
+						(tran_dfd = sclib_file_get(&sclib_file,
+							tran_fd, sysid)) < 0) {
+						return -EINVAL;
+					}
+					sclib_file_put(&sclib_file, tran_fd);
+					sprintf(fdstr, "%d", (int) tran_dfd);
+				}
+			}
+		}
+	}
+
+skip:
+	fd = sclib_file_add(&sclib_file, 0);
+	if (SCLIB_IS_ERR(fd))
+		goto error;
+
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		rbuf = sclib_memory_alloc(&sclib_data[sysid], sz);
+		SCLIB_MEM_RET(rbuf, dfd);
+		memcpy(rbuf, dpath, sz);
+		dfd = SCLIB_REMOTE_CALL(sysid, open, 3, sclib_mem(sysid, rbuf), flags, mode);
+		sclib_memory_free(&sclib_data[sysid], rbuf);
+	} else {
+		dfd = SCLIB_LOCAL_CALL(open, 3, dpath, flags, mode);
+	}
+
+error_mem:
+	if (SCLIB_IS_ERR(dfd)) {
+		sclib_file_add_fail(&sclib_file, fd);
+		fd = dfd;
+	} else {
+		if (flags & O_CLOEXEC)
+			dfd_flags |= SCLIB_FD_EXEC;
+		sclib_file_add_ok(&sclib_file, fd, dfd, sysid, dfd_flags, 0);
+	}
+
+error:
+	return fd;
+}
+
+libc_hidden_def(__internal_sys_open)
+
+long __internal_sys_close(int fd)
+{
+	int sysid;
+	long dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	SCLIB_SYS_RET(dfd);
+	sclib_file_release(&sclib_file, fd);
+	return 0;
+}
+
+libc_hidden_def(__internal_sys_close)
+
+long __internal_sys_clone_begin(long flags)
+{
+	int cloneVM = (flags & CLONE_VM) != 0;
+	int cloneFD = (flags & CLONE_FILES) != 0;
+	long dfd;
+
+	if (cloneVM != cloneFD) /* Not supported */
+		return -EFAULT;
+	if (cloneVM)
+		return SCLIB_CLONE_THREAD;
+	dfd = SCLIB_LOCAL_CALL(eventfd, 2, 0, 0);
+	return dfd;
+}
+
+libc_hidden_def(__internal_sys_clone_begin)
+
+void __internal_sys_clone_child(long dfd)
+{
+	long ret = 0;
+	uint64_t val;
+	size_t sysid;
+
+	if (dfd != SCLIB_CLONE_THREAD) {
+		SCLIB_LOCAL_CALL(munmap, 2, sclib_rqueue, SYSCALL_QUEUE_PAGES * PAGE_SIZE);
+		sclib_init_minimal();
+		sclib_fd_close();
+		ret = sclib_fd_open();
+		if (likely(ret >= 0)) {
+			ret = sclib_fd_mmap();
+			if (likely(ret >= 0)) {
+				sclib_memory_init();
+				sclib_memory_prealloc_init();
+				/* The following statement will also block the task
+				 until it is truly added, as we need to get response from
+				 a remote domain. */
+				ret = sclib_efds_open(true);
+				if (ret == 0) {
+					for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++)
+						sclib_data[sysid].memoff = sclib_miscdata[sysid].membase - (long) (&sclib_data[sysid].buffer->page);
+				}
+			}
+		}
+		val = -ret + 1; /* Put an error code */
+		SCLIB_LOCAL_CALL(write, 3, dfd, &val, sizeof(val));
+		SCLIB_LOCAL_CALL(close, 1, dfd);
+		if (unlikely(ret != 0)) { /* Error code is sent to the parent */
+			/* Sclib file descriptor will be closed if it is open anyway */
+			exit(1);
+		}
+	} else {
+		__internal_sys_clone_thread();
+	}
+}
+
+libc_hidden_def(__internal_sys_clone_child)
+
+long __internal_sys_clone_parent(long ret, long dfd)
+{
+	uint64_t val;
+	long err;
+
+	if (dfd != SCLIB_CLONE_THREAD) {
+		if (!SCLIB_IS_ERR(ret)) {
+			SCLIB_LOCAL_CALL(read, 3, dfd, &val, sizeof(val));
+			err = -(int64_t) (val - 1);
+			if (unlikely(err != 0))
+				ret = err;
+		}
+		SCLIB_LOCAL_CALL(close, 1, dfd);
+	}
+	return ret;
+}
+
+libc_hidden_def(__internal_sys_clone_parent)
+
+long __internal_sys_fork(void)
+{
+	long ret, param;
+
+	param = __internal_sys_clone_begin(0);
+	if (SCLIB_IS_ERR(param))
+		return param;
+
+	ret = SCLIB_LOCAL_CALL(clone, 4,
+			CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID | SIGCHLD, 0,
+			NULL, &KTHREAD_SELF->ktid);
+
+	if (ret == 0) { /* Child */
+		__internal_sys_clone_child(param);
+	} else { /* Parent */
+		ret = __internal_sys_clone_parent(ret, param);
+	}
+	return ret;
+}
+
+libc_hidden_def(__internal_sys_fork)
+
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/select.c uClibc-0.9.33-new/libc/sysdeps/linux/common/select.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/select.c	2013-09-23 20:39:08.218221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/select.c	2013-09-23 20:39:32.958222861 -0400
@@ -3,6 +3,7 @@
  * select() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -11,6 +12,9 @@
 #include <sys/select.h>
 #include <stdint.h>
 
+#include <string.h>
+#include <bits/sclib.h>
+
 #ifdef __UCLIBC_HAS_THREADS_NATIVE__
 #include <sysdep-cancel.h>
 #else
@@ -65,14 +69,264 @@
 
 #else
 
-#ifdef __NR__newselect
-# define __NR___syscall_select __NR__newselect
-#else
-# define __NR___syscall_select __NR_select
-#endif
+static long select_convert_input(long *nall, fd_set *fds,
+	fd_set *dom[SYSCALL_SYSIDS+1], long domidx, long *ndom)
+{
+	long n = *nall;
+	long fd, dfd, mask = 0;
+	int sysid;
+	fd_set *cur;
+
+	*nall = 0;
+	if (fds != NULL) {
+		for (fd = 0; fd < n; fd++) {
+			if (FD_ISSET(fd, fds)) {
+				dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+				if (SCLIB_IS_ERR(dfd))
+					return dfd;
+				*nall = fd + 1;
+				if (!dom[sysid]) {
+					dom[sysid] = sclib_memory_alloc(&sclib_data[sysid], 3 * sizeof(fd_set) + sizeof(struct timeval));
+					if (dom[sysid] == NULL)
+						return -ENOMEM;
+				}
+				cur = dom[sysid] + domidx;
+				if (!(mask & (1U << sysid))) {
+					mask |= (1U << sysid);
+					FD_ZERO(cur);
+				}
+				FD_SET(dfd, cur);
+				if (dfd >= ndom[sysid])
+					ndom[sysid] = dfd + 1;
+			}
+		}
+	}
+	return mask;
+}
 
-static _syscall5(int, __syscall_select, int, n, fd_set *, readfds,
-		fd_set *, writefds, fd_set *, exceptfds, struct timeval *, timeout);
+static void select_convert_output(long n, fd_set *fds, fd_set *dom[SYSCALL_SYSIDS+1], long domidx)
+{
+	long fd, dfd;
+	int sysid;
+	fd_set *cur;
+
+	if (fds != NULL) {
+		for (fd = 0; fd < n; fd++) {
+			if (FD_ISSET(fd, fds)) {
+				dfd = sclib_file_touch(&sclib_file, fd, &sysid);
+				sclib_file_put(&sclib_file, fd);
+				cur = dom[sysid] + domidx;
+				if (!FD_ISSET(dfd, cur))
+					FD_CLR(fd, fds);
+			}
+		}
+	}
+}
+
+static inline void __syscall_select_debug(long n, fd_set *rfds, fd_set *wfds, fd_set *efds, struct timeval *timeout)
+{
+    char buf[256], *buf_ptr;
+	long i;
+
+	buf_ptr = stpcpy(buf, "R:[");
+	if (rfds != NULL) {
+		for (i = 0; i < n; i++) {
+			if (FD_ISSET(i, rfds))
+				buf_ptr += sprintf(buf_ptr, (i == n - 1) ? "%li" : "%li,", i);
+		}
+	}
+	buf_ptr = stpcpy(buf_ptr, "] W:[");
+	if (wfds != NULL) {
+		for (i = 0; i < n; i++) {
+			if (FD_ISSET(i, wfds))
+				buf_ptr += sprintf(buf_ptr, (i == n - 1) ? "%li" : "%li,", i);
+		}
+	}
+	buf_ptr = stpcpy(buf_ptr, "] E:[");
+	if (efds != NULL) {
+		for (i = 0; i < n; i++) {
+			if (FD_ISSET(i, efds))
+				buf_ptr += sprintf(buf_ptr, (i == n - 1) ? "%li" : "%li,", i);
+		}
+	}
+	buf_ptr = stpcpy(buf_ptr, "]");
+	SCLIB_LOCAL_CALL(write, 3, -1, buf, strlen(buf));
+	if (timeout != NULL) {
+		SCLIB_STRACE_DEBUG("T:{%li,%li}", timeout->tv_sec, timeout->tv_usec);
+	}
+}
+
+static long __syscall_select(long n, fd_set *rfds, fd_set *wfds, fd_set *efds,
+	struct timeval *timeout)
+{
+	struct syscall_efd param;
+	fd_set loc[3];
+	fd_set *dom[SYSCALL_SYSIDS+1], *cur;
+	long mask, mask_check, mask_rfds, mask_wfds, mask_efds;
+	long rfds_n, wfds_n, efds_n;
+	long err, ret, num, ndom[SYSCALL_SYSIDS+1];
+	syscall_entry_t *pos[SYSCALL_SYSIDS];
+	int timeout_copied, sysid;
+
+	//SCLIB_STRACE_DEBUG("SELECT %li\n", n);
+	//__syscall_select_debug(n, rfds, wfds, efds, timeout);
+
+	if (unlikely((unsigned long) n > 1024)) {
+		num = -EINVAL;
+		goto error4;
+	}
+	memset(dom, 0, sizeof(dom));
+	memset(ndom, 0, sizeof(ndom));
+
+	dom[SYSCALL_SYSID_LOCAL] = loc;
+	rfds_n = n;
+	num = select_convert_input(&rfds_n, rfds, dom, 0, ndom);
+
+	if (SCLIB_IS_ERR(num))
+		goto error3;
+	mask = num;
+	wfds_n = n;
+	num = select_convert_input(&wfds_n, wfds, dom, 1, ndom);
+
+	if (SCLIB_IS_ERR(num))
+		goto error2;
+
+	mask |= (num << (SYSCALL_SYSIDS + 1));
+	efds_n = n;
+	num = select_convert_input(&efds_n, efds, dom, 2, ndom);
+	if (SCLIB_IS_ERR(num))
+		goto error1;
+	mask |= (num << 2 * (SYSCALL_SYSIDS + 1));
+
+	mask_check = ~0L;
+	for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+		cur = dom[sysid];
+		mask_rfds = 1UL << sysid;
+		mask_wfds = mask_rfds << (SYSCALL_SYSIDS+1);
+		mask_efds = mask_wfds << (SYSCALL_SYSIDS+1);
+		num = mask_rfds + mask_wfds + mask_efds;
+		if (mask & num) { /* ..1..1..1 */
+			void *rarg = NULL, *warg = NULL, *earg = NULL, *targ = NULL;
+			void *rcur = sclib_mem(sysid, cur);
+			long efd_packed;
+
+			mask_check = ~num;
+			if (mask & mask_check) {
+				if (!(mask & mask_rfds)) { /* No one initialized rfds set yet */
+					mask |= mask_rfds;
+					FD_ZERO(&cur[0]);
+				}
+				efd_packed = sclib_thread.efd[sysid];
+				FD_SET(efd_packed, &cur[0]);
+				if (efd_packed >= ndom[sysid])
+					ndom[sysid] = efd_packed + 1;
+				efd_packed |= sclib_thread.efd[SYSCALL_SYSIDS] << 10;
+			} else {
+				efd_packed = 0xFFFFF;
+			}
+			efd_packed |= (ndom[sysid] << 20);
+			if (mask & mask_rfds)
+				rarg = rcur;
+			if (mask & mask_wfds)
+				warg = rcur + sizeof(fd_set);
+			if (mask & mask_efds)
+				earg = rcur + 2 * sizeof(fd_set);
+			if (timeout != NULL) {
+				targ = rcur + 3 * sizeof(fd_set);
+				memcpy((char *) cur + 3 * sizeof(fd_set), timeout, sizeof(struct timeval)); 
+			}
+			pos[sysid] = SCLIB_REMOTE_CALL_ASYNC(sysid, syscall_service_select, 5, efd_packed, rarg, warg, earg, targ);
+		}
+	}
+
+	timeout_copied = (timeout == NULL);
+    num = 0;
+	if ((mask & mask_check) || mask == 0) {
+		long efd;
+
+		mask_rfds = 1UL << SYSCALL_SYSID_LOCAL;
+		mask_wfds = mask_rfds << (SYSCALL_SYSIDS+1);
+		mask_efds = mask_wfds << (SYSCALL_SYSIDS+1);
+		if (mask & ~(mask_rfds + mask_wfds + mask_efds)) {
+			param.efd_num = -1;
+			efd = sclib_thread.efd[SYSCALL_SYSIDS];
+			param.efd[SYSCALL_SYSIDS] = efd;
+			if (!(mask & mask_rfds)) { /* No one initialized rfds set yet */
+				mask |= mask_rfds;
+				FD_ZERO(&loc[0]);
+			}
+			FD_SET(efd, &loc[0]);
+			if (efd >= ndom[SYSCALL_SYSID_LOCAL])
+				ndom[SYSCALL_SYSID_LOCAL] = efd + 1;
+			for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++)
+				param.efd[sysid] = sclib_thread.efd[sysid];
+		} else {
+			param.efd_num = 0;
+			efd = -1;
+		}
+		param.n = ndom[SYSCALL_SYSID_LOCAL];
+		num = SCLIB_LOCAL_CALL(syscall_service_select, 5, &param,
+			(mask & mask_rfds) ? &loc[0] : NULL,
+			(mask & mask_wfds) ? &loc[1] : NULL,
+			(mask & mask_efds) ? &loc[2] : NULL, timeout);
+		timeout_copied = 1;
+		if (likely(num != -EFAULT))
+			sclib_wait_efd(&param, efd);
+	}
+
+	/* Get result from the remote domain */
+	err = num;
+	if (mask_check != ~0L) {
+		for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+			if (!dom[sysid])
+				continue;
+			ret = SCLIB_REMOTE_CALL_RESULT(sysid, syscall_service_select, pos[sysid]);
+			if (!timeout_copied) {
+				memcpy(timeout, (char *) dom[sysid] + 3 * sizeof(fd_set), sizeof(struct timeval));
+				timeout_copied = 1;
+			}
+			if (SCLIB_IS_ERR(ret)) {
+				err = ret;
+			} else {
+				num += ret;
+			}
+		}
+		SCLIB_VAL_RET(err, num);
+
+		/* Correct num value */
+		if (mask & (1U << SYSCALL_SYSID_LOCAL)) {
+			for (sysid = 0; sysid < SYSCALL_SYSIDS+1; sysid++) {
+				if (!dom[sysid])
+					continue;
+				if (FD_ISSET(sclib_thread.efd[sysid], &dom[sysid][0]))
+					num--;
+			}
+		}
+	} else {
+		SCLIB_VAL_RET(err, num);
+	}
+
+error_val:
+error1:
+	select_convert_output(efds_n, efds, dom, 2);
+error2:
+	select_convert_output(wfds_n, wfds, dom, 1);
+error3:
+	select_convert_output(rfds_n, rfds, dom, 0);
+
+	for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+		if (!dom[sysid])
+			continue;
+		sclib_memory_free(&sclib_data[sysid], dom[sysid]);
+	}
+
+error4:
+	//SCLIB_STRACE_DEBUG("SELECT, result %li\n", num);
+	//__syscall_select_debug(n, rfds, wfds, efds, timeout);
+
+	SCLIB_ERR_RET(num);
+	return num;
+}
 
 int __libc_select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
                   struct timeval *timeout)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/sendfile64.c uClibc-0.9.33-new/libc/sysdeps/linux/common/sendfile64.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/sendfile64.c	2013-09-23 20:39:08.222221835 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/sendfile64.c	2013-09-23 20:39:32.958222861 -0400
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -19,6 +20,42 @@
 #include <sys/syscall.h>
 #include <bits/wordsize.h>
 
+#include <bits/sclib.h>
+
 #if defined __UCLIBC_HAS_LFS__ && defined __NR_sendfile64
-_syscall4(ssize_t,sendfile64, int, out_fd, int, in_fd, __off64_t *, offset, size_t, count)
+ssize_t sendfile64(int out_fd, int in_fd, __off64_t *offset, size_t count)
+{
+	int out_sysid, in_sysid;
+	long ret, out_dfd, in_dfd;
+
+	out_dfd = sclib_file_getid(&sclib_file, out_fd, &out_sysid);
+	if (SCLIB_IS_ERR(out_dfd)) {
+		ret = out_dfd;
+		goto error_out_dfd;
+	}
+	in_dfd = sclib_file_getid(&sclib_file, in_fd, &in_sysid);
+	if (SCLIB_IS_ERR(in_dfd)) {
+		ret = in_dfd;
+		goto error_in_dfd;
+	}
+
+	if (out_sysid == in_sysid) {
+		if (out_sysid != SYSCALL_SYSID_LOCAL) {
+			ret = SCLIB_REMOTE_CALL(out_sysid, sendfile64, 4, out_dfd, in_dfd, offset ? *offset : -1L, count);
+			if (!SCLIB_IS_ERR(ret) && offset != NULL)
+				*offset += (unsigned long) ret;
+		} else {
+			ret = SCLIB_LOCAL_CALL(sendfile64, 4, out_dfd, in_dfd, offset, count);
+		}
+	} else {
+		ret = sclib_copy64_file(in_dfd, offset, out_dfd, 0, count, in_sysid, out_sysid);
+	}
+
+	sclib_file_put(&sclib_file, in_fd);
+error_in_dfd:
+	sclib_file_put(&sclib_file, out_fd);
+error_out_dfd:
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/sendfile.c uClibc-0.9.33-new/libc/sysdeps/linux/common/sendfile.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/sendfile.c	2013-09-23 20:39:08.182221833 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/sendfile.c	2013-09-23 20:39:32.958222861 -0400
@@ -3,6 +3,7 @@
  * sendfile() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -11,10 +12,45 @@
 #include <unistd.h>
 #include <sys/sendfile.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_sendfile
 
-_syscall4(ssize_t, sendfile, int, out_fd, int, in_fd, __off_t *, offset,
-		  size_t, count)
+ssize_t sendfile(int out_fd, int in_fd, __off_t *offset, size_t count)
+{
+	int out_sysid, in_sysid;
+	long ret, out_dfd, in_dfd;
+
+	out_dfd = sclib_file_getid(&sclib_file, out_fd, &out_sysid);
+	if (SCLIB_IS_ERR(out_dfd)) {
+		ret = out_dfd;
+		goto error_out_dfd;
+	}
+	in_dfd = sclib_file_getid(&sclib_file, in_fd, &in_sysid);
+	if (SCLIB_IS_ERR(in_dfd)) {
+		ret = in_dfd;
+		goto error_in_dfd;
+	}
+
+	if (out_sysid == in_sysid) {
+		if (out_sysid != SYSCALL_SYSID_LOCAL) {
+			ret = SCLIB_REMOTE_CALL(out_sysid, sendfile, 4, out_dfd, in_dfd, offset ? *offset : -1L, count);
+			if (!SCLIB_IS_ERR(ret) && offset != NULL)
+				*offset += (unsigned long) ret;
+		} else {
+			ret = SCLIB_LOCAL_CALL(sendfile, 4, out_dfd, in_dfd, offset, count);
+		}
+	} else {
+		ret = sclib_copy_file(in_dfd, offset, out_dfd, 0, count, in_sysid, out_sysid);
+	}
+
+	sclib_file_put(&sclib_file, in_fd);
+error_in_dfd:
+	sclib_file_put(&sclib_file, out_fd);
+error_out_dfd:
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
 #if ! defined __NR_sendfile64 && defined __UCLIBC_HAS_LFS__
 strong_alias(sendfile,sendfile64)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/setdomainname.c uClibc-0.9.33-new/libc/sysdeps/linux/common/setdomainname.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/setdomainname.c	2013-09-23 20:39:08.186221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/setdomainname.c	2013-09-23 20:39:32.958222861 -0400
@@ -3,12 +3,31 @@
  * setdomainname() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
 
 #include <sys/syscall.h>
 #include <unistd.h>
+#include <bits/sclib.h>
+
 #if defined __USE_BSD || (defined __USE_XOPEN && !defined __USE_UNIX98)
-_syscall2(int, setdomainname, const char *, name, size_t, len)
+
+int setdomainname(const char *name, size_t len)
+{
+	void *mem;
+	long ret;
+
+	mem = sclib_memory_alloc(&sclib_data[SYSCALL_SYSID_NETWORK], len);
+	SCLIB_MEM_RET(mem, ret);
+	mem = memcpy(mem, name, len);
+	ret = SCLIB_REMOTE_CALL(SYSCALL_SYSID_NETWORK, setdomainname, 2, sclib_mem(SYSCALL_SYSID_NETWORK, mem), len);
+	sclib_memory_free(&sclib_data[SYSCALL_SYSID_NETWORK], mem);
+
+error_mem:
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
+
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/setgid.c uClibc-0.9.33-new/libc/sysdeps/linux/common/setgid.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/setgid.c	2013-09-23 20:39:08.222221835 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/setgid.c	2013-09-23 20:39:32.958222861 -0400
@@ -3,6 +3,7 @@
  * setgid() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -10,6 +11,7 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 #include <bits/wordsize.h>
+#include <bits/sclib.h>
 
 #if (__WORDSIZE == 32 && defined(__NR_setgid32)) || __WORDSIZE == 64
 # ifdef __NR_setgid32
@@ -17,7 +19,12 @@
 #  define __NR_setgid __NR_setgid32
 # endif
 
-_syscall1(int, setgid, gid_t, gid)
+int setgid(gid_t gid)
+{
+	long ret = SCLIB_ALL_SIMPLE_CALL(setgid, 1, gid);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
 #else
 
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/setgroups.c uClibc-0.9.33-new/libc/sysdeps/linux/common/setgroups.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/setgroups.c	2013-09-23 20:39:08.170221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/setgroups.c	2013-09-23 20:39:32.958222861 -0400
@@ -3,6 +3,7 @@
  * setgroups() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -12,6 +13,8 @@
 #include <unistd.h>
 #include <grp.h>
 
+#include <bits/sclib.h>
+
 #ifdef __USE_BSD
 
 
@@ -21,7 +24,37 @@
 _syscall2(int, setgroups, size_t, size, const gid_t *, list)
 
 #elif __WORDSIZE == 64
-_syscall2(int, setgroups, size_t, size, const gid_t *, list)
+
+int setgroups(size_t size, const gid_t *list)
+{
+	gid_t *rlist[SYSCALL_SYSIDS], *cur;
+	syscall_entry_t *pos[SYSCALL_SYSIDS];
+	long ret, rret;
+	size_t sysid;
+
+	for (sysid = 0; sysid < SYSCALL_SYSIDS; sysid++) {
+		rlist[sysid] = (gid_t *) sclib_memory_alloc(&sclib_data[sysid],
+									size * sizeof(gid_t));
+		SCLIB_MEM_RET(rlist[sysid], ret);
+		cur = memcpy(rlist[sysid], list, size * sizeof(gid_t));
+		pos[sysid] = SCLIB_REMOTE_CALL_ASYNC(sysid, setgroups, 2, size,
+			sclib_mem(sysid, cur));
+	}
+
+	ret = SCLIB_LOCAL_CALL(setgroups, 2, size, list);
+
+error_mem:
+	while (sysid != 0) {
+		sysid--;
+		rret = SCLIB_REMOTE_CALL_RESULT(sysid, setgroups, pos[sysid]);
+		if (SCLIB_IS_ERR(rret))
+			ret = rret;
+		sclib_memory_free(&sclib_data[sysid], rlist[sysid]);
+	}
+
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
 #else
 
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/sethostname.c uClibc-0.9.33-new/libc/sysdeps/linux/common/sethostname.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/sethostname.c	2013-09-23 20:39:08.218221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/sethostname.c	2013-09-23 20:39:32.958222861 -0400
@@ -3,12 +3,31 @@
  * sethostname() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
 
 #include <sys/syscall.h>
 #include <unistd.h>
+#include <bits/sclib.h>
+
 #if defined __USE_BSD || (defined __USE_XOPEN && !defined __USE_UNIX98)
-_syscall2(int, sethostname, const char *, name, size_t, len)
+
+int sethostname(const char *name, size_t len)
+{
+	void *mem;
+	long ret;
+
+	mem = sclib_memory_alloc(&sclib_data[SYSCALL_SYSID_NETWORK], len);
+	SCLIB_MEM_RET(mem, ret);
+	mem = memcpy(mem, name, len);
+	ret = SCLIB_REMOTE_CALL(SYSCALL_SYSID_NETWORK, sethostname, 2, sclib_mem(SYSCALL_SYSID_NETWORK, mem), len);
+	sclib_memory_free(&sclib_data[SYSCALL_SYSID_NETWORK], mem);
+
+error_mem:
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
+
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/setregid.c uClibc-0.9.33-new/libc/sysdeps/linux/common/setregid.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/setregid.c	2013-09-23 20:39:08.278221837 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/setregid.c	2013-09-23 20:39:32.958222861 -0400
@@ -3,6 +3,7 @@
  * setregid() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -10,7 +11,7 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 #include <bits/wordsize.h>
-
+#include <bits/sclib.h>
 
 #if (__WORDSIZE == 32 && defined(__NR_setregid32)) || __WORDSIZE == 64
 # ifdef __NR_setregid32
@@ -18,7 +19,12 @@
 #  define __NR_setregid __NR_setregid32
 # endif
 
-_syscall2(int, setregid, gid_t, rgid, gid_t, egid)
+int setregid(gid_t rgid, gid_t egid)
+{
+	long ret = SCLIB_ALL_SIMPLE_CALL(setregid, 2, rgid, egid);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
 #else
 
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/setresgid.c uClibc-0.9.33-new/libc/sysdeps/linux/common/setresgid.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/setresgid.c	2013-09-23 20:39:08.182221833 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/setresgid.c	2013-09-23 20:39:32.958222861 -0400
@@ -3,6 +3,7 @@
  * setresgid() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -11,6 +12,8 @@
 #ifdef __USE_GNU
 #include <unistd.h>
 
+#include <bits/sclib.h>
+
 #if defined(__NR_setresgid32)
 # undef __NR_setresgid
 # define __NR_setresgid __NR_setresgid32
@@ -20,9 +23,13 @@
 
 #elif defined(__NR_setresgid)
 
-# define __NR___syscall_setresgid __NR_setresgid
-static __inline__ _syscall3(int, __syscall_setresgid,
-		__kernel_gid_t, rgid, __kernel_gid_t, egid, __kernel_gid_t, sgid)
+static __inline__ int __syscall_setresgid(__kernel_gid_t rgid,
+	__kernel_gid_t egid, __kernel_gid_t sgid)
+{
+	long ret = SCLIB_ALL_SIMPLE_CALL(setresgid, 3, rgid, egid, sgid);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
 int setresgid(gid_t rgid, gid_t egid, gid_t sgid)
 {
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/setresuid.c uClibc-0.9.33-new/libc/sysdeps/linux/common/setresuid.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/setresuid.c	2013-09-23 20:39:08.178221833 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/setresuid.c	2013-09-23 20:39:32.958222861 -0400
@@ -3,6 +3,7 @@
  * setresuid() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -11,6 +12,8 @@
 #if defined __USE_GNU && defined __UCLIBC_LINUX_SPECIFIC__
 #include <unistd.h>
 
+#include <bits/sclib.h>
+
 #if defined(__NR_setresuid32)
 # undef __NR_setresuid
 # define __NR_setresuid __NR_setresuid32
@@ -20,9 +23,13 @@
 
 #elif defined(__NR_setresuid)
 
-# define __NR___syscall_setresuid __NR_setresuid
-static __inline__ _syscall3(int, __syscall_setresuid,
-		__kernel_uid_t, rgid, __kernel_uid_t, egid, __kernel_uid_t, sgid)
+static __inline__ int __syscall_setresuid(__kernel_uid_t ruid,
+	__kernel_uid_t euid, __kernel_uid_t suid)
+{
+	long ret = SCLIB_ALL_SIMPLE_CALL(setresuid, 3, ruid, euid, suid);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
 int setresuid(uid_t ruid, uid_t euid, uid_t suid)
 {
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/setreuid.c uClibc-0.9.33-new/libc/sysdeps/linux/common/setreuid.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/setreuid.c	2013-09-23 20:39:08.278221837 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/setreuid.c	2013-09-23 20:39:32.958222861 -0400
@@ -3,6 +3,7 @@
  * setreuid() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -10,7 +11,7 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 #include <bits/wordsize.h>
-
+#include <bits/sclib.h>
 
 #if (__WORDSIZE == 32 && defined(__NR_setreuid32)) || __WORDSIZE == 64
 # ifdef __NR_setreuid32
@@ -18,7 +19,12 @@
 #  define __NR_setreuid __NR_setreuid32
 # endif
 
-_syscall2(int, setreuid, uid_t, ruid, uid_t, euid)
+int setreuid(uid_t ruid, uid_t euid)
+{
+	long ret = SCLIB_ALL_SIMPLE_CALL(setreuid, 2, ruid, euid);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
 #else
 
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/setuid.c uClibc-0.9.33-new/libc/sysdeps/linux/common/setuid.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/setuid.c	2013-09-23 20:39:08.230221837 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/setuid.c	2013-09-23 20:39:32.958222861 -0400
@@ -3,6 +3,7 @@
  * setuid() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -10,6 +11,7 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 #include <bits/wordsize.h>
+#include <bits/sclib.h>
 
 #if (__WORDSIZE == 32 && defined(__NR_setuid32)) || __WORDSIZE == 64
 # ifdef __NR_setuid32
@@ -17,7 +19,12 @@
 #  define __NR_setuid __NR_setuid32
 # endif
 
-_syscall1(int, setuid, uid_t, uid)
+int setuid(uid_t uid)
+{
+	long ret = SCLIB_ALL_SIMPLE_CALL(setuid, 1, uid);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
 #else
 
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/signalfd.c uClibc-0.9.33-new/libc/sysdeps/linux/common/signalfd.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/signalfd.c	2013-09-23 20:39:08.218221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/signalfd.c	2013-09-23 20:39:32.958222861 -0400
@@ -3,6 +3,7 @@
  * signalfd() for uClibc
  *
  * Copyright (C) 2008 Bernhard Reutner-Fischer <uclibc@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -11,22 +12,69 @@
 #include <signal.h>
 #include <sys/signalfd.h>
 
+#include <bits/sclib.h>
+
 #if defined __NR_signalfd4
-#define __NR___syscall_signalfd4 __NR_signalfd4
-static __inline__ _syscall4(int, __syscall_signalfd4, int, fd,
-		const sigset_t *, mask, size_t, sizemask, int, flags)
+static __inline__ int __syscall_signalfd4(long fd, const sigset_t *mask, size_t sizemask, int flags)
+{
+	long lfd;
+
+	if (fd == -1) {
+		fd = sclib_file_add(&sclib_file, 0);
+		SCLIB_ERR_RET(fd);
+		lfd = SCLIB_LOCAL_CALL(signalfd, 4, -1, mask, sizemask, flags);
+		if (SCLIB_IS_ERR(lfd)) {
+			sclib_file_add_fail(&sclib_file, fd);
+		} else {
+			uint8_t lfd_flags = 0;
+			if (flags & SFD_CLOEXEC)
+				lfd_flags |= SCLIB_FD_EXEC;
+			sclib_file_add_ok(&sclib_file, fd, lfd, SYSCALL_SYSID_LOCAL, lfd_flags, 0);
+		}
+	} else {
+		lfd = sclib_file_get(&sclib_file, fd, SYSCALL_SYSID_LOCAL);
+		SCLIB_ERR_RET(lfd);
+		sclib_write_lock_fd_flags(&sclib_file, fd);
+		lfd = SCLIB_LOCAL_CALL(signalfd, 4, lfd, mask, sizemask, flags);
+		if (!SCLIB_IS_ERR(lfd)) {
+			if (flags & SFD_CLOEXEC)
+				sclib_file.fds[fd].flags |= SCLIB_FD_EXEC;
+			else
+				sclib_file.fds[fd].flags &= ~SCLIB_FD_EXEC;
+		}
+		sclib_write_unlock_fd_flags(&sclib_file, fd);
+		sclib_file_put(&sclib_file, fd);
+	}
+	SCLIB_ERR_RET(lfd);
+	return fd;
+}
 #elif defined __NR_signalfd
-#define __NR___syscall_signalfd __NR_signalfd
-static __inline__ _syscall3(int, __syscall_signalfd, int, fd,
-		const sigset_t *, mask, size_t, sizemask)
+static __inline__ int __syscall_signalfd(long fd, const sigset_t *mask, size_t sizemask)
+{
+	long dfd;
+
+	if (fd == -1) {
+		fd = sclib_file_add(&sclib_file, 0);
+		SCLIB_ERR_RET(fd);
+		lfd = SCLIB_LOCAL_CALL(signalfd, 3, -1, mask, sizemask);
+		sclib_file_add_done(&sclib_file, fd, lfd, SYSCALL_SYSID_LOCAL, 0, 0);
+	} else {
+		lfd = sclib_file_get(&sclib_file, fd, SYSCALL_SYSID_LOCAL);
+		SCLIB_ERR_RET(lfd);
+		lfd = SCLIB_LOCAL_CALL(signalfd, 3, lfd, mask, sizemask);
+		sclib_file_put(&sclib_file, fd);
+	}
+	SCLIB_ERR_RET(lfd);
+	return fd;
+}
 #endif
 
 #if defined __NR_signalfd4 || defined __NR_signalfd
 int signalfd (int fd, const sigset_t *mask, int flags)
 {
-#if defined __NR___syscall_signalfd4
+#if defined __NR_signalfd4
 	return __syscall_signalfd4(fd, mask, _NSIG / 8, flags);
-#elif defined __NR___syscall_signalfd
+#elif defined __NR_signalfd
 	if (flags != 0) {
 		__set_errno(EINVAL);
 		return -1;
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/sigprocmask.c uClibc-0.9.33-new/libc/sysdeps/linux/common/sigprocmask.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/sigprocmask.c	2013-09-23 20:39:08.174221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/sigprocmask.c	2013-09-23 20:39:32.958222861 -0400
@@ -23,7 +23,7 @@
 _syscall4(int, __rt_sigprocmask, int, how, const sigset_t *, set,
 		  sigset_t *, oldset, size_t, size)
 
-int sigprocmask(int how, const sigset_t * set, sigset_t * oldset)
+int weak_function sigprocmask(int how, const sigset_t * set, sigset_t * oldset)
 {
 #ifdef SIGCANCEL
 	sigset_t local_newmask;
@@ -58,7 +58,7 @@
 _syscall3(int, __syscall_sigprocmask, int, how, const sigset_t *, set,
 		  sigset_t *, oldset)
 
-int sigprocmask(int how, const sigset_t * set, sigset_t * oldset)
+int weak_function sigprocmask(int how, const sigset_t * set, sigset_t * oldset)
 {
 #ifdef SIGCANCEL
 	sigset_t local_newmask;
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/splice.c uClibc-0.9.33-new/libc/sysdeps/linux/common/splice.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/splice.c	2013-09-23 20:39:08.186221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/splice.c	2013-09-23 20:39:32.958222861 -0400
@@ -3,6 +3,7 @@
  * splice() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -10,7 +11,49 @@
 #include <sys/syscall.h>
 #include <fcntl.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_splice
-_syscall6(ssize_t, splice, int, __fdin, __off64_t *, __offin, int, __fdout,
-	__off64_t *, __offout, size_t, __len, unsigned int, __flags)
+ssize_t splice(int in_fd, __off64_t *in_off, int out_fd, __off64_t *out_off,
+	size_t count, unsigned int flags)
+{
+	int out_sysid, in_sysid;
+	long ret, out_dfd, in_dfd;
+
+	out_dfd = sclib_file_getid(&sclib_file, out_fd, &out_sysid);
+	if (SCLIB_IS_ERR(out_dfd)) {
+		ret = out_dfd;
+		goto error_out_dfd;
+	}
+	in_dfd = sclib_file_getid(&sclib_file, in_fd, &in_sysid);
+	if (SCLIB_IS_ERR(in_dfd)) {
+		ret = in_dfd;
+		goto error_in_dfd;
+	}
+
+	if (out_sysid == in_sysid) {
+		if (out_sysid != SYSCALL_SYSID_LOCAL) {
+			ret = SCLIB_REMOTE_CALL(out_sysid, splice, 6, in_dfd, in_off ? *in_off : -1L, out_dfd, out_off ? *out_off : -1L, count, flags);
+			if (!SCLIB_IS_ERR(ret)) {
+				if (in_off)
+					*in_off += (unsigned long) ret;
+				if (out_off)
+					*out_off += (unsigned long) ret;
+			}
+		} else {
+			ret = SCLIB_LOCAL_CALL(splice, 6, in_dfd, in_off, out_dfd, out_off,
+								   count, flags);
+		}
+	} else {
+		/* Flags seem to be implementation defined, so ignore them for now */
+		ret = sclib_copy64_file(in_dfd, in_off, out_dfd, out_off, count, in_sysid, out_sysid);
+	}
+
+	sclib_file_put(&sclib_file, in_fd);
+error_in_dfd:
+	sclib_file_put(&sclib_file, out_fd);
+error_out_dfd:
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/stat.c uClibc-0.9.33-new/libc/sysdeps/linux/common/stat.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/stat.c	2013-09-23 20:39:08.270221839 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/stat.c	2013-09-23 20:39:32.962222861 -0400
@@ -3,6 +3,7 @@
  * stat() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -12,21 +13,35 @@
 #include <sys/stat.h>
 #include "xstatconv.h"
 
-#define __NR___syscall_stat __NR_stat
-#undef stat
-static __inline__ _syscall2(int, __syscall_stat,
-		const char *, file_name, struct kernel_stat *, buf)
+#include <bits/sclib.h>
 
 int stat(const char *file_name, struct stat *buf)
 {
-	int result;
 	struct kernel_stat kbuf;
+	char abspath[PATH_MAX], *dpath;
+	long ret;
+	int sysid;
+	void *rbuf, *off;
+	size_t sz;
 
-	result = __syscall_stat(file_name, &kbuf);
-	if (result == 0) {
-		__xstat_conv(&kbuf, buf);
+    dpath = sclib_get_path(abspath, file_name, &sysid, &sz);
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		rbuf = sclib_memory_alloc(&sclib_data[sysid], sizeof(struct kernel_stat) + sz);
+		SCLIB_MEM_RET(rbuf, ret);
+		memcpy(rbuf + sizeof(struct kernel_stat), dpath, sz);
+		off = sclib_mem(sysid, rbuf);
+		ret = SCLIB_REMOTE_CALL(sysid, stat, 2, off + sizeof(struct kernel_stat), off);
+		if (ret == 0)
+			__xstat_conv(rbuf, buf);
+		sclib_memory_free(&sclib_data[sysid], rbuf);
+	} else {
+		ret = SCLIB_LOCAL_CALL(stat, 2, dpath, &kbuf);
+		if (ret == 0)
+			__xstat_conv(&kbuf, buf);
 	}
-	return result;
+error_mem:
+	SCLIB_ERR_RET(ret);
+	return ret;
 }
 libc_hidden_def(stat)
 
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/statfs.c uClibc-0.9.33-new/libc/sysdeps/linux/common/statfs.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/statfs.c	2013-09-23 20:39:08.226221836 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/statfs.c	2013-09-23 20:39:32.962222861 -0400
@@ -12,9 +12,14 @@
 #include <sys/param.h>
 #include <sys/vfs.h>
 
+#include <bits/sclib.h>
+
 extern __typeof(statfs) __libc_statfs attribute_hidden;
-#define __NR___libc_statfs __NR_statfs
-_syscall2(int, __libc_statfs, const char *, path, struct statfs *, buf)
+
+int __libc_statfs(const char *path, struct statfs *buf)
+{
+	return SCLIB_PATH_OUTBUF_CALL(statfs, sizeof(struct statfs), 2, path, buf);
+}
 
 #if defined __UCLIBC_LINUX_SPECIFIC__ || defined __UCLIBC_HAS_THREADS_NATIVE__
 /* statfs is used by NPTL, so it must exported in case */
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/symlinkat.c uClibc-0.9.33-new/libc/sysdeps/linux/common/symlinkat.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/symlinkat.c	2013-09-23 20:39:08.218221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/symlinkat.c	2013-09-23 20:39:32.962222861 -0400
@@ -2,6 +2,7 @@
  * symlinkat() for uClibc
  *
  * Copyright (C) 2009 Analog Devices Inc.
+ * Copyright (C) 2012-2013 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -9,8 +10,54 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_symlinkat
-_syscall3(int, symlinkat, const char *, from, int, tofd, const char *, to)
+int symlinkat(const char *from, int tofd, const char *to)
+{
+	const char *__dpath = (const char *) to, *__dlink;
+	char __abspath[PATH_MAX];
+	void *__rbuf = __rbuf, *__off;
+	size_t __sz2, __sz1;
+	int __sysid, __sysid1;
+	long __ret, __dfd;
+	if (tofd == AT_FDCWD) {
+		__dpath = sclib_get_path(__abspath, __dpath ? __dpath : "", &__sysid, &__sz2);
+		__dfd = -1;
+	} else if (__dpath && *__dpath == '/') {
+		__dpath = sclib_get_path(__abspath, __dpath, &__sysid, &__sz2);
+		__dfd = -1;
+	} else {
+		__sz2 = __dpath ? (strlen(__dpath) + 1) : 0;
+		__dfd = sclib_file_getid(&sclib_file, tofd, &__sysid);
+		SCLIB_ERR_RET(__dfd);
+	}
+	__dlink = sclib_get_link(from, &__sysid1);
+	if (__sysid1 != SYSCALL_SYSID_ALL && __sysid != __sysid1) {
+		__ret = -EINVAL;
+		goto error_mem;
+	}
+	if (__sysid != SYSCALL_SYSID_LOCAL) {
+		__sz1 = strlen(__dlink) + 1;
+		__off = NULL;
+		if (__sz1 + __sz2 != 0) {
+			__rbuf = sclib_memory_alloc(&sclib_data[__sysid], __sz1 + __sz2);
+			SCLIB_MEM_RET(__rbuf, __ret);
+			memcpy(mempcpy(__rbuf, __dlink, __sz1), __dpath, __sz2);
+			__off = sclib_mem(__sysid, __rbuf);
+		}
+		__ret = SCLIB_REMOTE_CALL(__sysid, symlinkat, 3, __off, __dfd, __sz2 ? (__off + __sz1) : NULL);
+		if (__sz1 + __sz2 != 0)
+			sclib_memory_free(&sclib_data[__sysid], __rbuf);
+	} else {
+		__ret = SCLIB_LOCAL_CALL(symlinkat, 3, __dlink, __dfd, __dpath);
+	}
+error_mem:
+	if (__dfd >= 0)
+		sclib_file_put(&sclib_file, tofd);
+	SCLIB_ERR_RET(__ret);
+	return __ret;
+}
 #else
 /* should add emulation with symlink() and /proc/self/fd/ ... */
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/symlink.c uClibc-0.9.33-new/libc/sysdeps/linux/common/symlink.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/symlink.c	2013-09-23 20:39:08.226221836 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/symlink.c	2013-09-23 20:39:32.962222861 -0400
@@ -3,6 +3,7 @@
  * symlink() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012-2013 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -10,5 +11,36 @@
 #include <sys/syscall.h>
 #if defined __USE_BSD || defined __USE_UNIX98 || defined __USE_XOPEN2K
 #include <unistd.h>
-_syscall2(int, symlink, const char *, oldpath, const char *, newpath)
+
+#include <bits/sclib.h>
+
+int symlink(const char *oldpath, const char *newpath)
+{
+	const char *__dlink;
+	char __abspath[PATH_MAX], *__dpath;
+	long __ret;
+	int __sysid, __sysid2;
+	void *__rbuf, *__off;
+	size_t __sz2, __sz1;
+	__dpath = sclib_get_path(__abspath, newpath, &__sysid, &__sz1);
+	__dlink = sclib_get_link(oldpath, &__sysid2);
+	if (__sysid2 != SYSCALL_SYSID_ALL && __sysid != __sysid2) {
+		__ret = -EINVAL;
+		goto error_mem;
+	}
+	if (__sysid != SYSCALL_SYSID_LOCAL) {
+		__sz2 = strlen(__dlink) + 1;
+		__rbuf = sclib_memory_alloc(&sclib_data[__sysid], __sz1 + __sz2);
+		SCLIB_MEM_RET(__rbuf, __ret);
+		memcpy(mempcpy(__rbuf, __dpath, __sz1), __dlink, __sz2);
+		__off = sclib_mem(__sysid, __rbuf);
+		__ret = SCLIB_REMOTE_CALL(__sysid, symlink, 2, __off + __sz1, __off);
+		sclib_memory_free(&sclib_data[__sysid], __rbuf);
+	} else {
+		__ret = SCLIB_LOCAL_CALL(symlink, 2, __dlink, __dpath);
+	}
+error_mem:
+	SCLIB_ERR_RET(__ret);
+	return __ret;
+}
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/__syscall_fcntl.c uClibc-0.9.33-new/libc/sysdeps/linux/common/__syscall_fcntl.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/__syscall_fcntl.c	2013-09-23 20:39:08.178221833 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/__syscall_fcntl.c	2013-09-23 20:39:32.962222861 -0400
@@ -4,6 +4,7 @@
  *
  * Copyright (C) 2006 Steven J. Hill <sjhill@realitydiluted.com>
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -16,6 +17,163 @@
 #include <fcntl.h>
 #include <bits/wordsize.h>
 
+#include <string.h>
+
+#include <bits/sclib.h>
+
+static long __syscall_dup(long fd, long cmd, unsigned long start_fd)
+{
+	int sysid;
+	long dup_fd, dup_dfd, dfd;
+
+	dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+	SCLIB_ERR_RET(dfd);
+	dup_fd = sclib_file_add(&sclib_file, start_fd);
+	SCLIB_VAL_RET(dup_fd, dup_dfd);
+
+	__sync_fetch_and_or(&sclib_file.fds[fd].ectl_doms, 0xFF);
+
+	switch (sysid)
+	{
+	default:
+		dup_dfd = SCLIB_REMOTE_CALL(sysid, fcntl, 3, dfd, cmd, 0);
+		break;
+
+	case SYSCALL_SYSID_LOCAL:
+		dup_dfd = SCLIB_LOCAL_CALL(fcntl, 3, dfd, cmd, 0);
+		break;
+
+	case SYSCALL_SYSID_ALL:
+	{
+		sclib_fd_t *aux, *dup_aux;
+		size_t n, i;
+
+		aux = sclib_file_aux(&sclib_file, fd);
+		dup_aux = sclib_file_aux(&sclib_file, dup_fd);
+		for (n = 0; n < SYSCALL_SYSIDS; n++) {
+			dup_aux[n] = SCLIB_REMOTE_CALL(n, fcntl, 3, aux[n], cmd, 0);
+			if (SCLIB_IS_ERR(dup_aux[n])) {
+				dup_dfd = dup_aux[n];
+				goto error_aux;
+			}
+		}
+		dup_dfd = SCLIB_LOCAL_CALL(fcntl, 3, dfd, cmd, 0);
+		if (SCLIB_IS_ERR(dup_dfd)) {
+error_aux:
+			for (i = 0; i < n; i++)
+				SCLIB_REMOTE_CALL(i, close, 1, dup_aux[i]);
+		}
+		break;
+	}
+	}
+
+	if (SCLIB_IS_ERR(dup_dfd)) {
+		sclib_file_add_fail(&sclib_file, dup_fd);
+	} else {
+		uint8_t dup_dfd_flags = 0;
+		if (cmd == F_DUPFD_CLOEXEC)
+			dup_dfd_flags |= SCLIB_FD_EXEC;
+		sclib_file_add_ok(&sclib_file, dup_fd, dup_dfd, sysid, dup_dfd_flags, 0xFF);
+	}
+
+error_val:
+	sclib_file_put(&sclib_file, fd);	
+	SCLIB_ERR_RET(dup_dfd);
+	return dup_fd;
+}
+
+static long __syscall_fcntl(long fd, long cmd, void *arg)
+{
+	int sysid;
+	long dfd, ret;
+
+	/* Use a different mechanism for dup operations */
+	if (cmd == F_DUPFD || cmd == F_DUPFD_CLOEXEC)
+		return __syscall_dup(fd, cmd, (unsigned long) arg);
+
+	dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+	SCLIB_ERR_RET(dfd);
+
+	if (cmd == F_SETFD)
+		sclib_write_lock_fd_flags(&sclib_file, fd);
+
+	switch (sysid)
+	{
+	default:
+	{
+		void *mem = NULL;
+		void *rarg = arg;
+		unsigned dir;
+		size_t size;
+
+		sclib_fcntl_decode(cmd, &dir, &size);
+		if (size > 0) {
+			mem = sclib_memory_alloc(&sclib_data[sysid], size);
+			SCLIB_MEM_RET(mem, ret);
+			if (dir & _IOC_WRITE)
+				mem = memcpy(mem, arg, size);
+			rarg = sclib_mem(sysid, mem);
+		}
+		ret = SCLIB_REMOTE_CALL(sysid, fcntl, 3, dfd, cmd, rarg);
+		if (mem) {
+			if ((dir & _IOC_READ) && !SCLIB_IS_ERR(ret))
+				memcpy(arg, mem, size);
+			sclib_memory_free(&sclib_data[sysid], mem);
+		}
+		break;
+	}
+
+	case SYSCALL_SYSID_LOCAL:
+		ret = SCLIB_LOCAL_CALL(fcntl, 3, dfd, cmd, arg);
+		break;
+
+	case SYSCALL_SYSID_ALL:
+	{
+		sclib_fd_t *aux = sclib_file_aux(&sclib_file, fd);
+		void *mem = mem;
+		void *rarg = arg;
+		unsigned dir;
+		size_t n, size;
+
+		sclib_fcntl_decode(cmd, &dir, &size);
+		for (n = 0; n < SYSCALL_SYSIDS; n++) {
+			if (size > 0) {
+				mem = sclib_memory_alloc(&sclib_data[n], size);
+				SCLIB_MEM_RET(mem, ret);
+				if (dir & _IOC_WRITE)
+					mem = memcpy(mem, arg, size);
+				rarg = sclib_mem(n, mem);
+			}
+			ret = SCLIB_REMOTE_CALL(n, fcntl, 3, aux[n], cmd, rarg);
+			if (size > 0) {
+				if ((dir & _IOC_READ) && !SCLIB_IS_ERR(ret))
+					memcpy(arg, mem, size);
+				sclib_memory_free(&sclib_data[n], mem);
+			}
+			if (SCLIB_IS_ERR(ret))
+				goto error_mem;
+		}
+		ret = SCLIB_LOCAL_CALL(fcntl, 3, dfd, cmd, arg);
+		break;
+	}
+	}
+
+error_mem:
+	if (cmd == F_SETFD) {
+		if (!SCLIB_IS_ERR(ret)) {
+			if ((long) arg & FD_CLOEXEC)
+				sclib_file.fds[fd].flags |= SCLIB_FD_EXEC;
+			else
+				sclib_file.fds[fd].flags &= ~SCLIB_FD_EXEC;
+		}
+		sclib_write_unlock_fd_flags(&sclib_file, fd);
+	}
+	sclib_file_put(&sclib_file, fd);
+
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
+
 extern __typeof(fcntl) __libc_fcntl;
 libc_hidden_proto(__libc_fcntl)
 
@@ -38,7 +196,7 @@
 #  endif
 	}
 # endif
-	return INLINE_SYSCALL (fcntl, 3, fd, cmd, arg);
+	return __syscall_fcntl(fd, cmd, arg);
 }
 libc_hidden_def(__fcntl_nocancel)
 
@@ -56,7 +214,7 @@
 # if defined __UCLIBC_HAS_LFS__ && defined __NR_fcntl64
 		return INLINE_SYSCALL (fcntl64, 3, fd, cmd, arg);
 # else
-		return INLINE_SYSCALL (fcntl, 3, fd, cmd, arg);
+		return __syscall_fcntl(fd, cmd, arg);
 # endif
 
 	int oldtype = LIBC_CANCEL_ASYNC ();
@@ -64,7 +222,7 @@
 # if defined __UCLIBC_HAS_LFS__ && defined __NR_fcntl64
 	int result = INLINE_SYSCALL (fcntl64, 3, fd, cmd, arg);
 # else
-	int result = INLINE_SYSCALL (fcntl, 3, fd, cmd, arg);
+	int result = __syscall_fcntl(fd, cmd, arg);
 # endif
 
 	LIBC_CANCEL_RESET (oldtype);
@@ -81,7 +239,7 @@
 #  endif
 	}
 # endif
-	return INLINE_SYSCALL (fcntl, 3, fd, cmd, arg);
+	return __syscall_fcntl(fd, cmd, arg);
 #endif
 }
 libc_hidden_def(__libc_fcntl)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/tee.c uClibc-0.9.33-new/libc/sysdeps/linux/common/tee.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/tee.c	2013-09-23 20:39:08.186221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/tee.c	2013-09-23 20:39:32.962222861 -0400
@@ -10,7 +10,11 @@
 #include <sys/syscall.h>
 #include <fcntl.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_tee
-_syscall4(ssize_t, tee, int, __fdin, int, __fdout, size_t, __len,
-	unsigned int, __flags)
+ssize_t tee(int fdin, int fdout, size_t len, unsigned int flags)
+{
+	return SCLIB_LFD_SYSCALL2(tee, 4, fdin, fdout, len, flags);
+}
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/truncate64.c uClibc-0.9.33-new/libc/sysdeps/linux/common/truncate64.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/truncate64.c	2013-09-23 20:39:08.270221839 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/truncate64.c	2013-09-23 20:39:32.962222861 -0400
@@ -25,7 +25,10 @@
 #if __WORDSIZE == 64
 
 /* For a 64 bit machine, life is simple... */
-_syscall2(int, truncate64, const char *, path, __off64_t, length)
+int truncate64(const char *path, __off64_t length)
+{
+	return SCLIB_PATH_CALL(truncate64, 2, path, length);
+}
 
 #elif __WORDSIZE == 32
 
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/truncate.c uClibc-0.9.33-new/libc/sysdeps/linux/common/truncate.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/truncate.c	2013-09-23 20:39:08.222221835 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/truncate.c	2013-09-23 20:39:32.962222861 -0400
@@ -10,6 +10,11 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
+#include <bits/sclib.h>
+
+int truncate(const char *path, __off_t length)
+{
+	return SCLIB_PATH_CALL(truncate, 2, path, length);
+}
 
-_syscall2(int, truncate, const char *, path, __off_t, length)
 libc_hidden_def(truncate)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/uname.c uClibc-0.9.33-new/libc/sysdeps/linux/common/uname.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/uname.c	2013-09-23 20:39:08.174221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/uname.c	2013-09-23 20:39:32.962222861 -0400
@@ -3,13 +3,37 @@
  * uname() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
 
 #include <sys/syscall.h>
 #include <sys/utsname.h>
+#include <bits/sclib.h>
 
+int uname(struct utsname *buf)
+{
+	struct utsname *rbuf;
+	syscall_entry_t *pos;
+	long ret, rret;
+
+	rbuf = (struct utsname *) sclib_memory_alloc(&sclib_data[SYSCALL_SYSID_NETWORK], sizeof(struct utsname));
+	SCLIB_MEM_RET(rbuf, ret);
+	pos = SCLIB_REMOTE_CALL_ASYNC(SYSCALL_SYSID_NETWORK, uname, 1, sclib_mem(SYSCALL_SYSID_NETWORK, rbuf));
+	ret = SCLIB_LOCAL_CALL(uname, 1, buf);
+	rret = SCLIB_REMOTE_CALL_RESULT(SYSCALL_SYSID_NETWORK, uname, pos);
+	if (SCLIB_IS_ERR(rret)) {
+		ret = rret;
+	} else {
+		memcpy(buf->nodename, rbuf->nodename, sizeof(rbuf->nodename));
+		memcpy(buf->domainname, rbuf->domainname, sizeof(rbuf->domainname));
+	}
+	sclib_memory_free(&sclib_data[SYSCALL_SYSID_NETWORK], rbuf);
+
+error_mem:
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
-_syscall1(int, uname, struct utsname *, buf)
 libc_hidden_def(uname)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/unlinkat.c uClibc-0.9.33-new/libc/sysdeps/linux/common/unlinkat.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/unlinkat.c	2013-09-23 20:39:08.218221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/unlinkat.c	2013-09-23 20:39:32.962222861 -0400
@@ -9,8 +9,13 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_unlinkat
-_syscall3(int, unlinkat, int, fd, const char *, file, int, flag)
+int unlinkat(int fd, const char *file, int flag)
+{
+	return SCLIB_DFD_SYSCALL_AT(unlinkat, 3, fd, file, flag);
+}
 #else
 /* should add emulation with unlink() and /proc/self/fd/ ... */
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/unlink.c uClibc-0.9.33-new/libc/sysdeps/linux/common/unlink.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/unlink.c	2013-09-23 20:39:08.174221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/unlink.c	2013-09-23 20:39:32.962222861 -0400
@@ -10,6 +10,11 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
+#include <bits/sclib.h>
+
+int unlink(const char *pathname)
+{
+	return SCLIB_PATH_CALL(unlink, 1, pathname);
+}
 
-_syscall1(int, unlink, const char *, pathname)
 libc_hidden_def(unlink)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/utime.c uClibc-0.9.33-new/libc/sysdeps/linux/common/utime.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/utime.c	2013-09-23 20:39:08.270221839 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/utime.c	2013-09-23 20:39:32.962222861 -0400
@@ -10,9 +10,13 @@
 #include <sys/syscall.h>
 #include <utime.h>
 
+#include <bits/sclib.h>
 
 #ifdef __NR_utime
-_syscall2(int, utime, const char *, file, const struct utimbuf *, times)
+int utime(const char *file, const struct utimbuf *times)
+{
+	return SCLIB_PATH_INBUF_CALL(utime, sizeof(struct utimbuf), 2, file, times);
+}
 #else
 #include <stdlib.h>
 #include <sys/time.h>
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/utimensat.c uClibc-0.9.33-new/libc/sysdeps/linux/common/utimensat.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/utimensat.c	2013-09-23 20:39:08.222221835 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/utimensat.c	2013-09-23 20:39:32.962222861 -0400
@@ -9,8 +9,13 @@
 #include <sys/syscall.h>
 #include <sys/stat.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_utimensat
-_syscall4(int, utimensat, int, fd, const char *, path, const struct timespec *, times, int, flags)
+int utimensat(int fd, const char *path, const struct timespec *times, int flags)
+{
+	return SCLIB_DFD_INBUF_SYSCALL_AT(utimensat, sizeof(struct timespec) * 2, 4, fd, path, times, flags);
+}
 libc_hidden_def(utimensat)
 #else
 /* should add emulation with utimens() and /proc/self/fd/ ... */
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/utimes.c uClibc-0.9.33-new/libc/sysdeps/linux/common/utimes.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/utimes.c	2013-09-23 20:39:08.266221839 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/utimes.c	2013-09-23 20:39:32.962222861 -0400
@@ -11,9 +11,13 @@
 #include <utime.h>
 #include <sys/time.h>
 
+#include <bits/sclib.h>
 
 #ifdef __NR_utimes
-_syscall2(int, utimes, const char *, file, const struct timeval *, tvp)
+int utimes(const char *file, const struct timeval *tvp)
+{
+	return SCLIB_PATH_INBUF_CALL(utimes, sizeof(struct timeval) * 2, 2, file, tvp);
+}
 #else
 #include <stdlib.h>
 
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/vfork.c uClibc-0.9.33-new/libc/sysdeps/linux/common/vfork.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/vfork.c	2013-09-23 20:39:08.278221837 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/vfork.c	2013-09-23 20:39:32.962222861 -0400
@@ -10,7 +10,7 @@
 
 extern __typeof(vfork) __vfork attribute_hidden;
 
-#ifdef __NR_vfork
+#if 0 /* Use normal fork() for sclib */
 
 # define __NR___vfork __NR_vfork
 _syscall0(pid_t, __vfork)
@@ -18,7 +18,7 @@
 weak_alias(__vfork,vfork)
 libc_hidden_weak(vfork)
 
-#elif defined __ARCH_USE_MMU__ && defined __NR_fork
+#else
 
 /* Trivial implementation for arches that lack vfork */
 
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/vmsplice.c uClibc-0.9.33-new/libc/sysdeps/linux/common/vmsplice.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/vmsplice.c	2013-09-23 20:39:08.222221835 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/vmsplice.c	2013-09-23 20:39:32.962222861 -0400
@@ -3,6 +3,7 @@
  * vmsplice() for uClibc
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -10,7 +11,11 @@
 #include <sys/syscall.h>
 #include <fcntl.h>
 
+#include <bits/sclib.h>
+
 #ifdef __NR_vmsplice
-_syscall4(ssize_t, vmsplice, int, __fdout, const struct iovec *, __iov,
-	size_t, __count, unsigned int, __flags)
+ssize_t vmsplice(int fd, const struct iovec *iov, size_t count, unsigned int flags)
+{
+	return SCLIB_LFD_SYSCALL(vmsplice, 4, fd, iov, count, flags);
+}
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/write.c uClibc-0.9.33-new/libc/sysdeps/linux/common/write.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/write.c	2013-09-23 20:39:08.194221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/write.c	2013-09-23 20:39:32.962222861 -0400
@@ -2,6 +2,7 @@
 /*
  * write() for uClibc
  *
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
@@ -10,7 +11,16 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
-_syscall3(ssize_t, write, int, fd, const __ptr_t, buf, size_t, count)
+#include <bits/sclib.h>
+#include <bits/sclib_syscalls.h>
+
+ssize_t write(int fd, const void *buf, size_t count)
+{
+	ssize_t ret = __internal_sys_write(fd, buf, count);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
+
 #ifndef __LINUXTHREADS_OLD__
 libc_hidden_def(write)
 #else
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/writev.c uClibc-0.9.33-new/libc/sysdeps/linux/common/writev.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/writev.c	2013-09-23 20:39:08.278221837 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/writev.c	2013-09-23 20:39:32.962222861 -0400
@@ -2,6 +2,7 @@
 /*
  * writev() for uClibc
  *
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
@@ -10,6 +11,55 @@
 #include <sys/syscall.h>
 #include <sys/uio.h>
 
+#include <bits/sclib.h>
+
+static __inline__ ssize_t __syscall_writev(int fd, const struct iovec *iov, int iovcnt)
+{
+	int sysid;
+	size_t size;
+	long dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	SCLIB_ERR_RET(dfd);
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		struct sclib_iovc iovc;
+		size_t ret, chunk, count = sclib_iovec_length(iov, iovcnt);
+		void *rbuf, *mem;
+
+		SCLIB_VAL2_RET(count, size);
+		chunk = MIN(count, SCLIB_MAX_BUFFER);
+		mem = sclib_memory_alloc(&sclib_data[sysid], chunk);
+		SCLIB_MEM_RET(mem, size);
+		size = 0;
+		iovc.iovc_iov = iov;
+		iovc.iovc_off = 0;
+		rbuf = sclib_mem(sysid, mem);
+
+		for (; count > chunk; count -= chunk) {
+			sclib_copy_from_iovec(mem, &iovc, chunk);
+			ret = SCLIB_REMOTE_CALL(sysid, write, 3, dfd, rbuf, chunk);
+			SCLIB_VAL_RET(ret, size);
+			size += ret;
+			if (unlikely(ret < chunk))
+				goto error_val;
+		}
+		sclib_copy_from_iovec(mem, &iovc, count);
+		ret = SCLIB_REMOTE_CALL(sysid, write, 3, dfd, rbuf, count);
+		SCLIB_VAL_RET(ret, size);
+		size += ret;
+
+error_val:
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		size = SCLIB_LOCAL_CALL(writev, 3, dfd, iov, iovcnt);
+	}
+
+error_val2:
+error_mem:
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(size);
+	return size;
+}
+
 #ifdef __UCLIBC_HAS_THREADS_NATIVE__
 #include <errno.h>
 #include <sysdep-cancel.h>
@@ -20,7 +70,7 @@
 {
   ssize_t bytes_written;
 
-  bytes_written = INLINE_SYSCALL (writev, 3, fd, vector, count);
+  bytes_written = __syscall_writev (fd, vector, count);
 
   if (bytes_written >= 0 || errno != EINVAL || count <= UIO_FASTIOV)
     return bytes_written;
@@ -45,6 +95,8 @@
   return result;
 }
 #else
-_syscall3(ssize_t, writev, int, filedes, const struct iovec *, vector,
-		  int, count)
+ssize_t writev(int fd, const struct iovec *vector, int count)
+{
+  return __syscall_writev (fd, vector, count);
+}
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/common/xattr.c uClibc-0.9.33-new/libc/sysdeps/linux/common/xattr.c
--- uClibc-0.9.33/libc/sysdeps/linux/common/xattr.c	2013-09-23 20:39:08.218221834 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/common/xattr.c	2013-09-23 20:39:32.962222861 -0400
@@ -25,6 +25,8 @@
 #include <unistd.h>
 #include <sys/xattr.h>
 
+#include <bits/sclib.h>
+
 /* sets */
 #ifdef __NR_setxattr
 _syscall5(int, setxattr, const char *, path, const char *, name,
@@ -37,8 +39,10 @@
 #endif
 
 #ifdef __NR_fsetxattr
-_syscall5(int, fsetxattr, int, filedes, const char *, name, const void *,
-	value, size_t, size, int, flags)
+int fsetxattr(int filedes, const char *name, const void *value, size_t size, int flags)
+{
+	return SCLIB_DFD_STR_INBUF_SYSCALL(fsetxattr, strlen(name) + 1, size, 5, filedes, name, value, size, flags);
+}
 #endif
 
 /* gets */
@@ -53,8 +57,12 @@
 #endif
 
 #ifdef __NR_fgetxattr
-_syscall4(ssize_t, fgetxattr, int, filedes, const char *, name, void *,
-	value, size_t, size)
+ssize_t fgetxattr(int filedes, const char *name, void *value, size_t size)
+{
+	if (size > SCLIB_MAX_BUFFER)
+		size = SCLIB_MAX_BUFFER;
+	return SCLIB_DFD_STR_OUTBUF_SYSCALL(fgetxattr, strlen(name) + 1, size, 4, filedes, name, value, size);
+}
 #endif
 
 /* list */
@@ -69,18 +77,32 @@
 #endif
 
 #ifdef __NR_flistxattr
-_syscall3(ssize_t, flistxattr, int, filedes, char *, list, size_t, size)
+ssize_t flistxattr(int filedes, char *list, size_t size)
+{
+	if (size > SCLIB_MAX_BUFFER)
+		size = SCLIB_MAX_BUFFER;
+	return SCLIB_DFD_OUTBUF_SYSCALL(flistxattr, size, 3, filedes, list, size);
+}
 #endif
 
 /* remove */
 #ifdef __NR_removexattr
-_syscall2(int, removexattr, const char *, path, const char *, name)
+int removexattr(const char *path, const char *name)
+{
+	return SCLIB_PATH_INBUF_CALL(removexattr, strlen(name) + 1, 2, path, name);
+}
 #endif
 
 #ifdef __NR_lremovexattr
-_syscall2(int, lremovexattr, const char *, path, const char *, name)
+int lremovexattr(const char *path, const char *name)
+{
+	return SCLIB_PATH_INBUF_CALL(lremovexattr, strlen(name) + 1, 2, path, name);
+}
 #endif
 
 #ifdef __NR_fremovexattr
-_syscall2(int, fremovexattr, int, filedes, const char *, name)
+int fremovexattr(int filedes, const char *name)
+{
+	return SCLIB_DFD_INBUF_SYSCALL(fremovexattr, strlen(name) + 1, 2, filedes, name);
+}
 #endif
diff -urN uClibc-0.9.33/libc/sysdeps/linux/x86_64/clone.S uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/clone.S
--- uClibc-0.9.33/libc/sysdeps/linux/x86_64/clone.S	2013-09-23 20:39:08.582221851 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/clone.S	2013-09-23 20:39:32.962222861 -0400
@@ -1,4 +1,5 @@
 /* Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,9 +24,15 @@
 #define _ERRNO_H 1
 #include <bits/errno.h>
 #include <sys/syscall.h>
+#include <sysdep.h>
 
 #define CLONE_VM	0x00000100
 #define CLONE_THREAD	0x00010000
+#define CLONE_VFORK		0x00004000
+
+#ifndef __CLONE_CALL
+# define __CLONE_CALL(x) HIDDEN_JUMPTARGET(x)
+#endif
 
 /* The userland implementation is:
    int clone (int (*fn)(void *arg), void *child_stack, int flags, void *arg),
@@ -61,27 +68,70 @@
 	testq	%rsi,%rsi		/* no NULL stack pointers */
 	jz	__syscall_error
 
+	andl	$~CLONE_VFORK,%edx	/* ignore this flag, treat as fork() */
+
 	/* Insert the argument onto the new stack.  */
+#ifdef CLONE_NOWRAPPER
 	subq	$16,%rsi
 	movq	%rcx,8(%rsi)
+#else
+	subq	$24,%rsi
+	movq	%rcx,16(%rsi)
+#endif
 
 	/* Save the function pointer.  It will be popped off in the
 	   child in the ebx frobbing below.  */
+#ifdef CLONE_NOWRAPPER
 	movq	%rdi,0(%rsi)
 
 	/* Do the system call.  */
 	movq	%rdx, %rdi
 	movq	%r8, %rdx
 	movq	%r9, %r8
+
+	movq	8(%rsp), %r10
+#else
+	movq	%rdi,8(%rsi)
+
+	pushq	%rsi
+	pushq	%rdx
+	pushq	%r8
+	pushq	%r9
+
+	movq	%rdx,%rdi
+	call	__CLONE_CALL(__internal_sys_clone_begin)
+	testq	%rax,%rax
+
+	popq	%r8
+	popq	%rdx
+	popq	%rdi
+	popq	%rsi
+	jl	__syscall_error
+
 	movq	8(%rsp), %r10
+
+	/* Keep the return value from sclib_clone_begin */
+	movq	%rax,0(%rsi)		/* child */
+	pushq	%rax				/* parent */
+
+	/* Do the system call.  */
+#endif
 	movl	$__NR_clone,%eax
 
 	syscall
 
 	testq	%rax,%rax
-	jl	__syscall_error
 	jz	.Lthread_start
 
+#ifndef CLONE_NOWRAPPER
+	popq	%rsi
+
+	movq	%rax,%rdi
+	call	__CLONE_CALL(__internal_sys_clone_parent)
+	testq	%rax,%rax
+#endif
+	jl	__syscall_error
+
 .Lpseudo_end:
 	ret
 
@@ -103,6 +153,11 @@
 1:
 #endif
 
+#ifndef CLONE_NOWRAPPER
+	popq	%rdi		/* Restore the value */
+	call	__CLONE_CALL(__internal_sys_clone_child)
+#endif
+
 	/* Set up arguments for the function call.  */
 	popq	%rax		/* Function to call.  */
 	popq	%rdi		/* Argument.  */
diff -urN uClibc-0.9.33/libc/sysdeps/linux/x86_64/getcontext.S uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/getcontext.S
--- uClibc-0.9.33/libc/sysdeps/linux/x86_64/getcontext.S	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/getcontext.S	2013-09-23 20:39:32.962222861 -0400
@@ -0,0 +1,95 @@
+/* Save current context.
+   Copyright (C) 2002-2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sys/syscall.h>
+#include <sysdep.h>
+
+#include "ucontext_i.h"
+
+/*  int __getcontext (ucontext_t *ucp)
+
+  Saves the machine context in UCP such that when it is activated,
+  it appears as if __getcontext() returned again.
+
+  This implementation is intended to be used for *synchronous* context
+  switches only.  Therefore, it does not have to save anything
+  other than the PRESERVED state.  */
+
+.text
+.global __getcontext
+.hidden __getcontext
+.type   __getcontext,%function
+
+__getcontext:
+	/* Save the preserved registers, the registers used for passing
+	   args, and the return address.  */
+	movq	%rbx, oRBX(%rdi)
+	movq	%rbp, oRBP(%rdi)
+	movq	%r12, oR12(%rdi)
+	movq	%r13, oR13(%rdi)
+	movq	%r14, oR14(%rdi)
+	movq	%r15, oR15(%rdi)
+
+	movq	%rdi, oRDI(%rdi)
+	movq	%rsi, oRSI(%rdi)
+	movq	%rdx, oRDX(%rdi)
+	movq	%rcx, oRCX(%rdi)
+	movq	%r8, oR8(%rdi)
+	movq	%r9, oR9(%rdi)
+
+	movq	(%rsp), %rcx
+	movq	%rcx, oRIP(%rdi)
+	leaq	8(%rsp), %rcx		/* Exclude the return address.  */
+	movq	%rcx, oRSP(%rdi)
+
+	/* We have separate floating-point register content memory on the
+	   stack.  We use the __fpregs_mem block in the context.  Set the
+	   links up correctly.  */
+
+	leaq	oFPREGSMEM(%rdi), %rcx
+	movq	%rcx, oFPREGS(%rdi)
+	/* Save the floating-point environment.  */
+	fnstenv	(%rcx)
+	fldenv	(%rcx)
+	stmxcsr oMXCSR(%rdi)
+
+	/* Save the current signal mask with
+	   rt_sigprocmask (SIG_BLOCK, NULL, set,_NSIG/8).  */
+	leaq	oSIGMASK(%rdi), %rdx
+	xorl	%esi,%esi
+#if SIG_BLOCK == 0
+	xorl	%edi, %edi
+#else
+	movl	$SIG_BLOCK, %edi
+#endif
+	movl	$_NSIG8,%r10d
+	movl	$__NR_rt_sigprocmask, %eax
+	syscall
+	cmpq	$-4095, %rax		/* Check %rax for error.  */
+	jae	__syscall_error	/* Jump to error handler if error.  */
+
+	/* All done, return 0 for success.  */
+	xorl	%eax, %eax
+	ret
+
+.size __getcontext,.-__getcontext
+
+weak_alias(__getcontext,getcontext)
+libc_hidden_weak(getcontext)
+
diff -urN uClibc-0.9.33/libc/sysdeps/linux/x86_64/makecontext.c uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/makecontext.c
--- uClibc-0.9.33/libc/sysdeps/linux/x86_64/makecontext.c	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/makecontext.c	2013-09-23 20:39:32.962222861 -0400
@@ -0,0 +1,121 @@
+/* Create new context.
+   Copyright (C) 2002, 2004, 2005, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <stdarg.h>
+#include <stdint.h>
+#include <ucontext.h>
+
+#include "ucontext_i.h"
+
+/* This implementation can handle any ARGC value but only
+   normal integer parameters.
+   makecontext sets up a stack and the registers for the
+   user context. The stack looks like this:
+               +-----------------------+
+               | next context          |
+               +-----------------------+
+               | parameter 7-n         |
+	       +-----------------------+
+	       | trampoline address    |
+    %rsp ->    +-----------------------+
+
+   The registers are set up like this:
+     %rdi,%rsi,%rdx,%rcx,%r8,%r9: parameter 1 to 6
+     %rbx   : address of next context
+     %rsp   : stack pointer.
+*/
+
+/* XXX: This implementation currently only handles integer arguments.
+   To handle long int and pointer arguments the va_arg arguments needs
+   to be changed to long and also the stdlib/tst-setcontext.c file needs
+   to be changed to pass long arguments to makecontext.  */
+
+
+extern void __start_context (void);
+
+static void
+__makecontext (ucontext_t *ucp, void (*func) (void), int argc, ...)
+{
+  greg_t *sp;
+  unsigned int idx_uc_link;
+  va_list ap;
+  int i;
+
+  /* Generate room on stack for parameter if needed and uc_link.  */
+  sp = (greg_t *) ((uintptr_t) ucp->uc_stack.ss_sp
+		   + ucp->uc_stack.ss_size);
+  sp -= (argc > 6 ? argc - 6 : 0) + 1;
+  /* Align stack and make space for trampoline address.  */
+  sp = (greg_t *) ((((uintptr_t) sp) & -16L) - 8);
+
+  idx_uc_link = (argc > 6 ? argc - 6 : 0) + 1;
+
+  /* Setup context ucp.  */
+  /* Address to jump to.  */
+  ucp->uc_mcontext.gregs[REG_RIP] = (uintptr_t) func;
+  /* Setup rbx.*/
+  ucp->uc_mcontext.gregs[REG_RBX] = (uintptr_t) &sp[idx_uc_link];
+  ucp->uc_mcontext.gregs[REG_RSP] = (uintptr_t) sp;
+
+  /* Setup stack.  */
+  sp[0] = (uintptr_t) &__start_context;
+  sp[idx_uc_link] = (uintptr_t) ucp->uc_link;
+
+  va_start (ap, argc);
+  /* Handle arguments.
+
+     The standard says the parameters must all be int values.  This is
+     an historic accident and would be done differently today.  For
+     x86-64 all integer values are passed as 64-bit values and
+     therefore extending the API to copy 64-bit values instead of
+     32-bit ints makes sense.  It does not break existing
+     functionality and it does not violate the standard which says
+     that passing non-int values means undefined behavior.  */
+  for (i = 0; i < argc; ++i)
+    switch (i)
+      {
+      case 0:
+	ucp->uc_mcontext.gregs[REG_RDI] = va_arg (ap, greg_t);
+	break;
+      case 1:
+	ucp->uc_mcontext.gregs[REG_RSI] = va_arg (ap, greg_t);
+	break;
+      case 2:
+	ucp->uc_mcontext.gregs[REG_RDX] = va_arg (ap, greg_t);
+	break;
+      case 3:
+	ucp->uc_mcontext.gregs[REG_RCX] = va_arg (ap, greg_t);
+	break;
+      case 4:
+	ucp->uc_mcontext.gregs[REG_R8] = va_arg (ap, greg_t);
+	break;
+      case 5:
+	ucp->uc_mcontext.gregs[REG_R9] = va_arg (ap, greg_t);
+	break;
+      default:
+	/* Put value on stack.  */
+	sp[i - 5] = va_arg (ap, greg_t);
+	break;
+      }
+  va_end (ap);
+
+}
+
+weak_alias (__makecontext, makecontext)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/x86_64/Makefile.arch uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/Makefile.arch
--- uClibc-0.9.33/libc/sysdeps/linux/x86_64/Makefile.arch	2013-09-23 20:39:08.582221851 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/Makefile.arch	2013-09-23 20:39:32.962222861 -0400
@@ -5,10 +5,10 @@
 # Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
 #
 
-CSRC := brk.c __syscall_error.c sigaction.c mmap.c
+CSRC := brk.c __syscall_error.c pread_write.c sigaction.c mmap.c makecontext.c swapcontext.c
 
 SSRC := \
-	__longjmp.S setjmp.S syscall.S bsd-setjmp.S bsd-_setjmp.S
+	__longjmp.S setjmp.S syscall.S bsd-setjmp.S bsd-_setjmp.S swapcontextp.S setcontext.S getcontext.S __start_context.S
 
 ifneq ($(UCLIBC_HAS_THREADS_NATIVE),y)
 SSRC += vfork.S clone.S
diff -urN uClibc-0.9.33/libc/sysdeps/linux/x86_64/mmap.c uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/mmap.c
--- uClibc-0.9.33/libc/sysdeps/linux/x86_64/mmap.c	2013-09-23 20:39:08.598221852 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/mmap.c	2013-09-23 20:39:32.962222861 -0400
@@ -4,6 +4,7 @@
  *
  * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
  * Copyright (C) 2005 by Mike Frysinger <vapier@gentoo.org>
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
  *
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
@@ -13,7 +14,23 @@
 #include <sys/mman.h>
 #include <sys/syscall.h>
 
+#include <bits/sclib.h>
+
+void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)
+{
+	long ret, lfd = -1;
+
+	if (!(flags & MAP_ANONYMOUS)) {
+		lfd = sclib_file_get(&sclib_file, fd, SYSCALL_SYSID_LOCAL);
+		if (SCLIB_IS_ERR(lfd)) {
+			__set_errno(-lfd);
+			return (void *) -1;
+		}
+	}
+	ret = INLINE_SYSCALL(mmap, 6, addr, length, prot, flags, lfd, offset);
+	if (!(flags & MAP_ANONYMOUS))
+		sclib_file_put(&sclib_file, fd);
+	return (void *) ret;
+}
 
-_syscall6(void *, mmap, void *, start, size_t, length, int, prot,
-          int, flags, int, fd, off_t, offset)
 libc_hidden_def(mmap)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/x86_64/pread_write.c uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/pread_write.c
--- uClibc-0.9.33/libc/sysdeps/linux/x86_64/pread_write.c	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/pread_write.c	2013-09-23 20:39:32.962222861 -0400
@@ -0,0 +1,157 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
+ * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+/*
+ * Based in part on the files
+ *		./sysdeps/unix/sysv/linux/pwrite.c,
+ *		./sysdeps/unix/sysv/linux/pread.c,
+ *		sysdeps/posix/pread.c
+ *		sysdeps/posix/pwrite.c
+ * from GNU libc 2.2.5, but reworked considerably...
+ */
+
+/* Seems to be missing in original uClibc 0.9.33 distribution for some reason.
+   This version is similar and based on MIPS version.
+
+   Ruslan Nikolaev */
+
+#include <sys/syscall.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <endian.h>
+
+extern __typeof(pread) __libc_pread;
+extern __typeof(pwrite) __libc_pwrite;
+#ifdef __UCLIBC_HAS_LFS__
+extern __typeof(pread64) __libc_pread64;
+extern __typeof(pwrite64) __libc_pwrite64;
+#endif
+
+#include <bits/kernel_types.h>
+#include <bits/sclib.h>
+
+#ifdef __NR_pread64
+
+static __inline__ ssize_t __syscall_pread(int fd, void *buf, size_t count,
+	off64_t offset)
+{
+	int sysid;
+	size_t size;
+	long dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	SCLIB_ERR_RET(dfd);
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		size_t ret, chunk = MIN(count, SCLIB_MAX_BUFFER);
+		void *rbuf, *mem = sclib_memory_alloc(&sclib_data[sysid], chunk);
+
+		SCLIB_MEM_RET(mem, size);
+		size = 0;
+		rbuf = sclib_mem(sysid, mem);
+
+		for (; count > chunk; count -= chunk) {
+			ret = SCLIB_REMOTE_CALL(sysid, pread64, 4, dfd, rbuf, chunk, offset);
+			SCLIB_VAL_RET(ret, size);
+			size += ret;
+			offset += ret;
+			buf = mempcpy(buf, mem, ret);
+			if (unlikely(ret < chunk))
+				goto error_val;
+		}
+		ret = SCLIB_REMOTE_CALL(sysid, pread64, 4, dfd, rbuf, count, offset);
+		SCLIB_VAL_RET(ret, size);
+		size += ret;
+		memcpy(buf, mem, ret);
+
+error_val:
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		size = SCLIB_LOCAL_CALL(pread64, 4, dfd, buf, count, offset);
+	}
+
+error_mem:
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(size);
+	return size;
+}
+
+ssize_t __libc_pread(int fd, void *buf, size_t count, off_t offset)
+{
+	return __syscall_pread(fd, buf, count, offset);
+}
+weak_alias (__libc_pread, pread)
+# ifdef __UCLIBC_HAS_LFS__
+ssize_t __libc_pread64(int fd, void *buf, size_t count, off64_t offset)
+{
+	return __syscall_pread(fd, buf, count, offset);
+}
+weak_alias (__libc_pread64, pread64)
+# endif /* __UCLIBC_HAS_LFS__ */
+
+#endif /* __NR_pread */
+
+/**********************************************************************/
+
+
+#ifdef __NR_pwrite64
+
+static __inline__ ssize_t __syscall_pwrite(int fd, const void *buf,
+	size_t count, off64_t offset)
+{
+	int sysid;
+	size_t size;
+	long dfd = sclib_file_getid(&sclib_file, fd, &sysid);
+
+	SCLIB_ERR_RET(dfd);
+	if (sysid != SYSCALL_SYSID_LOCAL) {
+		size_t ret, chunk = MIN(count, SCLIB_MAX_BUFFER);
+		void *rbuf, *mem = sclib_memory_alloc(&sclib_data[sysid], chunk);
+
+		SCLIB_MEM_RET(mem, size);
+		size = 0;
+		rbuf = sclib_mem(sysid, mem);
+
+		for (; count > chunk; count -= chunk) {
+			memcpy(mem, buf, chunk);
+			buf += chunk;
+			ret = SCLIB_REMOTE_CALL(sysid, pwrite64, 4, dfd, rbuf, chunk, offset);
+			SCLIB_VAL_RET(ret, size);
+			size += ret;
+			offset += ret;
+			if (unlikely(ret < chunk))
+				goto error_val;
+		}
+		memcpy(mem, buf, count);
+		ret = SCLIB_REMOTE_CALL(sysid, pwrite64, 4, dfd, rbuf, count, offset);
+		SCLIB_VAL_RET(ret, size);
+		size += ret;
+
+error_val:
+		sclib_memory_free(&sclib_data[sysid], mem);
+	} else {
+		size = SCLIB_LOCAL_CALL(pwrite64, 4, dfd, buf, count, offset);
+	}
+
+error_mem:
+	sclib_file_put(&sclib_file, fd);
+	SCLIB_ERR_RET(size);
+	return size;
+}
+
+ssize_t __libc_pwrite(int fd, const void *buf, size_t count, off_t offset)
+{
+	return __syscall_pwrite(fd, buf, count, offset);
+}
+weak_alias (__libc_pwrite, pwrite)
+# ifdef __UCLIBC_HAS_LFS__
+ssize_t __libc_pwrite64(int fd, const void *buf, size_t count, off64_t offset)
+{
+	return __syscall_pwrite(fd, buf, count, offset);
+}
+weak_alias (__libc_pwrite64, pwrite64)
+# endif /* __UCLIBC_HAS_LFS__  */
+
+#endif /* __NR_pwrite */
diff -urN uClibc-0.9.33/libc/sysdeps/linux/x86_64/sched_getcpu.S uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/sched_getcpu.S
--- uClibc-0.9.33/libc/sysdeps/linux/x86_64/sched_getcpu.S	2013-09-23 20:39:08.598221852 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/sched_getcpu.S	2013-09-23 20:39:32.966222861 -0400
@@ -34,7 +34,7 @@
 	movq	%rsp, %rdi
 	xorl	%esi, %esi
 	movl	$VGETCPU_CACHE_OFFSET, %edx
-	addq	%fs:0, %rdx
+	addq	%fs:CURRENT_TLS, %rdx
 
 #ifdef SHARED
 	movq	__vdso_getcpu(%rip), %rax
diff -urN uClibc-0.9.33/libc/sysdeps/linux/x86_64/setcontext.S uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/setcontext.S
--- uClibc-0.9.33/libc/sysdeps/linux/x86_64/setcontext.S	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/setcontext.S	2013-09-23 20:39:32.966222861 -0400
@@ -0,0 +1,110 @@
+/* Install given context.
+   Copyright (C) 2002-2012 Free Software Foundation, Inc.
+   Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sys/syscall.h>
+#include <sysdep.h>
+
+#include "ucontext_i.h"
+
+
+/*  int __setcontext (const ucontext_t *ucp)
+
+  Restores the machine context in UCP and thereby resumes execution
+  in that context.
+
+  This implementation is intended to be used for *synchronous* context
+  switches only.  Therefore, it does not have to restore anything
+  other than the PRESERVED state.  */
+
+.text
+.global __setcontext
+.hidden __setcontext
+.type   __setcontext,%function
+
+.global __setcontextp
+.hidden __setcontextp
+.type   __setcontextp,%function
+
+__setcontextp:
+	movq	oSIGMASK(%rdi),%rdx
+	cmpq	%rdx,oSIGMASK(%rsi) /* Same mask (likely) */
+	je		1f
+
+__setcontext:
+	/* Save argument since syscall will destroy it.  */
+	pushq	%rdi
+
+	/* Set the signal mask with
+	   rt_sigprocmask (SIG_SETMASK, mask, NULL, _NSIG/8).  */
+	leaq	oSIGMASK(%rdi), %rsi
+	xorl	%edx, %edx
+	movl	$SIG_SETMASK, %edi
+	movl	$_NSIG8,%r10d
+	movl	$__NR_rt_sigprocmask, %eax
+	syscall
+	popq	%rdi			/* Reload %rdi, adjust stack.  */
+
+	cmpq	$-4095, %rax		/* Check %rax for error.  */
+	jae	__syscall_error	/* Jump to error handler if error.  */
+
+1:
+	/* Restore the floating-point context.  Not the registers, only the
+	   rest.  */
+	movq	oFPREGS(%rdi), %rcx
+	fldenv	(%rcx)
+	ldmxcsr oMXCSR(%rdi)
+
+
+	/* Load the new stack pointer, the preserved registers and
+	   registers used for passing args.  */
+
+	movq	oRSP(%rdi), %rsp
+	movq	oRBX(%rdi), %rbx
+	movq	oRBP(%rdi), %rbp
+	movq	oR12(%rdi), %r12
+	movq	oR13(%rdi), %r13
+	movq	oR14(%rdi), %r14
+	movq	oR15(%rdi), %r15
+
+	/* The following ret should return to the address set with
+	getcontext.  Therefore push the address on the stack.  */
+	movq	oRIP(%rdi), %rcx
+	pushq	%rcx
+
+	movq	oRSI(%rdi), %rsi
+	movq	oRDX(%rdi), %rdx
+	movq	oRCX(%rdi), %rcx
+	movq	oR8(%rdi), %r8
+	movq	oR9(%rdi), %r9
+
+	/* Setup finally  %rdi.  */
+	movq	oRDI(%rdi), %rdi
+
+	/* Clear rax to indicate NULL-pointer or success.  */
+	xorl	%eax, %eax
+	ret
+.size __setcontext,.-__setcontext
+.size __setcontextp,.-__setcontextp
+
+weak_alias(__setcontext,setcontext)
+libc_hidden_weak(setcontext)
+
+weak_alias(__setcontextp,setcontextp)
+libc_hidden_weak(setcontextp)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/x86_64/__start_context.S uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/__start_context.S
--- uClibc-0.9.33/libc/sysdeps/linux/x86_64/__start_context.S	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/__start_context.S	2013-09-23 20:39:32.966222861 -0400
@@ -0,0 +1,55 @@
+/* Copyright (C) 2002-2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+/* This is the helper code which gets called if a function which is
+   registered with 'makecontext' returns.  In this case we have to
+   install the context listed in the uc_link element of the context
+   'makecontext' manipulated at the time of the 'makecontext' call.
+   If the pointer is NULL the process must terminate.  */
+
+.text
+.global __start_context
+.hidden __start_context
+.type   __start_context,%function
+
+__start_context:
+	/* This removes the parameters passed to the function given to
+	   'makecontext' from the stack.  RBX contains the address
+	   on the stack pointer for the next context.  */
+	movq	%rbx, %rsp
+
+	popq	%rdi			/* This is the next context.  */
+
+	testq	%rdi, %rdi
+	je	2f			/* If it is zero exit.  */
+
+	call	JUMPTARGET(__setcontext)
+	/* If this returns (which can happen if the syscall fails) we'll
+	   exit the program with the return error value (-1).  */
+	movq	%rax,%rdi
+
+2:
+	call	HIDDEN_JUMPTARGET(exit)
+	/* The 'exit' call should never return.  In case it does cause
+	   the process to terminate.  */
+	hlt
+.size __start_context,.-__start_context
+
+libc_hidden_weak(__start_context)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/x86_64/swapcontext.c uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/swapcontext.c
--- uClibc-0.9.33/libc/sysdeps/linux/x86_64/swapcontext.c	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/swapcontext.c	2013-09-23 20:39:32.966222861 -0400
@@ -0,0 +1,12 @@
+#include <sysdep.h>
+#include <stdarg.h>
+#include <stdint.h>
+#include <ucontext.h>
+
+static int
+__swapcontext (ucontext_t *oucp, const ucontext_t *ucp)
+{
+  return -((long) swapcontextp (oucp, ucp) == -1L);
+}
+
+weak_alias (__swapcontext, swapcontext)
diff -urN uClibc-0.9.33/libc/sysdeps/linux/x86_64/swapcontextp.S uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/swapcontextp.S
--- uClibc-0.9.33/libc/sysdeps/linux/x86_64/swapcontextp.S	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/swapcontextp.S	2013-09-23 20:39:32.966222861 -0400
@@ -0,0 +1,134 @@
+/* Save current context and install the given one.
+   Copyright (C) 2002-2012 Free Software Foundation, Inc.
+   Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sys/syscall.h>
+#include <sysdep.h>
+
+#include "ucontext_i.h"
+
+
+/* ucontext_t *__swapcontextp (ucontext_t *oucp, const ucontext_t *ucp);
+
+  Saves the machine context in oucp such that when it is activated,
+  it appears as if __swapcontextpt() returned again, restores the
+  machine context in ucp and thereby resumes execution in that
+  context.
+
+  This implementation is intended to be used for *synchronous* context
+  switches only.  Therefore, it does not have to save anything
+  other than the PRESERVED state.  */
+
+.text
+.global __swapcontextp
+.hidden __swapcontextp
+.type   __swapcontextp,%function
+
+__swapcontextp:
+	/* Save the preserved registers, the registers used for passing args,
+	   and the return address.  */
+	movq	%rbx, oRBX(%rdi)
+	movq	%rbp, oRBP(%rdi)
+	movq	%r12, oR12(%rdi)
+	movq	%r13, oR13(%rdi)
+	movq	%r14, oR14(%rdi)
+	movq	%r15, oR15(%rdi)
+
+	movq	%rdi, oRDI(%rdi)
+	movq	%rsi, oRSI(%rdi)
+	movq	%rdx, oRDX(%rdi)
+	movq	%rcx, oRCX(%rdi)
+	movq	%r8, oR8(%rdi)
+	movq	%r9, oR9(%rdi)
+
+	movq	(%rsp), %rcx
+	movq	%rcx, oRIP(%rdi)
+	leaq	8(%rsp), %rcx		/* Exclude the return address.  */
+	movq	%rcx, oRSP(%rdi)
+
+	/* We have separate floating-point register content memory on the
+	   stack.  We use the __fpregs_mem block in the context.  Set the
+	   links up correctly.  */
+	leaq	oFPREGSMEM(%rdi), %rcx
+	movq	%rcx, oFPREGS(%rdi)
+	/* Save the floating-point environment.  */
+	fnstenv	(%rcx)
+	stmxcsr oMXCSR(%rdi)
+
+
+	/* The syscall destroys some registers, save them.  */
+	movq	%rsi, %r12
+	movq	%rdi, %r14
+
+	/* Save the current signal mask and install the new one with
+	   rt_sigprocmask (SIG_BLOCK, newset, oldset,_NSIG/8).  */
+	leaq	oSIGMASK(%rdi), %rdx
+	leaq	oSIGMASK(%rsi), %rsi
+	movq	(%rdx),%rdi
+	cmpq	%rdi,(%rsi)	/* Same mask (likely) */
+	je		1f
+	movl	$SIG_SETMASK, %edi
+	movl	$_NSIG8,%r10d
+	movl	$__NR_rt_sigprocmask, %eax
+	syscall
+	cmpq	$-4095, %rax		/* Check %rax for error.  */
+	jae	__syscall_error	/* Jump to error handler if error.  */
+
+1:
+	/* Restore destroyed registers.  */
+	movq	%r12, %rsi
+	movq	%r14, %rax
+
+	/* Restore the floating-point context.  Not the registers, only the
+	   rest.  */
+	movq	oFPREGS(%rsi), %rcx
+	fldenv	(%rcx)
+	ldmxcsr oMXCSR(%rsi)
+
+	/* Load the new stack pointer and the preserved registers.  */
+	movq	oRSP(%rsi), %rsp
+	movq	oRBX(%rsi), %rbx
+	movq	oRBP(%rsi), %rbp
+	movq	oR12(%rsi), %r12
+	movq	oR13(%rsi), %r13
+	movq	oR14(%rsi), %r14
+	movq	oR15(%rsi), %r15
+
+	/* The following ret should return to the address set with
+	getcontext.  Therefore push the address on the stack.  */
+	movq	oRIP(%rsi), %rcx
+	pushq	%rcx
+
+	/* Setup registers used for passing args.  */
+	movq	oRDI(%rsi), %rdi
+	movq	oRDX(%rsi), %rdx
+	movq	oRCX(%rsi), %rcx
+	movq	oR8(%rsi), %r8
+	movq	oR9(%rsi), %r9
+
+	/* Setup finally  %rsi.  */
+	movq	oRSI(%rsi), %rsi
+
+	ret
+
+.size __swapcontextp,.-__swapcontextp
+
+weak_alias(__swapcontextp,swapcontextp)
+libc_hidden_weak(swapcontextp)
+
diff -urN uClibc-0.9.33/libc/sysdeps/linux/x86_64/sysdep.h uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/sysdep.h
--- uClibc-0.9.33/libc/sysdeps/linux/x86_64/sysdep.h	2013-09-23 20:39:08.590221850 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/sysdep.h	2013-09-23 20:39:32.966222861 -0400
@@ -205,9 +205,10 @@
 #  define SYSCALL_ERROR_HANDLER			\
 0:						\
   movq SYSCALL_ERROR_ERRNO@GOTTPOFF(%rip), %rcx;\
+  addq %fs:CURRENT_TLS, %rcx; \
   xorl %edx, %edx;				\
   subq %rax, %rdx;				\
-  movl %edx, %fs:(%rcx);			\
+  movl %edx, (%rcx);			\
   orq $-1, %rax;				\
   jmp L(pseudo_end);
 # elif defined _LIBC_REENTRANT
@@ -288,6 +289,10 @@
 # define DOARGS_5 DOARGS_4
 # define DOARGS_6 DOARGS_5
 
+# undef DO_SCLIB_CALL
+# define DO_SCLIB_CALL(syscall_name, args)	\
+	call HIDDEN_JUMPTARGET(__internal_sys_##syscall_name);
+
 #endif	/* __ASSEMBLER__ */
 
 
diff -urN uClibc-0.9.33/libc/sysdeps/linux/x86_64/ucontext_i.h uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/ucontext_i.h
--- uClibc-0.9.33/libc/sysdeps/linux/x86_64/ucontext_i.h	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/ucontext_i.h	2013-09-23 20:39:32.966222861 -0400
@@ -0,0 +1,27 @@
+/* Generated by glibc's make */
+
+#define SIG_BLOCK 0
+#define SIG_SETMASK 2
+#define _NSIG8 8
+#define oRBP 120
+#define oRSP 160
+#define oRBX 128
+#define oR8 40
+#define oR9 48
+#define oR10 56
+#define oR11 64
+#define oR12 72
+#define oR13 80
+#define oR14 88
+#define oR15 96
+#define oRDI 104
+#define oRSI 112
+#define oRDX 136
+#define oRAX 144
+#define oRCX 152
+#define oRIP 168
+#define oEFL 176
+#define oFPREGS 224
+#define oSIGMASK 296
+#define oFPREGSMEM 424
+#define oMXCSR 448
diff -urN uClibc-0.9.33/libc/sysdeps/linux/x86_64/vfork.S uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/vfork.S
--- uClibc-0.9.33/libc/sysdeps/linux/x86_64/vfork.S	2013-09-23 20:39:08.582221851 -0400
+++ uClibc-0.9.33-new/libc/sysdeps/linux/x86_64/vfork.S	2013-09-23 20:39:32.966222861 -0400
@@ -1,4 +1,5 @@
-/* Copyright (C) 2001, 2002, 2004, 2008 Free Software Foundation, Inc.
+/* Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
+   Copyright (C) 2001, 2002, 2004, 2008 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -28,6 +29,10 @@
 # define __NR_vfork __NR_fork
 #endif
 
+#ifndef __VFORK_CALL
+# define __VFORK_CALL(x) HIDDEN_JUMPTARGET(x)
+#endif
+
 .text
 .global __vfork
 .hidden __vfork
@@ -35,24 +40,7 @@
 
 __vfork:
 
-	/* Pop the return PC value into RDI.  We need a register that
-	   is preserved by the syscall and that we're allowed to destroy. */
-	popq	%rdi
-
-#ifdef SAVE_PID
-	SAVE_PID
-#endif
-
-	/* Stuff the syscall number in RAX and enter into the kernel.  */
-	movl	$__NR_vfork, %eax
-	syscall
-
-	/* Push back the return PC.  */
-	pushq	%rdi
-
-#ifdef RESTORE_PID
-	RESTORE_PID
-#endif
+	call __VFORK_CALL(__internal_sys_fork)
 
 	cmpl	$-4095, %eax
 	jae __syscall_error		/* Branch forward if it failed.  */
diff -urN uClibc-0.9.33/libc/termios/tcdrain.c uClibc-0.9.33-new/libc/termios/tcdrain.c
--- uClibc-0.9.33/libc/termios/tcdrain.c	2013-09-23 20:39:07.738221816 -0400
+++ uClibc-0.9.33-new/libc/termios/tcdrain.c	2013-09-23 20:39:32.966222861 -0400
@@ -23,6 +23,8 @@
 #include <sysdep-cancel.h>
 #endif
 
+#include <bits/sclib.h>
+
 libc_hidden_proto(ioctl)
 
 extern __typeof(tcdrain) __libc_tcdrain;
@@ -32,12 +34,12 @@
 #ifdef __UCLIBC_HAS_THREADS_NATIVE__
 	if (SINGLE_THREAD_P)
 		/* With an argument of 1, TCSBRK for output to be drain.  */
-		return INLINE_SYSCALL (ioctl, 3, fd, TCSBRK, 1);
+		return SCLIB_LFD_SYSCALL (ioctl, 3, fd, TCSBRK, 1);
 
 	int oldtype = LIBC_CANCEL_ASYNC ();
 
 	/* With an argument of 1, TCSBRK for output to be drain.  */
-	int result = INLINE_SYSCALL (ioctl, 3, fd, TCSBRK, 1);
+	int result = SCLIB_LFD_SYSCALL (ioctl, 3, fd, TCSBRK, 1);
 
 	LIBC_CANCEL_RESET (oldtype);
 
diff -urN uClibc-0.9.33/libc/termios/tcgetattr.c uClibc-0.9.33-new/libc/termios/tcgetattr.c
--- uClibc-0.9.33/libc/termios/tcgetattr.c	2013-09-23 20:39:07.738221816 -0400
+++ uClibc-0.9.33-new/libc/termios/tcgetattr.c	2013-09-23 20:39:32.966222861 -0400
@@ -28,6 +28,7 @@
    kernel is not the same as we use in the libc.  Therefore we must
    translate it here.  */
 #include "kernel_termios.h"
+#include <bits/sclib.h>
 
 /* Put the state of FD into *TERMIOS_P.  */
 int tcgetattr (int fd, struct termios *termios_p)
@@ -36,6 +37,7 @@
     int retval;
 
     retval = ioctl (fd, TCGETS, &k_termios);
+
 	if(likely(retval == 0)) {
 		termios_p->c_iflag = k_termios.c_iflag;
 		termios_p->c_oflag = k_termios.c_oflag;
diff -urN uClibc-0.9.33/libc/unistd/daemon.c uClibc-0.9.33-new/libc/unistd/daemon.c
--- uClibc-0.9.33/libc/unistd/daemon.c	2013-09-23 20:39:07.750221816 -0400
+++ uClibc-0.9.33-new/libc/unistd/daemon.c	2013-09-23 20:39:32.966222861 -0400
@@ -63,7 +63,7 @@
 
 #if defined __USE_BSD || (defined __USE_XOPEN && !defined __USE_UNIX98)
 
-#ifndef __ARCH_USE_MMU__
+#if 0 /* Do not use it */
 #include <sys/syscall.h>
 #include <sched.h>
 /* use clone() to get fork() like behavior here -- we just want to disassociate
diff -urN uClibc-0.9.33/libpthread/linuxthreads/sysdeps/pthread/not-cancel.h uClibc-0.9.33-new/libpthread/linuxthreads/sysdeps/pthread/not-cancel.h
--- uClibc-0.9.33/libpthread/linuxthreads/sysdeps/pthread/not-cancel.h	2013-09-23 20:39:09.046221871 -0400
+++ uClibc-0.9.33-new/libpthread/linuxthreads/sysdeps/pthread/not-cancel.h	2013-09-23 20:39:32.966222861 -0400
@@ -21,53 +21,54 @@
 #include <sys/types.h>
 #include <sysdep.h>
 
+#include <bits/sclib.h>
+#include <bits/sclib_syscalls.h>
+
 /* Uncancelable open.  */
-#define open_not_cancel(name, flags, mode) \
-   INLINE_SYSCALL (open, 3, (const char *) (name), (flags), (mode))
-#define open_not_cancel_2(name, flags) \
-   INLINE_SYSCALL (open, 2, (const char *) (name), (flags))
-
-/* Uncancelable openat.  */
-#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
-extern int __openat_nocancel (int fd, const char *fname, int oflag,
-			      mode_t mode) attribute_hidden;
-extern int __openat64_nocancel (int fd, const char *fname, int oflag,
-				mode_t mode) attribute_hidden;
-#else
-# define __openat_nocancel(fd, fname, oflag, mode) \
-  openat (fd, fname, oflag, mode)
-# define __openat64_nocancel(fd, fname, oflag, mode) \
-  openat64 (fd, fname, oflag, mode)
-#endif
-
-#define openat_not_cancel(fd, fname, oflag, mode) \
-  __openat_nocancel (fd, fname, oflag, mode)
-#define openat_not_cancel_3(fd, fname, oflag) \
-  __openat_nocancel (fd, fname, oflag, 0)
-#define openat64_not_cancel(fd, fname, oflag, mode) \
-  __openat64_nocancel (fd, fname, oflag, mode)
-#define openat64_not_cancel_3(fd, fname, oflag) \
-  __openat64_nocancel (fd, fname, oflag, 0)
+static __always_inline int open_not_cancel(const char *name, int flags, mode_t mode)
+{
+	long ret = __internal_sys_open(name, flags, mode);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
+
+static __always_inline int open_not_cancel_2(const char *name, int flags)
+{
+	long ret = __internal_sys_open(name, flags, 0);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
 /* Uncancelable close.  */
-#define close_not_cancel(fd) \
-  INLINE_SYSCALL (close, 1, fd)
-#define close_not_cancel_no_status(fd) \
-  (void) ({ INTERNAL_SYSCALL_DECL (err);				      \
-	    INTERNAL_SYSCALL (close, err, 1, (fd)); })
+static __always_inline int close_not_cancel(int fd)
+{
+	long ret = __internal_sys_close(fd);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
+
+static __always_inline void close_not_cancel_no_status(int fd)
+{
+	__internal_sys_close(fd);
+}
 
 /* Uncancelable read.  */
-#define read_not_cancel(fd, buf, n) \
-  INLINE_SYSCALL (read, 3, (fd), (buf), (n))
+static __always_inline ssize_t read_not_cancel(int fd, void *buf, size_t n)
+{
+	return SCLIB_LFD_SYSCALL(read, 3, fd, buf, n);
+}
 
 /* Uncancelable write.  */
-#define write_not_cancel(fd, buf, n) \
-  INLINE_SYSCALL (write, 3, (fd), (buf), (n))
+static __always_inline ssize_t write_not_cancel(int fd, const void *buf, size_t n)
+{
+	return SCLIB_LFD_SYSCALL(write, 3, fd, buf, n);
+}
 
 /* Uncancelable writev.  */
-#define writev_not_cancel_no_status(fd, iov, n) \
-  (void) ({ INTERNAL_SYSCALL_DECL (err);				      \
-	    INTERNAL_SYSCALL (writev, err, 3, (fd), (iov), (n)); })
+static __always_inline void writev_not_cancel_no_status(int fd, const struct iovec *iov, int n)
+{
+	SCLIB_LFD_SYSCALL_NOSTATUS(writev, 3, fd, iov, n);
+}
 
 /* Uncancelable fcntl.  */
 #define fcntl_not_cancel(fd, cmd, val) \
diff -urN uClibc-0.9.33/libpthread/linuxthreads/sysdeps/unix/sysv/linux/execve.c uClibc-0.9.33-new/libpthread/linuxthreads/sysdeps/unix/sysv/linux/execve.c
--- uClibc-0.9.33/libpthread/linuxthreads/sysdeps/unix/sysv/linux/execve.c	2013-09-23 20:39:08.990221868 -0400
+++ uClibc-0.9.33-new/libpthread/linuxthreads/sysdeps/unix/sysv/linux/execve.c	2013-09-23 20:39:32.966222861 -0400
@@ -1,4 +1,5 @@
 /* Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.
+   Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,6 +24,8 @@
 #include <alloca.h>
 #include <sys/syscall.h>
 
+#include <bits/sclib.h>
+
 extern int __syscall_execve(const char *file,
 			char *const *argv,
 			char *const *envp);
@@ -32,9 +35,13 @@
 int
 __execve(const char *file, char *const argv[], char *const envp[])
 {
+	long ret;
+
 	/* If this is a threaded application kill all other threads.  */
 	if (__pthread_kill_other_threads_np)
 		__pthread_kill_other_threads_np();
+	ret = sclib_fds_save();
+	SCLIB_ERR_RET(ret);
 	return INLINE_SYSCALL(execve, 3, file, argv, envp);
 }
 weak_alias(__execve, execve)
diff -urN uClibc-0.9.33/libpthread/linuxthreads/sysdeps/unix/sysv/linux/x86_64/sysdep-cancel.h uClibc-0.9.33-new/libpthread/linuxthreads/sysdeps/unix/sysv/linux/x86_64/sysdep-cancel.h
--- uClibc-0.9.33/libpthread/linuxthreads/sysdeps/unix/sysv/linux/x86_64/sysdep-cancel.h	2013-09-23 20:39:09.022221870 -0400
+++ uClibc-0.9.33-new/libpthread/linuxthreads/sysdeps/unix/sysv/linux/x86_64/sysdep-cancel.h	2013-09-23 20:39:32.966222861 -0400
@@ -1,4 +1,5 @@
 /* Copyright (C) 2002, 2003, 2005 Free Software Foundation, Inc.
+   Copyright (C) 2012 Ruslan Nikolaev <rnikola@vt.edu>
    This file is part of the GNU C Library.
    Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
 
@@ -57,6 +58,36 @@
     jae SYSCALL_ERROR_LABEL;						      \
   L(pseudo_end):
 
+# undef PSEUDO_SCLIB
+# define PSEUDO_SCLIB(name, syscall_name, args)			     \
+  .text;								      \
+  ENTRY (name)								      \
+    SINGLE_THREAD_P;							      \
+    jne L(pseudo_cancel);						      \
+    DO_SCLIB_CALL (syscall_name, args);					      \
+    cmpq $-4095, %rax;							      \
+    jae SYSCALL_ERROR_LABEL;						      \
+    ret;								      \
+  L(pseudo_cancel):							      \
+    /* Save registers that might get destroyed.  */			      \
+    SAVESTK_##args							      \
+    PUSHARGS_##args							      \
+    CENABLE								      \
+    /* Restore registers.  */						      \
+    POPARGS_CX_##args							      \
+    /* The return value from CENABLE is argument for CDISABLE.  */	      \
+    movq %rax, (%rsp);							      \
+	DO_SCLIB_CALL (syscall_name, args)				\
+    movq (%rsp), %rdi;							      \
+    /* Save %rax since it's the error code from the syscall.  */	      \
+    movq %rax, 8(%rsp);							      \
+    CDISABLE								      \
+    movq 8(%rsp), %rax;							      \
+    RESTSTK_##args							      \
+    cmpq $-4095, %rax;							      \
+    jae SYSCALL_ERROR_LABEL;						      \
+  L(pseudo_end):
+
 # define PUSHARGS_0	/* Nothing.  */
 # define PUSHARGS_1	PUSHARGS_0 movq %rdi, 8(%rsp);
 # define PUSHARGS_2	PUSHARGS_1 movq %rsi, 16(%rsp);
@@ -73,6 +104,14 @@
 # define POPARGS_5	POPARGS_4 movq 40(%rsp), %r8;
 # define POPARGS_6	POPARGS_5 movq 48(%rsp), %r9;
 
+# define POPARGS_CX_0	POPARGS_0
+# define POPARGS_CX_1	POPARGS_1
+# define POPARGS_CX_2	POPARGS_2
+# define POPARGS_CX_3	POPARGS_3
+# define POPARGS_CX_4	POPARGS_CX_3 movq 32(%rsp), %rcx;
+# define POPARGS_CX_5	POPARGS_CX_4 movq 40(%rsp), %r8;
+# define POPARGS_CX_6	POPARGS_CX_5 movq 48(%rsp), %r9;
+
 /* We always have to align the stack before calling a function.  */
 # define SAVESTK_0	subq $24, %rsp;cfi_adjust_cfa_offset(24);
 # define SAVESTK_1	SAVESTK_0
diff -urN uClibc-0.9.33/libpthread/linuxthreads/sysdeps/unix/sysv/linux/x86_64/vfork.S uClibc-0.9.33-new/libpthread/linuxthreads/sysdeps/unix/sysv/linux/x86_64/vfork.S
--- uClibc-0.9.33/libpthread/linuxthreads/sysdeps/unix/sysv/linux/x86_64/vfork.S	2013-09-23 20:39:09.022221870 -0400
+++ uClibc-0.9.33-new/libpthread/linuxthreads/sysdeps/unix/sysv/linux/x86_64/vfork.S	2013-09-23 20:39:32.966222861 -0400
@@ -36,18 +36,7 @@
 #endif
 	jne	HIDDEN_JUMPTARGET (__fork)
 
-	/* Pop the return PC value into RDI.  We need a register that
-	   is preserved by the syscall and that we're allowed to destroy. */
-	popq	%rdi
-	cfi_adjust_cfa_offset(-8)
-
-	/* Stuff the syscall number in RAX and enter into the kernel.  */
-	movl	$SYS_ify (vfork), %eax
-	syscall
-
-	/* Push back the return PC.  */
-	pushq	%rdi
-	cfi_adjust_cfa_offset(8)
+	call HIDDEN_JUMPTARGET(__internal_sys_fork)
 
 	cmpl	$-4095, %eax
 	jae SYSCALL_ERROR_LABEL		/* Branch forward if it failed.  */
diff -urN uClibc-0.9.33/libpthread/linuxthreads.old/sysdeps/pthread/not-cancel.h uClibc-0.9.33-new/libpthread/linuxthreads.old/sysdeps/pthread/not-cancel.h
--- uClibc-0.9.33/libpthread/linuxthreads.old/sysdeps/pthread/not-cancel.h	2013-09-23 20:39:08.910221865 -0400
+++ uClibc-0.9.33-new/libpthread/linuxthreads.old/sysdeps/pthread/not-cancel.h	2013-09-23 20:39:32.966222861 -0400
@@ -21,53 +21,54 @@
 #include <sys/types.h>
 #include <sysdep.h>
 
+#include <bits/sclib.h>
+#include <bits/sclib_syscalls.h>
+
 /* Uncancelable open.  */
-#define open_not_cancel(name, flags, mode) \
-   INLINE_SYSCALL (open, 3, (const char *) (name), (flags), (mode))
-#define open_not_cancel_2(name, flags) \
-   INLINE_SYSCALL (open, 2, (const char *) (name), (flags))
-
-/* Uncancelable openat.  */
-#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
-extern int __openat_nocancel (int fd, const char *fname, int oflag,
-			      mode_t mode) attribute_hidden;
-extern int __openat64_nocancel (int fd, const char *fname, int oflag,
-				mode_t mode) attribute_hidden;
-#else
-# define __openat_nocancel(fd, fname, oflag, mode) \
-  openat (fd, fname, oflag, mode)
-# define __openat64_nocancel(fd, fname, oflag, mode) \
-  openat64 (fd, fname, oflag, mode)
-#endif
-
-#define openat_not_cancel(fd, fname, oflag, mode) \
-  __openat_nocancel (fd, fname, oflag, mode)
-#define openat_not_cancel_3(fd, fname, oflag) \
-  __openat_nocancel (fd, fname, oflag, 0)
-#define openat64_not_cancel(fd, fname, oflag, mode) \
-  __openat64_nocancel (fd, fname, oflag, mode)
-#define openat64_not_cancel_3(fd, fname, oflag) \
-  __openat64_nocancel (fd, fname, oflag, 0)
+static __always_inline int open_not_cancel(const char *name, int flags, mode_t mode)
+{
+	long ret = __internal_sys_open(name, flags, mode);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
+
+static __always_inline int open_not_cancel_2(const char *name, int flags)
+{
+	long ret = __internal_sys_open(name, flags, 0);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
 /* Uncancelable close.  */
-#define close_not_cancel(fd) \
-  INLINE_SYSCALL (close, 1, fd)
-#define close_not_cancel_no_status(fd) \
-  (void) ({ INTERNAL_SYSCALL_DECL (err);				      \
-	    INTERNAL_SYSCALL (close, err, 1, (fd)); })
+static __always_inline int close_not_cancel(int fd)
+{
+	long ret = __internal_sys_close(fd);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
+
+static __always_inline void close_not_cancel_no_status(int fd)
+{
+	__internal_sys_close(fd);
+}
 
 /* Uncancelable read.  */
-#define read_not_cancel(fd, buf, n) \
-  INLINE_SYSCALL (read, 3, (fd), (buf), (n))
+static __always_inline ssize_t read_not_cancel(int fd, void *buf, size_t n)
+{
+	return SCLIB_LFD_SYSCALL(read, 3, fd, buf, n);
+}
 
 /* Uncancelable write.  */
-#define write_not_cancel(fd, buf, n) \
-  INLINE_SYSCALL (write, 3, (fd), (buf), (n))
+static __always_inline ssize_t write_not_cancel(int fd, const void *buf, size_t n)
+{
+	return SCLIB_LFD_SYSCALL(write, 3, fd, buf, n);
+}
 
 /* Uncancelable writev.  */
-#define writev_not_cancel_no_status(fd, iov, n) \
-  (void) ({ INTERNAL_SYSCALL_DECL (err);				      \
-	    INTERNAL_SYSCALL (writev, err, 3, (fd), (iov), (n)); })
+static __always_inline void writev_not_cancel_no_status(int fd, const struct iovec *iov, int n)
+{
+	SCLIB_LFD_SYSCALL_NOSTATUS(writev, 3, fd, iov, n);
+}
 
 /* Uncancelable fcntl.  */
 #define fcntl_not_cancel(fd, cmd, val) \
diff -urN uClibc-0.9.33/libpthread/nptl/allocatestack.c uClibc-0.9.33-new/libpthread/nptl/allocatestack.c
--- uClibc-0.9.33/libpthread/nptl/allocatestack.c	2013-09-23 20:39:09.058221869 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/allocatestack.c	2013-09-23 20:39:32.966222861 -0400
@@ -1,4 +1,5 @@
 /* Copyright (C) 2002-2007, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -28,8 +29,9 @@
 #include <tls.h>
 #include <lowlevellock.h>
 #include <link.h>
+#include <scheduleP.h>
 #include <bits/kernel-features.h>
-
+#include <bits/sclib.h>
 
 #ifndef NEED_SEPARATE_REGISTER_STACK
 
@@ -104,7 +106,7 @@
 static size_t stack_cache_actsize;
 
 /* Mutex protecting this variable.  */
-static int stack_cache_lock = LLL_LOCK_INITIALIZER;
+static lll_lock_t stack_cache_lock = LLL_LOCK_INITIALIZER;
 
 /* List of queued stack frames.  */
 static LIST_HEAD (stack_cache);
@@ -331,6 +333,50 @@
   return 0;
 }
 
+static int
+allocate_kpd (struct kpthread **kpdp)
+{
+  void *mem, *top;
+  struct kpthread *kpd;
+  size_t size;
+
+  size = __getpagesize();
+  mem = mmap (NULL, size, PROT_READ | PROT_WRITE,
+		 MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);
+
+  if (__builtin_expect (mem == MAP_FAILED, 0))
+    {
+	    if (errno == ENOMEM)
+	   __set_errno (EAGAIN);
+
+	   return errno;
+	}
+
+  /* SIZE is guaranteed to be greater than zero.
+	 So we can never get a null pointer back from mmap.  */
+  assert (mem != NULL);
+
+#if defined(TLS_TCB_AT_TP)
+  kpd = (struct kpthread *) ((char *) mem + size) - 1;
+  top = ((char *) (kpd + 1) - TLS_KTCB_SIZE);
+#elif defined(TLS_DTV_AT_TP)
+  kpd = (struct kpthread *) ((uintptr_t) mem + size - TLS_KTCB_SIZE - TLS_PRE_KTCB_SIZE);
+  top = (char *) kpd;
+#endif
+
+  kpd->pid = KTHREAD_GETMEM (KTHREAD_SELF, pid);
+  kpd->context.uc_stack.ss_sp = mem;
+  kpd->context.uc_stack.ss_size = (size_t) (top - mem);
+
+  *kpdp = kpd;
+  return 0;
+}
+
+static void
+free_kpd(struct kpthread *kpd)
+{
+  munmap(kpd->context.uc_stack.ss_sp, __getpagesize());
+}
 
 static int
 allocate_stack (const struct pthread_attr *attr, struct pthread **pdp,
@@ -416,7 +462,7 @@
 #endif
 
       /* The process ID is also the same as that of the caller.  */
-      pd->pid = THREAD_GETMEM (THREAD_SELF, pid);
+      pd->pid = KTHREAD_GETMEM (KTHREAD_SELF, pid);
 
       /* Allocate the DTV for this thread.  */
       if (_dl_allocate_tls (TLS_TPADJ (pd)) == NULL)
@@ -426,7 +472,6 @@
 	  return EAGAIN;
 	}
 
-
       /* Prepare to modify global data.  */
       lll_lock (stack_cache_lock, LLL_PRIVATE);
 
@@ -554,7 +599,7 @@
 #endif
 
 	  /* The process ID is also the same as that of the caller.  */
-	  pd->pid = THREAD_GETMEM (THREAD_SELF, pid);
+	  pd->pid = KTHREAD_GETMEM (KTHREAD_SELF, pid);
 
 	  /* Allocate the DTV for this thread.  */
 	  if (_dl_allocate_tls (TLS_TPADJ (pd)) == NULL)
@@ -568,7 +613,6 @@
 	      return EAGAIN;
 	    }
 
-
 	  /* Prepare to modify global data.  */
 	  lll_lock (stack_cache_lock, LLL_PRIVATE);
 
@@ -577,7 +621,6 @@
 
 	  lll_unlock (stack_cache_lock, LLL_PRIVATE);
 
-
 	  /* Note that all of the stack and the thread descriptor is
 	     zeroed.  This means we do not have to initialize fields
 	     with initial value zero.  This is specifically true for
@@ -661,7 +704,7 @@
 
   /* Initialize the lock.  We have to do this unconditionally since the
      stillborn thread could be canceled while the lock is taken.  */
-  pd->lock = LLL_LOCK_INITIALIZER;
+  __sclib_mutex_auto_init(&pd->lock, __SCLIB_MUTEX_NORMAL);
 
   /* The robust mutex lists also need to be initialized
      unconditionally because the cleanup for the previous stack owner
@@ -685,6 +728,9 @@
   stacktop = (char *) (pd - 1);
 #endif
 
+  pd->context.uc_stack.ss_sp = pd->stackblock;
+  pd->context.uc_stack.ss_size = (size_t) (stacktop - pd->stackblock);
+
 #ifdef NEED_SEPARATE_REGISTER_STACK
   *stack = pd->stackblock;
   *stacksize = stacktop - *stack;
@@ -703,6 +749,8 @@
 internal_function
 __deallocate_stack (struct pthread *pd)
 {
+//  __sclib_mutex_destroy(&pd->lock);
+
   lll_lock (stack_cache_lock, LLL_PRIVATE);
 
   /* Remove the thread from the list of threads with user defined
@@ -778,6 +826,7 @@
 void
 __reclaim_stacks (void)
 {
+  struct kpthread *kself = KTHREAD_SELF;
   struct pthread *self = (struct pthread *) THREAD_SELF;
 
   /* No locking necessary.  The caller is the only stack in use.  But
@@ -831,7 +880,7 @@
 	  curp->tid = 0;
 
 	  /* The PID field must be initialized for the new process.  */
-	  curp->pid = self->pid;
+	  curp->pid = KTHREAD_GETMEM (kself, pid);
 
 	  /* Account for the size of the stack.  */
 	  stack_cache_actsize += curp->stackblock_size;
@@ -863,7 +912,7 @@
   list_for_each (runp, &stack_cache)
     {
       struct pthread *curp = list_entry (runp, struct pthread, list);
-      curp->pid = self->pid;
+      curp->pid = KTHREAD_GETMEM (kself, pid);
     }
 
   /* Add the stack of all running threads to the cache.  */
@@ -885,11 +934,12 @@
 
   /* There is one thread running.  */
   __nptl_nthreads = 1;
+  __nptl_rqueue->nkthreads = 1;
 
   in_flight_stack = 0;
 
   /* Initialize the lock.  */
-  stack_cache_lock = LLL_LOCK_INITIALIZER;
+  __sclib_mutex_auto_reinit (&stack_cache_lock);
 }
 
 
@@ -994,11 +1044,11 @@
   int val;
   INTERNAL_SYSCALL_DECL (err);
 #if defined (__ASSUME_TGKILL) && __ASSUME_TGKILL
-  val = INTERNAL_SYSCALL (tgkill, err, 3, THREAD_GETMEM (THREAD_SELF, pid),
+  val = INTERNAL_SYSCALL (tgkill, err, 3, KTHREAD_GETMEM (KTHREAD_SELF, pid),
 			  t->tid, SIGSETXID);
 #else
 # ifdef __NR_tgkill
-  val = INTERNAL_SYSCALL (tgkill, err, 3, THREAD_GETMEM (THREAD_SELF, pid),
+  val = INTERNAL_SYSCALL (tgkill, err, 3, KTHREAD_GETMEM (KTHREAD_SELF, pid),
 			  t->tid, SIGSETXID);
   if (INTERNAL_SYSCALL_ERROR_P (val, err)
       && INTERNAL_SYSCALL_ERRNO (val, err) == ENOSYS)
diff -urN uClibc-0.9.33/libpthread/nptl/cancellation.c uClibc-0.9.33-new/libpthread/nptl/cancellation.c
--- uClibc-0.9.33/libpthread/nptl/cancellation.c	2013-09-23 20:39:09.378221883 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/cancellation.c	2013-09-23 20:39:32.966222861 -0400
@@ -19,6 +19,7 @@
 
 #include <setjmp.h>
 #include <stdlib.h>
+#include <bits/libc-lock.h>
 #include "pthreadP.h"
 
 
@@ -94,7 +95,7 @@
   while (__builtin_expect ((newval & (CANCELING_BITMASK | CANCELED_BITMASK))
 			   == CANCELING_BITMASK, 0))
     {
-      lll_futex_wait (&self->cancelhandling, newval, LLL_PRIVATE);
+      __libc_futex_wait (&self->cancelhandling, newval);
       newval = THREAD_GETMEM (self, cancelhandling);
     }
 }
diff -urN uClibc-0.9.33/libpthread/nptl/descr.h uClibc-0.9.33-new/libpthread/nptl/descr.h
--- uClibc-0.9.33/libpthread/nptl/descr.h	2013-09-23 20:39:09.122221872 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/descr.h	2013-09-23 20:39:32.966222861 -0400
@@ -1,4 +1,5 @@
 /* Copyright (C) 2002-2006, 2007, 2008, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -20,6 +21,7 @@
 #ifndef _DESCR_H
 #define _DESCR_H	1
 
+#include <ucontext.h>
 #include <limits.h>
 #include <sched.h>
 #include <setjmp.h>
@@ -38,6 +40,7 @@
 #include <resolv.h>
 #include <bits/kernel-features.h>
 #include "uClibc-glue.h"
+#include "scheduleP.h"
 
 #ifndef TCB_ALIGNMENT
 # define TCB_ALIGNMENT	sizeof (double)
@@ -120,6 +123,49 @@
 };
 
 
+struct syscall_queue;
+struct __sclib_mutex;
+struct pthread;
+
+struct kpthread
+{
+  union
+  {
+#if !defined(TLS_DTV_AT_TP)
+    /* This overlaps the TCB as used for TLS without threads (see tls.h).  */
+    tcbhead_t header;
+#else
+    struct
+    {
+      int multiple_threads;
+      int gscope_flag;
+# ifndef __ASSUME_PRIVATE_FUTEX
+      int private_futex;
+# endif
+    } header;
+#endif
+
+    /* This extra padding has no special purpose, and this structure layout
+       is private and subject to change without affecting the official ABI.
+       We just have it here in case it might be convenient for some
+       implementation-specific instrumentation hack or suchlike.  */
+    void *__padding[24];
+  };
+
+  struct syscall_queue *current_queue;
+
+  union {
+    struct __sclib_mutex *current_mutex;
+    struct syscall_entry *current_entry;
+  };
+
+  pid_t ktid; /* Compatible with pthread. */
+  pid_t pid; /* Compatible with pthread. */
+
+  ucontext_t context;
+  ucontext_t wait_context;
+} __attribute ((aligned (TCB_ALIGNMENT)));
+
 /* Thread descriptor data structure.  */
 struct pthread
 {
@@ -156,6 +202,11 @@
   /* Process ID - thread group ID in kernel speak.  */
   pid_t pid;
 
+  long state;
+  ucontext_t context;
+  struct list_head rqueue;
+  struct __sclib_sem exit_sem;
+
   /* List of robust mutexes the thread is holding.  */
 #ifdef __PTHREAD_MUTEX_HAVE_PREV
   void *robust_prev;
@@ -309,7 +360,7 @@
   int parent_cancelhandling;
 
   /* Lock to synchronize access to the descriptor.  */
-  int lock;
+  lll_lock_t lock;
 
   /* Lock for synchronizing setxid calls.  */
   int setxid_futex;
diff -urN uClibc-0.9.33/libpthread/nptl/forward.c uClibc-0.9.33-new/libpthread/nptl/forward.c
--- uClibc-0.9.33/libpthread/nptl/forward.c	2013-09-23 20:39:09.066221870 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/forward.c	2013-09-23 20:39:32.966222861 -0400
@@ -25,6 +25,7 @@
 #include <atomic.h>
 #include <sysdep.h>
 
+#include <bits/sclib.h>
 
 /* Pointers to the libc functions.  */
 struct pthread_functions __libc_pthread_functions attribute_hidden;
@@ -144,7 +145,38 @@
 
 FORWARD (pthread_setcanceltype, (int type, int *oldtype), (type, oldtype), 0)
 
+FORWARD2 (__sclib_futex_wait,
+	 long, (int *ptr, int val), (ptr, val), return 0)
+
+FORWARD2 (__sclib_futex_wake,
+	 long, (int *ptr, int val), (ptr, val), return 0)
+
+struct syscall_entry;
+
+FORWARD2 (__sclib_schedule,
+	 void, (int sysid, struct syscall_entry *entry), (sysid, entry), sclib_schedule_single(sysid, entry))
+
+struct __sclib_mutex_auto;
+
+FORWARD2 (__sclib_mutex_auto_init,
+	 long, (struct __sclib_mutex_auto *mutex, int kind), (mutex, kind), return 0)
+
+FORWARD2 (__sclib_mutex_auto_reinit,
+	 long, (struct __sclib_mutex_auto *mutex), (mutex), return 0)
+
+FORWARD2 (__sclib_mutex_auto_trylock,
+	 long, (struct __sclib_mutex_auto *mutex), (mutex), return 0)
+
+FORWARD2 (__sclib_mutex_auto_lock,
+	 long, (struct __sclib_mutex_auto *mutex), (mutex), return 0)
+
+FORWARD2 (__sclib_mutex_auto_unlock,
+	 long, (struct __sclib_mutex_auto *mutex), (mutex), return 0)
+
 #define return /* value is void */
+FORWARD2 (__sclib_mutex_auto_destroy,
+	 void, (struct __sclib_mutex_auto *mutex), (mutex), return)
+
 FORWARD2(_pthread_cleanup_push_defer,
 	 void, (struct _pthread_cleanup_buffer *buffer, void (*routine)(void *), void *arg),
 	 (buffer, routine, arg),
diff -urN uClibc-0.9.33/libpthread/nptl/init.c uClibc-0.9.33-new/libpthread/nptl/init.c
--- uClibc-0.9.33/libpthread/nptl/init.c	2013-09-23 20:39:09.082221870 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/init.c	2013-09-23 20:39:32.966222861 -0400
@@ -1,4 +1,5 @@
 /* Copyright (C) 2002-2007, 2008, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -34,13 +35,17 @@
 #include <smp.h>
 #include <lowlevellock.h>
 #include <bits/kernel-features.h>
+#include <bits/sclib.h>
 #include <stdio.h>
+#include <scheduleP.h>
 extern __typeof(sigaction) __libc_sigaction;
 
 /* Size and alignment of static TLS block.  */
 size_t __static_tls_size;
 size_t __static_tls_align_m1;
 
+size_t __sclib_num_kthreads = SCLIB_NUM_KTHREADS;
+
 #ifndef __ASSUME_SET_ROBUST_LIST
 /* Negative if we do not have the system call and we can use it.  */
 int __set_robust_list_avail;
@@ -99,6 +104,7 @@
     .ptr_pthread_setschedparam = __pthread_setschedparam,
     .ptr_pthread_mutex_destroy = INTUSE(__pthread_mutex_destroy),
     .ptr_pthread_mutex_init = INTUSE(__pthread_mutex_init),
+    .ptr___pthread_mutex_reinit = INTUSE(__pthread_mutex_reinit),
     .ptr_pthread_mutex_lock = INTUSE(__pthread_mutex_lock),
     .ptr_pthread_mutex_unlock = INTUSE(__pthread_mutex_unlock),
     .ptr_pthread_self = __pthread_self,
@@ -119,7 +125,16 @@
     .ptr__nptl_deallocate_tsd = __nptl_deallocate_tsd,
     .ptr__nptl_setxid = __nptl_setxid,
     /* For now only the stack cache needs to be freed.  */
-    .ptr_freeres = nptl_freeres
+    .ptr_freeres = nptl_freeres,
+    .ptr___sclib_futex_wake = __sclib_futex_wake,
+    .ptr___sclib_futex_wait = __sclib_futex_wait,
+    .ptr___sclib_schedule = __sclib_schedule,
+    .ptr___sclib_mutex_auto_init = INTUSE(__sclib_mutex_auto_init),
+    .ptr___sclib_mutex_auto_reinit = INTUSE(__sclib_mutex_auto_reinit),
+    .ptr___sclib_mutex_auto_destroy = INTUSE(__sclib_mutex_auto_destroy),
+    .ptr___sclib_mutex_auto_lock = INTUSE(__sclib_mutex_auto_lock),
+    .ptr___sclib_mutex_auto_trylock = INTUSE(__sclib_mutex_auto_trylock),
+    .ptr___sclib_mutex_auto_unlock = INTUSE(__sclib_mutex_auto_unlock)
   };
 # define ptr_pthread_functions &pthread_functions
 #else
@@ -146,7 +161,7 @@
 #ifdef __ASSUME_CORRECT_SI_PID
   /* Determine the process ID.  It might be negative if the thread is
      in the middle of a fork() call.  */
-  pid_t pid = THREAD_GETMEM (THREAD_SELF, pid);
+  pid_t pid = KTHREAD_GETMEM (KTHREAD_SELF, pid);
   if (__builtin_expect (pid < 0, 0))
     pid = -pid;
 #endif
@@ -207,7 +222,7 @@
 #ifdef __ASSUME_CORRECT_SI_PID
   /* Determine the process ID.  It might be negative if the thread is
      in the middle of a fork() call.  */
-  pid_t pid = THREAD_GETMEM (THREAD_SELF, pid);
+  pid_t pid = KTHREAD_GETMEM (KTHREAD_SELF, pid);
   if (__builtin_expect (pid < 0, 0))
     pid = -pid;
 #endif
@@ -257,16 +272,26 @@
 /* This can be set by the debugger before initialization is complete.  */
 static bool __nptl_initial_report_events __attribute_used__;
 
-void __pthread_initialize_minimal_internal (void) attribute_hidden;
+void __pthread_initialize_minimal_internal (struct syscall_queue *rqueue) attribute_hidden;
 void
-__pthread_initialize_minimal_internal (void)
+__pthread_initialize_minimal_internal (struct syscall_queue *rqueue)
 {
   static int initialized = 0;
+  struct kpthread *kpd = KTHREAD_SELF;
+  struct pthread *pd;
+  const char *str;
+  pid_t pid;
+  unsigned long num;
 
   if (initialized)
     return;
   initialized = 1;
 
+  __sclib_schedule_init (rqueue);
+  __sclib_kthread_init (kpd);
+  pd = THREAD_SELF;
+  __sclib_thread_init (pd, kpd);
+
 #ifndef SHARED
   /* Unlike in the dynamically linked case the dynamic linker has not
      taken care of initializing the TLS data structures.  */
@@ -280,13 +305,15 @@
 #endif
 
   /* Minimal initialization of the thread descriptor.  */
-  struct pthread *pd = THREAD_SELF;
   INTERNAL_SYSCALL_DECL (err);
-  pd->pid = pd->tid = INTERNAL_SYSCALL (set_tid_address, err, 1, &pd->tid);
+  pid = INTERNAL_SYSCALL (set_tid_address, err, 1, &kpd->ktid);
+  KTHREAD_SETMEM (kpd, ktid, pid);
+  KTHREAD_SETMEM (kpd, pid, pid);
+  THREAD_SETMEM (pd, pid, pid);
+  THREAD_SETMEM (pd, tid, GET_TID());
   THREAD_SETMEM (pd, specific[0], &pd->specific_1stblock[0]);
   THREAD_SETMEM (pd, user_stack, true);
-  if (LLL_LOCK_INITIALIZER != 0)
-    THREAD_SETMEM (pd, lock, LLL_LOCK_INITIALIZER);
+  __sclib_mutex_auto_init(&pd->lock, __SCLIB_MUTEX_NORMAL);
 #if HP_TIMING_AVAIL
   THREAD_SETMEM (pd, cpuclock_offset, GL(dl_cpuclock_offset));
 #endif
@@ -296,6 +323,7 @@
   pd->robust_prev = &pd->robust_head;
 #endif
   pd->robust_head.list = &pd->robust_head;
+#if 0
 #ifdef __NR_set_robust_list
   pd->robust_head.futex_offset = (offsetof (pthread_mutex_t, __data.__lock)
 				  - offsetof (pthread_mutex_t,
@@ -304,6 +332,7 @@
 			      sizeof (struct robust_list_head));
   if (INTERNAL_SYSCALL_ERROR_P (res, err))
 #endif
+#endif
     set_robust_list_not_avail ();
 
 #ifndef __ASSUME_PRIVATE_FUTEX
@@ -442,6 +471,14 @@
       }
     }
   }
+
+  /* Obtain number of kernel thread entities. */
+  str = getenv("SCLIB_NUM_KTHREADS");
+  if (str != NULL) {
+    num = strtol(str, NULL, 10);
+    if ((num > 0 && num <= SCLIB_MAX_KTHREADS))
+      __sclib_num_kthreads = num;
+  }
 }
 strong_alias (__pthread_initialize_minimal_internal,
 	      __pthread_initialize_minimal)
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_attr_init.c uClibc-0.9.33-new/libpthread/nptl/pthread_attr_init.c
--- uClibc-0.9.33/libpthread/nptl/pthread_attr_init.c	2013-09-23 20:39:09.106221872 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_attr_init.c	2013-09-23 20:39:32.966222861 -0400
@@ -25,7 +25,7 @@
 
 
 struct pthread_attr *__attr_list;
-int __attr_list_lock = LLL_LOCK_INITIALIZER;
+lll_lock_t __attr_list_lock = LLL_LOCK_INITIALIZER;
 
 
 int
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_cancel.c uClibc-0.9.33-new/libpthread/nptl/pthread_cancel.c
--- uClibc-0.9.33/libpthread/nptl/pthread_cancel.c	2013-09-23 20:39:09.378221883 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_cancel.c	2013-09-23 20:39:32.970222861 -0400
@@ -29,6 +29,8 @@
 pthread_cancel (
      pthread_t th)
 {
+  return ENOSYS;
+#if 0
   volatile struct pthread *pd = (volatile struct pthread *) th;
 
   /* Make sure the descriptor is valid.  */
@@ -103,6 +105,7 @@
 					       oldval));
 
   return result;
+#endif
 }
 
 PTHREAD_STATIC_FN_REQUIRE (pthread_create)
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_cond_destroy.c uClibc-0.9.33-new/libpthread/nptl/pthread_cond_destroy.c
--- uClibc-0.9.33/libpthread/nptl/pthread_cond_destroy.c	2013-09-23 20:39:09.378221883 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_cond_destroy.c	2013-09-23 20:39:32.970222861 -0400
@@ -19,13 +19,17 @@
 
 #include <errno.h>
 #include "pthreadP.h"
-
+#include "scheduleP.h"
 
 int
 attribute_protected
 __pthread_cond_destroy (
      pthread_cond_t *cond)
 {
+  __sclib_cond_destroy(&cond->sclib_cond);
+  return 0;
+
+#if 0
   int pshared = (cond->__data.__mutex == (void *) ~0l)
 		? LLL_SHARED : LLL_PRIVATE;
 
@@ -80,5 +84,6 @@
     }
 
   return 0;
+#endif
 }
 weak_alias(__pthread_cond_destroy, pthread_cond_destroy)
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_cond_init.c uClibc-0.9.33-new/libpthread/nptl/pthread_cond_init.c
--- uClibc-0.9.33/libpthread/nptl/pthread_cond_init.c	2013-09-23 20:39:09.066221870 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_cond_init.c	2013-09-23 20:39:32.970222861 -0400
@@ -19,7 +19,7 @@
    02111-1307 USA.  */
 
 #include "pthreadP.h"
-
+#include "scheduleP.h"
 
 int
 attribute_protected
@@ -27,6 +27,9 @@
      pthread_cond_t *cond,
      const pthread_condattr_t *cond_attr)
 {
+  return __sclib_cond_init(&cond->sclib_cond);
+
+#if 0
   struct pthread_condattr *icond_attr = (struct pthread_condattr *) cond_attr;
 
   cond->__data.__lock = LLL_LOCK_INITIALIZER;
@@ -43,5 +46,6 @@
   cond->__data.__broadcast_seq = 0;
 
   return 0;
+#endif
 }
 weak_alias(__pthread_cond_init, pthread_cond_init)
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_create.c uClibc-0.9.33-new/libpthread/nptl/pthread_create.c
--- uClibc-0.9.33/libpthread/nptl/pthread_create.c	2013-09-23 20:39:09.066221870 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_create.c	2013-09-23 20:39:32.970222861 -0400
@@ -22,16 +22,18 @@
 #include <stdlib.h>
 #include <string.h>
 #include "pthreadP.h"
+#include "scheduleP.h"
 #include <hp-timing.h>
 #include <ldsodefs.h>
 #include <atomic.h>
 #include <libc-internal.h>
 #include <resolv.h>
 #include <bits/kernel-features.h>
-
+#include <bits/sclib.h>
+#include <bits/sclib_syscalls.h>
 
 /* Local function to start thread and handle cleanup.  */
-static int start_thread (void *arg);
+static void start_thread (struct pthread *from, struct pthread *pd);
 
 
 /* Nozero if debugging mode is enabled.  */
@@ -46,6 +48,8 @@
 /* Number of threads running.  */
 unsigned int __nptl_nthreads = 1;
 
+/* Thread ID counter */
+unsigned int __nptl_tid = 0;
 
 /* Code to allocate and deallocate a stack.  */
 #include "allocatestack.c"
@@ -222,10 +226,15 @@
 }
 
 
-static int
-start_thread (void *arg)
+static void
+start_thread (struct pthread *from, struct pthread *pd)
 {
-  struct pthread *pd = (struct pthread *) arg;
+  if (from != NULL) {
+    KTHREAD_SETMEM (KTHREAD_SELF, header.tcb, pd);
+    __sclib_initial_add (from);
+  }
+
+  __internal_sys_clone_thread ();
 
 #if HP_TIMING_AVAIL
   /* Remember the time when the thread was started.  */
@@ -233,10 +242,14 @@
   HP_TIMING_NOW (now);
   THREAD_SETMEM (pd, cpuclock_offset, now);
 #endif
+
+  __sclib_yield();
+
 #if defined __UCLIBC_HAS_RESOLVER_SUPPORT__
   /* Initialize resolver state pointer.  */
   __resp = &pd->res;
 #endif
+#if 0
 #ifdef __NR_set_robust_list
 # ifndef __ASSUME_SET_ROBUST_LIST
   if (__set_robust_list_avail >= 0)
@@ -249,6 +262,7 @@
 			sizeof (struct robust_list_head));
     }
 #endif
+#endif
 
   /* If the parent was running cancellation handlers while creating
      the thread the new thread inherited the signal mask.  Reset the
@@ -298,6 +312,12 @@
 #endif
     }
 
+  /* We still need thread-local data for this. */
+  sclib_efds_close();
+  sclib_memory_prealloc_exit();
+
+	pd->state = __SCLIB_PTHREAD_COMPLETE;
+
   /* Run the destructor for the thread-local data.  */
   __nptl_deallocate_tsd ();
 
@@ -345,6 +365,7 @@
      the breakpoint reports TD_THR_RUN state rather than TD_THR_ZOMBIE.  */
   atomic_bit_set (&pd->cancelhandling, EXITING_BIT);
 
+#if 0
 #ifndef __ASSUME_SET_ROBUST_LIST
   /* If this thread has any robust mutexes locked, handle them now.  */
 # if __WORDSIZE == 64
@@ -375,6 +396,7 @@
       while (robust != (void *) &pd->robust_head);
     }
 #endif
+#endif
 
   /* Mark the memory of the stack as usable to the kernel.  We free
      everything except for the space used for the TCB itself.  */
@@ -413,10 +435,9 @@
 
      The exit code is zero since in case all threads exit by calling
      'pthread_exit' the exit status must be 0 (zero).  */
-  __exit_thread_inline (0);
+  /* __exit_thread_inline (0); */
 
-  /* NOTREACHED */
-  return 0;
+  setcontextp (&KTHREAD_SELF->context, &pd->context);
 }
 
 
@@ -451,6 +472,9 @@
        invalid or we could not allocate memory.  */
     return err;
 
+  err = __sclib_sem_init (&pd->exit_sem, 0);
+  if (__builtin_expect (err != 0, 0))
+    goto errout_stack;
 
   /* Initialize the TCB.  All initializations with zero should be
      performed in 'get_cached_stack'.  This way we avoid doing this if
@@ -483,7 +507,6 @@
   /* The debug events are inherited from the parent.  */
   pd->eventbuf = self->eventbuf;
 
-
   /* Copy the parent's scheduling parameters.  The flags will say what
      is valid and what is not.  */
   pd->schedpolicy = self->schedpolicy;
@@ -553,6 +576,8 @@
       if (!is_detached)
 	{
 	errout:
+      __sclib_sem_destroy (&pd->exit_sem);
+    errout_stack:
 	  __deallocate_stack (pd);
 	}
       return err;
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_getattr_np.c uClibc-0.9.33-new/libpthread/nptl/pthread_getattr_np.c
--- uClibc-0.9.33/libpthread/nptl/pthread_getattr_np.c	2013-09-23 20:39:09.106221872 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_getattr_np.c	2013-09-23 20:39:32.970222861 -0400
@@ -67,7 +67,7 @@
     {
       /* No stack information available.  This must be for the initial
 	 thread.  Get the info in some magical way.  */
-      assert (abs (thread->pid) == thread->tid);
+      /* assert (abs (thread->pid) == thread->tid); */
 
       /* Stack size limit.  */
       struct rlimit rl;
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_getschedparam.c uClibc-0.9.33-new/libpthread/nptl/pthread_getschedparam.c
--- uClibc-0.9.33/libpthread/nptl/pthread_getschedparam.c	2013-09-23 20:39:09.058221869 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_getschedparam.c	2013-09-23 20:39:32.970222861 -0400
@@ -48,7 +48,7 @@
      not yet been retrieved do it now.  */
   if ((pd->flags & ATTR_FLAG_SCHED_SET) == 0)
     {
-      if (sched_getparam (pd->tid, &pd->schedparam) != 0)
+      if (sched_getparam (pd->pid, &pd->schedparam) != 0)
 	result = 1;
       else
 	pd->flags |= ATTR_FLAG_SCHED_SET;
@@ -56,7 +56,7 @@
 
   if ((pd->flags & ATTR_FLAG_POLICY_SET) == 0)
     {
-      pd->schedpolicy = sched_getscheduler (pd->tid);
+      pd->schedpolicy = sched_getscheduler (pd->pid);
       if (pd->schedpolicy == -1)
 	result = 1;
       else
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_join.c uClibc-0.9.33-new/libpthread/nptl/pthread_join.c
--- uClibc-0.9.33/libpthread/nptl/pthread_join.c	2013-09-23 20:39:09.390221884 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_join.c	2013-09-23 20:39:32.970222861 -0400
@@ -22,7 +22,7 @@
 
 #include <atomic.h>
 #include "pthreadP.h"
-
+#include "scheduleP.h"
 
 static void
 cleanup (void *arg)
@@ -86,7 +86,7 @@
     result = EINVAL;
   else
     /* Wait for the child.  */
-    lll_wait_tid (pd->tid);
+    __sclib_sem_wait(&pd->exit_sem);
 
 
   /* Restore cancellation mode.  */
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_mutex_consistent.c uClibc-0.9.33-new/libpthread/nptl/pthread_mutex_consistent.c
--- uClibc-0.9.33/libpthread/nptl/pthread_mutex_consistent.c	2013-09-23 20:39:09.378221883 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_mutex_consistent.c	2013-09-23 20:39:32.970222861 -0400
@@ -30,8 +30,9 @@
       || mutex->__data.__owner != PTHREAD_MUTEX_INCONSISTENT)
     return EINVAL;
 
+#if 0
   mutex->__data.__owner = THREAD_GETMEM (THREAD_SELF, tid);
-
+#endif
   return 0;
 }
 weak_alias (pthread_mutex_consistent, pthread_mutex_consistent_np)
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_mutex_destroy.c uClibc-0.9.33-new/libpthread/nptl/pthread_mutex_destroy.c
--- uClibc-0.9.33/libpthread/nptl/pthread_mutex_destroy.c	2013-09-23 20:39:09.374221883 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_mutex_destroy.c	2013-09-23 20:39:32.970222861 -0400
@@ -19,20 +19,23 @@
 
 #include <errno.h>
 #include "pthreadP.h"
-
+#include "scheduleP.h"
 
 int
 attribute_protected
 __pthread_mutex_destroy (
      pthread_mutex_t *mutex)
 {
+#if 0
   if ((mutex->__data.__kind & PTHREAD_MUTEX_ROBUST_NORMAL_NP) == 0
       && mutex->__data.__nusers != 0)
     return EBUSY;
 
   /* Set to an invalid value.  */
   mutex->__data.__kind = -1;
+#endif
 
+  __sclib_mutex_destroy(&mutex->sclib_mutex);
   return 0;
 }
 strong_alias (__pthread_mutex_destroy, pthread_mutex_destroy)
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_mutex_init.c uClibc-0.9.33-new/libpthread/nptl/pthread_mutex_init.c
--- uClibc-0.9.33/libpthread/nptl/pthread_mutex_init.c	2013-09-23 20:39:09.090221869 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_mutex_init.c	2013-09-23 20:39:32.970222861 -0400
@@ -23,6 +23,7 @@
 #include <string.h>
 #include <bits/kernel-features.h>
 #include "pthreadP.h"
+#include "scheduleP.h"
 
 static const struct pthread_mutexattr default_attr =
   {
@@ -31,10 +32,20 @@
   };
 
 
+#if 0
 #ifndef __ASSUME_FUTEX_LOCK_PI
 static int tpi_supported;
 #endif
+#endif
 
+int
+attribute_protected
+__pthread_mutex_reinit (
+     pthread_mutex_t *mutex)
+{
+  return __sclib_mutex_reinit(&mutex->sclib_mutex);
+}
+INTDEF(__pthread_mutex_reinit)
 
 int
 attribute_protected
@@ -48,6 +59,9 @@
 
   imutexattr = (const struct pthread_mutexattr *) mutexattr ?: &default_attr;
 
+  return __sclib_mutex_init(&mutex->sclib_mutex, imutexattr->mutexkind & ~PTHREAD_MUTEXATTR_FLAG_BITS);
+
+#if 0
   /* Sanity checks.  */
   switch (__builtin_expect (imutexattr->mutexkind
 			    & PTHREAD_MUTEXATTR_PROTOCOL_MASK,
@@ -137,6 +151,7 @@
   // mutex->__next = NULL;	already done by memset
 
   return 0;
+#endif
 }
 strong_alias (__pthread_mutex_init, pthread_mutex_init)
 INTDEF(__pthread_mutex_init)
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_mutex_lock.c uClibc-0.9.33-new/libpthread/nptl/pthread_mutex_lock.c
--- uClibc-0.9.33/libpthread/nptl/pthread_mutex_lock.c	2013-09-23 20:39:09.066221870 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_mutex_lock.c	2013-09-23 20:39:32.970222861 -0400
@@ -23,6 +23,7 @@
 #include <unistd.h>
 #include <not-cancel.h>
 #include "pthreadP.h"
+#include "scheduleP.h"
 #include <lowlevellock.h>
 
 
@@ -36,10 +37,10 @@
 		   PTHREAD_ROBUST_MUTEX_PSHARED (mutex))
 #endif
 
-
+#if 0
 static int __pthread_mutex_lock_full (pthread_mutex_t *mutex)
      __attribute_noinline__;
-
+#endif
 
 int
 #ifdef NO_INCR
@@ -52,6 +53,9 @@
 {
   assert (sizeof (mutex->__size) >= sizeof (mutex->__data));
 
+  return __sclib_mutex_lock(&mutex->sclib_mutex);
+
+#if 0
   unsigned int type = PTHREAD_MUTEX_TYPE (mutex);
   if (__builtin_expect (type & ~PTHREAD_MUTEX_KIND_MASK_NP, 0))
     return __pthread_mutex_lock_full (mutex);
@@ -133,8 +137,10 @@
 #endif
 
   return 0;
+#endif
 }
 
+#if 0
 static int
 __pthread_mutex_lock_full (pthread_mutex_t *mutex)
 {
@@ -474,12 +480,14 @@
 
   return 0;
 }
+#endif
+
 #ifndef __pthread_mutex_lock
 strong_alias (__pthread_mutex_lock, pthread_mutex_lock)
 strong_alias (__pthread_mutex_lock, __pthread_mutex_lock_internal)
 #endif
 
-
+#if 0
 #ifdef NO_INCR
 void
 attribute_hidden internal_function
@@ -498,3 +506,4 @@
     ++mutex->__data.__count;
 }
 #endif
+#endif
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_mutex_setprioceiling.c uClibc-0.9.33-new/libpthread/nptl/pthread_mutex_setprioceiling.c
--- uClibc-0.9.33/libpthread/nptl/pthread_mutex_setprioceiling.c	2013-09-23 20:39:09.054221870 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_mutex_setprioceiling.c	2013-09-23 20:39:32.970222861 -0400
@@ -29,6 +29,8 @@
      int prioceiling;
      int *old_ceiling;
 {
+  return ENOSYS;
+#if 0
   /* The low bits of __kind aren't ever changed after pthread_mutex_init,
      so we don't need a lock yet.  */
   if ((mutex->__data.__kind & PTHREAD_MUTEX_PRIO_PROTECT_NP) == 0)
@@ -116,4 +118,5 @@
 		  PTHREAD_MUTEX_PSHARED (mutex));
 
   return 0;
+#endif
 }
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_mutex_timedlock.c uClibc-0.9.33-new/libpthread/nptl/pthread_mutex_timedlock.c
--- uClibc-0.9.33/libpthread/nptl/pthread_mutex_timedlock.c	2013-09-23 20:39:09.382221883 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_mutex_timedlock.c	2013-09-23 20:39:32.970222861 -0400
@@ -24,6 +24,7 @@
 #include <lowlevellock.h>
 #include <not-cancel.h>
 
+#if 0
 /* We need to build this function with optimization to avoid
  * lll_timedlock erroring out with
  * error: can't find a register in class GENERAL_REGS while reloading asm
@@ -486,3 +487,4 @@
  out:
   return result;
 }
+#endif
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_mutex_trylock.c uClibc-0.9.33-new/libpthread/nptl/pthread_mutex_trylock.c
--- uClibc-0.9.33/libpthread/nptl/pthread_mutex_trylock.c	2013-09-23 20:39:09.390221884 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_mutex_trylock.c	2013-09-23 20:39:32.970222861 -0400
@@ -28,6 +28,9 @@
 __pthread_mutex_trylock (
      pthread_mutex_t *mutex)
 {
+  return __sclib_mutex_trylock(&mutex->sclib_mutex);
+
+#if 0
   int oldval;
   pid_t id = THREAD_GETMEM (THREAD_SELF, tid);
 
@@ -378,5 +381,6 @@
     }
 
   return EBUSY;
+#endif
 }
 strong_alias (__pthread_mutex_trylock, pthread_mutex_trylock)
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_mutex_unlock.c uClibc-0.9.33-new/libpthread/nptl/pthread_mutex_unlock.c
--- uClibc-0.9.33/libpthread/nptl/pthread_mutex_unlock.c	2013-09-23 20:39:09.066221870 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_mutex_unlock.c	2013-09-23 20:39:32.970222861 -0400
@@ -21,8 +21,10 @@
 #include <errno.h>
 #include <stdlib.h>
 #include "pthreadP.h"
+#include "scheduleP.h"
 #include <lowlevellock.h>
 
+#if 0
 static int
 internal_function
 __pthread_mutex_unlock_full (pthread_mutex_t *mutex, int decr)
@@ -282,13 +284,14 @@
   return 0;
 }
 
+#endif
 
 int
 attribute_protected
 __pthread_mutex_unlock (
      pthread_mutex_t *mutex)
 {
-  return __pthread_mutex_unlock_usercnt (mutex, 1);
+  return __sclib_mutex_unlock(&mutex->sclib_mutex);
 }
 strong_alias (__pthread_mutex_unlock, pthread_mutex_unlock)
 strong_alias (__pthread_mutex_unlock, __pthread_mutex_unlock_internal)
diff -urN uClibc-0.9.33/libpthread/nptl/pthreadP.h uClibc-0.9.33-new/libpthread/nptl/pthreadP.h
--- uClibc-0.9.33/libpthread/nptl/pthreadP.h	2013-09-23 20:39:09.378221883 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthreadP.h	2013-09-23 20:39:32.970222861 -0400
@@ -33,6 +33,7 @@
 #include <atomic.h>
 #include <bits/kernel-features.h>
 
+#include <stdio.h>
 
 /* Atomic operations on TLS memory.  */
 #ifndef THREAD_ATOMIC_CMPXCHG_VAL
@@ -144,7 +145,6 @@
 #define FUTEX_OWNER_DIED	0x40000000
 #define FUTEX_TID_MASK		0x3fffffff
 
-
 /* Internal variables.  */
 
 
@@ -164,7 +164,7 @@
 
 /* Attribute handling.  */
 extern struct pthread_attr *__attr_list attribute_hidden;
-extern int __attr_list_lock attribute_hidden;
+extern lll_lock_t __attr_list_lock attribute_hidden;
 
 /* First available RT signal.  */
 extern int __current_sigrtmin attribute_hidden;
@@ -187,6 +187,16 @@
 #endif
 	;
 
+extern unsigned int __nptl_tid
+#ifdef SHARED
+	attribute_hidden
+#else
+	__attribute ((weak))
+#endif
+	;
+
+#define GET_TID()	(atomic_increment_val(&__nptl_tid) & 0x1FFFFFFFU)
+
 #ifndef __ASSUME_SET_ROBUST_LIST
 /* Negative if we do not have the system call and we can use it.  */
 extern int __set_robust_list_avail attribute_hidden;
@@ -196,9 +206,11 @@
 extern int __sched_fifo_min_prio attribute_hidden;
 extern int __sched_fifo_max_prio attribute_hidden;
 extern void __init_sched_fifo_prio (void) attribute_hidden;
+#if 0
 extern int __pthread_tpp_change_priority (int prev_prio, int new_prio)
      attribute_hidden;
 extern int __pthread_current_priority (void) attribute_hidden;
+#endif
 
 /* The library can run in debugging mode where it performs a lot more
    tests.  */
@@ -415,6 +427,8 @@
 extern int __pthread_mutex_init_internal (pthread_mutex_t *__mutex,
 					  __const pthread_mutexattr_t *__mutexattr)
      attribute_hidden;
+extern int __pthread_mutex_reinit (pthread_mutex_t *__mutex);
+extern int __pthread_mutex_reinit_internal (pthread_mutex_t *__mutex);
 extern int __pthread_mutex_destroy (pthread_mutex_t *__mutex);
 extern int __pthread_mutex_destroy_internal (pthread_mutex_t *__mutex)
      attribute_hidden;
@@ -422,16 +436,16 @@
 extern int __pthread_mutex_lock (pthread_mutex_t *__mutex);
 extern int __pthread_mutex_lock_internal (pthread_mutex_t *__mutex)
      attribute_hidden;
-extern int __pthread_mutex_cond_lock (pthread_mutex_t *__mutex)
-     attribute_hidden internal_function;
-extern void __pthread_mutex_cond_lock_adjust (pthread_mutex_t *__mutex)
-     attribute_hidden internal_function;
+/* extern int __pthread_mutex_cond_lock (pthread_mutex_t *__mutex)
+     attribute_hidden internal_function; */
+/* extern void __pthread_mutex_cond_lock_adjust (pthread_mutex_t *__mutex)
+     attribute_hidden internal_function; */
 extern int __pthread_mutex_unlock (pthread_mutex_t *__mutex);
 extern int __pthread_mutex_unlock_internal (pthread_mutex_t *__mutex)
      attribute_hidden;
-extern int __pthread_mutex_unlock_usercnt (pthread_mutex_t *__mutex,
+/* extern int __pthread_mutex_unlock_usercnt (pthread_mutex_t *__mutex,
 					   int __decr)
-     attribute_hidden internal_function;
+     attribute_hidden internal_function; */
 extern int __pthread_mutexattr_init (pthread_mutexattr_t *attr);
 extern int __pthread_mutexattr_destroy (pthread_mutexattr_t *attr);
 extern int __pthread_mutexattr_settype (pthread_mutexattr_t *attr, int kind);
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_rwlock_destroy.c uClibc-0.9.33-new/libpthread/nptl/pthread_rwlock_destroy.c
--- uClibc-0.9.33/libpthread/nptl/pthread_rwlock_destroy.c	2013-09-23 20:39:09.390221884 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_rwlock_destroy.c	2013-09-23 20:39:32.970222861 -0400
@@ -18,12 +18,12 @@
    02111-1307 USA.  */
 
 #include "pthreadP.h"
-
+#include "scheduleP.h"
 
 int
 __pthread_rwlock_destroy (pthread_rwlock_t *rwlock)
 {
-  /* Nothing to be done.  For now.  */
+  __sclib_rwlock_destroy(&rwlock->sclib_rwlock);
   return 0;
 }
 strong_alias (__pthread_rwlock_destroy, pthread_rwlock_destroy)
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_rwlock_init.c uClibc-0.9.33-new/libpthread/nptl/pthread_rwlock_init.c
--- uClibc-0.9.33/libpthread/nptl/pthread_rwlock_init.c	2013-09-23 20:39:09.058221869 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_rwlock_init.c	2013-09-23 20:39:32.970222861 -0400
@@ -20,12 +20,15 @@
 #include "pthreadP.h"
 #include <bits/kernel-features.h>
 #include <string.h>
+#include "scheduleP.h"
 
+#if 0
 static const struct pthread_rwlockattr default_attr =
   {
     .lockkind = PTHREAD_RWLOCK_DEFAULT_NP,
     .pshared = PTHREAD_PROCESS_PRIVATE
   };
+#endif
 
 
 int
@@ -33,6 +36,9 @@
      pthread_rwlock_t *rwlock,
      const pthread_rwlockattr_t *attr)
 {
+  return __sclib_rwlock_init(&rwlock->sclib_rwlock);
+
+#if 0
   const struct pthread_rwlockattr *iattr;
 
   iattr = ((const struct pthread_rwlockattr *) attr) ?: &default_attr;
@@ -69,5 +75,6 @@
 #endif
 
   return 0;
+#endif
 }
 strong_alias (__pthread_rwlock_init, pthread_rwlock_init)
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_rwlock_tryrdlock.c uClibc-0.9.33-new/libpthread/nptl/pthread_rwlock_tryrdlock.c
--- uClibc-0.9.33/libpthread/nptl/pthread_rwlock_tryrdlock.c	2013-09-23 20:39:09.382221883 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_rwlock_tryrdlock.c	2013-09-23 20:39:32.970222861 -0400
@@ -19,6 +19,7 @@
 
 #include <errno.h>
 #include "pthreadP.h"
+#include <scheduleP.h>
 #include <lowlevellock.h>
 
 
@@ -26,6 +27,9 @@
 __pthread_rwlock_tryrdlock (
      pthread_rwlock_t *rwlock)
 {
+  return __sclib_rwlock_tryrdlock(&rwlock->sclib_rwlock);
+
+#if 0
   int result = EBUSY;
 
   lll_lock (rwlock->__data.__lock, rwlock->__data.__shared);
@@ -46,5 +50,6 @@
   lll_unlock (rwlock->__data.__lock, rwlock->__data.__shared);
 
   return result;
+#endif
 }
 strong_alias (__pthread_rwlock_tryrdlock, pthread_rwlock_tryrdlock)
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_rwlock_trywrlock.c uClibc-0.9.33-new/libpthread/nptl/pthread_rwlock_trywrlock.c
--- uClibc-0.9.33/libpthread/nptl/pthread_rwlock_trywrlock.c	2013-09-23 20:39:09.066221870 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_rwlock_trywrlock.c	2013-09-23 20:39:32.970222861 -0400
@@ -19,6 +19,7 @@
 
 #include <errno.h>
 #include "pthreadP.h"
+#include <scheduleP.h>
 #include <lowlevellock.h>
 
 
@@ -26,6 +27,9 @@
 __pthread_rwlock_trywrlock (
      pthread_rwlock_t *rwlock)
 {
+  return __sclib_rwlock_trywrlock(&rwlock->sclib_rwlock);
+
+#if 0
   int result = EBUSY;
 
   lll_lock (rwlock->__data.__lock, rwlock->__data.__shared);
@@ -39,5 +43,6 @@
   lll_unlock (rwlock->__data.__lock, rwlock->__data.__shared);
 
   return result;
+#endif
 }
 strong_alias (__pthread_rwlock_trywrlock, pthread_rwlock_trywrlock)
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_setschedparam.c uClibc-0.9.33-new/libpthread/nptl/pthread_setschedparam.c
--- uClibc-0.9.33/libpthread/nptl/pthread_setschedparam.c	2013-09-23 20:39:09.374221883 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_setschedparam.c	2013-09-23 20:39:32.970222861 -0400
@@ -31,6 +31,9 @@
      int policy,
      const struct sched_param *param)
 {
+  return 0;
+
+#if 0
   struct pthread *pd = (struct pthread *) threadid;
 
   /* Make sure the descriptor is valid.  */
@@ -71,5 +74,6 @@
   lll_unlock (pd->lock, LLL_PRIVATE);
 
   return result;
+#endif
 }
 strong_alias (__pthread_setschedparam, pthread_setschedparam)
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_setschedprio.c uClibc-0.9.33-new/libpthread/nptl/pthread_setschedprio.c
--- uClibc-0.9.33/libpthread/nptl/pthread_setschedprio.c	2013-09-23 20:39:09.070221871 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_setschedprio.c	2013-09-23 20:39:32.970222861 -0400
@@ -30,6 +30,9 @@
      pthread_t threadid,
      int prio)
 {
+  return 0;
+
+#if 0
   struct pthread *pd = (struct pthread *) threadid;
 
   /* Make sure the descriptor is valid.  */
@@ -63,4 +66,5 @@
   lll_unlock (pd->lock, LLL_PRIVATE);
 
   return result;
+#endif
 }
diff -urN uClibc-0.9.33/libpthread/nptl/pthread_timedjoin.c uClibc-0.9.33-new/libpthread/nptl/pthread_timedjoin.c
--- uClibc-0.9.33/libpthread/nptl/pthread_timedjoin.c	2013-09-23 20:39:09.106221872 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/pthread_timedjoin.c	2013-09-23 20:39:32.974222861 -0400
@@ -21,7 +21,7 @@
 #include <stdlib.h>
 #include <atomic.h>
 #include "pthreadP.h"
-
+#include "scheduleP.h"
 
 static void
 cleanup (void *arg)
@@ -79,7 +79,8 @@
 
 
   /* Wait for the child.  */
-  result = lll_timedwait_tid (pd->tid, abstime);
+  result = 0;
+  __sclib_sem_wait(&pd->exit_sem);
 
 
   /* Restore cancellation mode.  */
diff -urN uClibc-0.9.33/libpthread/nptl/schedule.c uClibc-0.9.33-new/libpthread/nptl/schedule.c
--- uClibc-0.9.33/libpthread/nptl/schedule.c	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libpthread/nptl/schedule.c	2013-09-23 20:39:32.974222861 -0400
@@ -0,0 +1,878 @@
+/**
+ * VM-Syscalls
+ * Copyright (c) 2013 Ruslan Nikolaev <rnikola@vt.edu>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <ucontext.h>
+#include <list.h>
+#include <lowlevellock.h>
+#include <descr.h>
+#include <stdio.h>
+#include <sys/mman.h>
+#include <scheduleP.h>
+#include <atomic.h>
+
+#include <bits/sclib.h>
+
+struct __sclib_futex_queue {
+	list_t list;
+	int *value;
+	struct pthread *thread;
+	unsigned int counter;
+};
+
+#define __SCLIB_PAGE_SIZE			4096UL
+#define __SCLIB_QUEUES_THRESHOLD	1024
+
+#define __SCLIB_FUTEX_TABLE_SIZE	256
+
+list_t __futex_table[__SCLIB_FUTEX_TABLE_SIZE];
+static struct syscall_queue __sclib_queues;
+static struct __sclib_mutex __futex_table_lock;
+static unsigned long __sclib_queues_num = 0;
+struct syscall_queue *__nptl_rqueue;
+
+#define __SCLIB_PTHREAD_BLOCKED_QUEUE	(__SCLIB_PTHREAD_BLOCKED + 0)
+#define __SCLIB_PTHREAD_BLOCKED_COND	(__SCLIB_PTHREAD_BLOCKED + 1)
+#define __SCLIB_PTHREAD_BLOCKED_FUTEX	(__SCLIB_PTHREAD_BLOCKED + 2)
+#define __SCLIB_PTHREAD
+
+#define SQUEUE_NULL	\
+	MAP_FAILED
+#define SQUEUE_ALLOC()	\
+	mmap(0, sizeof(struct syscall_queue), PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)
+#define SQUEUE_FREE(a)	\
+	munmap((a), sizeof(struct syscall_queue))
+
+#if 0
+
+static inline unsigned int __sclib_wq_create(void)
+{
+	long ret;
+	INTERNAL_SYSCALL_DECL(err);
+	ret = INTERNAL_SYSCALL(syscall_service_wq_create, err, 0);
+	if (INTERNAL_SYSCALL_ERROR_P(ret, err))
+		ret = -INTERNAL_SYSCALL_ERRNO(ret, err);
+	return ret;
+}
+
+static inline long __sclib_wq_destroy(unsigned int descriptor)
+{
+	long ret;
+	INTERNAL_SYSCALL_DECL(err);
+	ret = INTERNAL_SYSCALL(syscall_service_wq_destroy, err, 1, descriptor);
+	if (INTERNAL_SYSCALL_ERROR_P(ret, err))
+		ret = -INTERNAL_SYSCALL_ERRNO(ret, err);
+	return ret;
+}
+
+static inline void __sclib_wq_wake(unsigned int descriptor)
+{
+	long ret;
+	INTERNAL_SYSCALL_DECL(err);
+	ret = INTERNAL_SYSCALL(syscall_service_wq_wake, err, 1, descriptor);
+	if (INTERNAL_SYSCALL_ERROR_P(ret, err)) {
+		fprintf(stderr, "Cannot wake up from a waiting queue\n");
+		exit(1);
+	}
+}
+
+static inline size_t __sclib_wq_wait(struct syscall_queue *queue,
+	struct pthread **result)
+{
+	long ret;
+	INTERNAL_SYSCALL_DECL(err);
+	ret = INTERNAL_SYSCALL(syscall_service_wq_wait, err, 2, queue, result);
+	if (INTERNAL_SYSCALL_ERROR_P(ret, err)) {
+		fprintf(stderr, "Cannot waint on a waiting queue\n");
+		exit(1);
+	}
+	return ret;
+}
+#endif
+
+static bool __sclib_queue_add_mark(struct syscall_queue *queue, void *thread, bool mark)
+{
+	void *result;
+	size_t idx, res;
+
+	idx = syscall_queue_dequeue(queue->next, queue->entries, &queue->free_head,
+		&queue->free_tail, &result, SYSCALL_MAX_PTHREADS, false);
+	if ((ssize_t) idx < 0) {
+		fprintf(stderr, "ERROR: ready queue failure (1)!\n");
+		exit(1);
+	}
+	queue->entries[idx] = thread;
+	if ((res = syscall_queue_enqueue(queue->next, &queue->alloc_tail, idx, SYSCALL_MAX_PTHREADS, mark)) != 0) {
+		if (res == SYSCALL_NULL_ENTRY && syscall_queue_enqueue(queue->next,
+			&queue->free_tail, idx, SYSCALL_MAX_PTHREADS, false) == 0) {
+			return false;
+		}
+		fprintf(stderr, "ERROR: ready queue failure (2)!\n");
+		exit(1);
+	}
+	return true;
+}
+
+static void *__sclib_queue_remove_mark(struct syscall_queue *queue, bool mark)
+{
+	void *result;
+	size_t idx;
+
+	idx = syscall_queue_dequeue(queue->next, queue->entries, &queue->alloc_head,
+	        &queue->alloc_tail, &result, SYSCALL_MAX_PTHREADS, mark);
+	if (idx == SYSCALL_ERROR_ENTRY) {
+		fprintf(stderr, "ERROR: ready queue failure (3)!\n", queue);
+		exit(1);
+	}
+	if (idx == SYSCALL_NULL_ENTRY)
+		return NULL;
+	if (syscall_queue_enqueue(queue->next, &queue->free_tail, idx, SYSCALL_MAX_PTHREADS, false) != 0) {
+		fprintf(stderr, "ERROR: ready queue failure (4)!\n");
+		exit(1);
+	}
+	return result;
+}
+
+static inline void __sclib_unblock(struct pthread *thread)
+{
+	thread->state = __SCLIB_PTHREAD_RUNNING;
+	__sclib_queue_add(__nptl_rqueue, thread);
+}
+
+static void __sclib_enqueue(struct pthread *thread)
+{
+	struct syscall_queue *queue;
+	struct __sclib_futex_queue *futex;
+	struct __sclib_mutex *mutex;
+	syscall_entry_t *entry;
+	unsigned int id;
+
+	queue = KTHREAD_GETMEM(KTHREAD_SELF, current_queue);
+	if (queue != NULL) {
+		if (thread->state >= __SCLIB_PTHREAD_BLOCKED) {
+			if (thread->state == __SCLIB_PTHREAD_BLOCKED_QUEUE) {
+				if (!__sclib_queue_add_mark(queue, thread, true))
+					__sclib_unblock(thread);
+			} else if (thread->state == __SCLIB_PTHREAD_BLOCKED_FUTEX) {
+				futex = (struct __sclib_futex_queue *) queue;
+				if (atomic_decrement_and_test(&futex->counter)) {
+					__sclib_mutex_lock(&__futex_table_lock);
+					list_del(&futex->list);
+					__sclib_mutex_unlock(&__futex_table_lock);
+					free(futex);
+					__sclib_unblock(thread);
+				}
+			} else {
+				__sclib_queue_add_mark(queue, thread, false);
+				mutex = KTHREAD_GETMEM(KTHREAD_SELF, current_mutex);
+				__sclib_mutex_unlock(mutex);
+			}
+		} else {
+			__sclib_queue_add(queue, thread);
+		}
+	} else {
+		entry = KTHREAD_GETMEM(KTHREAD_SELF, current_entry);
+		do {
+			id = entry->id;
+			if (id == SYSCALL_ENTRY_DONE) { /* Already completed. */
+				__sclib_queue_add(__nptl_rqueue, entry->pd);
+				break;
+			}
+		} while (!__sync_bool_compare_and_swap(&entry->id, id, id + SYSCALL_ENTRY_RQUEUE));
+	}
+}
+
+static void __sclib_swapcontext(struct pthread *from, ucontext_t *to)
+{
+	struct pthread *thread;
+	ucontext_t *prev;
+
+	prev = swapcontextp(&from->context, to);
+	KTHREAD_SETMEM(KTHREAD_SELF, header.tcb, from);
+	if (prev == NULL) /* Came from __sclib_thread_loop(). */
+		return;
+	thread = container_of(prev, struct pthread, context);
+	__sclib_enqueue(thread);
+}
+
+attribute_protected
+#if !defined SHARED && !defined IS_IN_libpthread
+weak_function
+#endif
+void __sclib_schedule(int sysid, struct syscall_entry *entry)
+{
+	struct pthread *thread;
+	KTHREAD_SETMEM(KTHREAD_SELF, current_queue, NULL);
+	KTHREAD_SETMEM(KTHREAD_SELF, current_entry, entry);
+	thread = __sclib_queue_remove(__nptl_rqueue, false);
+	__sclib_swapcontext(THREAD_SELF, (thread != NULL) ? &thread->context : &KTHREAD_SELF->wait_context);
+}
+hidden_def(__sclib_schedule)
+
+static inline void __sclib_block(struct pthread *pd, size_t state)
+{
+	struct pthread *thread;
+	pd->state = state;
+	thread = __sclib_queue_remove(__nptl_rqueue, false);
+	if (thread != NULL) {
+		thread->state = __SCLIB_PTHREAD_RUNNING;
+		__sclib_swapcontext(pd, &thread->context);
+		return;
+	}
+	__sclib_swapcontext(pd, &KTHREAD_SELF->wait_context);
+}
+
+attribute_hidden
+void __sclib_schedule_init(struct syscall_queue *rqueue)
+{
+	size_t i;
+
+	sclib_queue_init(&__sclib_queues);
+	__nptl_rqueue = rqueue;
+	if (__sclib_mutex_init(&__futex_table_lock, __SCLIB_MUTEX_NORMAL) != 0) {
+		fprintf(stderr, "Cannot initialize futex table lock!\n");
+		exit(1);
+	}
+	for (i = 0; i < __SCLIB_FUTEX_TABLE_SIZE; i++) {
+		INIT_LIST_HEAD(&__futex_table[i]);
+	}
+	__sync_synchronize();
+}
+
+attribute_hidden
+void __sclib_initial_switch(struct pthread *from, struct pthread *to)
+{
+	KTHREAD_SETMEM(KTHREAD_SELF, current_queue, __nptl_rqueue);
+	__sclib_swapcontext(from, &to->context);
+}
+
+attribute_hidden
+void __sclib_initial_add(struct pthread *thread)
+{
+	__sclib_queue_add(__nptl_rqueue, thread);
+}
+
+attribute_hidden
+void __sclib_yield(void)
+{
+	struct pthread *thread;
+	thread = __sclib_queue_remove(__nptl_rqueue, false);
+	if (thread != NULL) {
+		thread->state = __SCLIB_PTHREAD_RUNNING;
+		KTHREAD_SETMEM(KTHREAD_SELF, current_queue, __nptl_rqueue);
+		__sclib_swapcontext(THREAD_SELF, &thread->context);
+	}
+}
+
+static struct syscall_queue *__sclib_alloc_queue(void)
+{
+	struct syscall_queue *queue;
+
+	queue = __sclib_queue_remove_mark(&__sclib_queues, false);
+	if (!queue) {
+		queue = SQUEUE_ALLOC();
+		if (queue == SQUEUE_NULL)
+			return NULL;
+		sclib_queue_init(queue);
+	} else {
+		atomic_decrement(&__sclib_queues_num);
+	}
+	return queue;
+}
+
+static void __sclib_free_queue(struct syscall_queue *queue)
+{
+	if (VOLATILE_READ(__sclib_queues_num) >= __SCLIB_QUEUES_THRESHOLD) {
+		SQUEUE_FREE(queue);
+		return;
+	}
+	atomic_increment(&__sclib_queues_num);
+#ifdef SYSCALL_DEBUG
+	if (syscall_queue_check(queue->next, &queue->alloc_head, &queue->alloc_tail, SYSCALL_MAX_PTHREADS) != SYSCALL_NULL_ENTRY) {
+		fprintf(stderr, "Invalid use of POSIX locks!\n");
+		exit(1);
+	}
+#endif
+	__sclib_queue_add_mark(&__sclib_queues, queue, false);
+}
+
+static inline long __sclib_lazy_queue(struct syscall_queue **pqueue)
+{
+	struct syscall_queue *queue;
+
+	if (*pqueue == NULL) {
+		if ((queue = __sclib_alloc_queue()) == NULL)
+			return ENOMEM;
+		if (atomic_compare_and_exchange_bool_acq(pqueue,
+			queue, NULL)) {
+			__sclib_free_queue(queue);
+		}
+	}
+	return 0;
+}
+
+long
+attribute_protected
+__sclib_mutex_auto_init(struct __sclib_mutex_auto *mutex, int kind)
+{
+	mutex->kind = kind;
+	mutex->recur_count = 0;
+	mutex->owner = NULL;
+	mutex->value = 0;
+	__sync_synchronize();
+	return 0;
+}
+INTDEF(__sclib_mutex_auto_init)
+
+void
+attribute_protected
+__sclib_mutex_auto_destroy(struct __sclib_mutex_auto *mutex)
+{
+	struct syscall_queue *queue;
+	queue = (struct syscall_queue *)
+		(VOLATILE_READ(mutex->value) & ~(__SCLIB_PAGE_SIZE - 1));
+	if (queue != NULL)
+		__sclib_free_queue(queue);
+}
+INTDEF(__sclib_mutex_auto_destroy)
+
+long
+attribute_protected
+__sclib_mutex_auto_reinit(struct __sclib_mutex_auto *mutex)
+{
+	__sclib_mutex_auto_destroy(mutex);
+	mutex->recur_count = 0;
+	mutex->owner = NULL;
+	mutex->value = 0;
+	__sync_synchronize();
+	return 0;
+}
+INTDEF(__sclib_mutex_auto_reinit)
+
+static inline long __sclib_get_queue(unsigned long *pvalue, unsigned long value,
+	struct syscall_queue **qptr)
+{
+	struct syscall_queue *queue, *nqueue;
+	unsigned long oldvalue;
+
+	queue = (struct syscall_queue *) (value & ~(__SCLIB_PAGE_SIZE - 1));
+	if (queue != NULL) {
+		*qptr = queue;
+		return 0;
+	}
+
+	/* Allocate a queue. */
+	if ((nqueue = __sclib_alloc_queue()) == NULL)
+		return ENOMEM;
+
+	while ((oldvalue = atomic_compare_and_exchange_val_acq(pvalue,
+			value + (unsigned long) nqueue, value)) != value) {
+		value = oldvalue;
+		queue = (struct syscall_queue *) (value & ~(__SCLIB_PAGE_SIZE - 1));
+		if (queue != NULL) {
+			__sclib_free_queue(nqueue);
+			*qptr = queue;
+			return 0;
+		}
+	}
+
+	*qptr = nqueue;
+	return 0;
+}
+
+long
+attribute_protected
+__sclib_mutex_auto_lock(struct __sclib_mutex_auto *mutex)
+{
+	struct pthread *self = THREAD_SELF;
+	struct syscall_queue *queue;
+	unsigned long value;
+	long err;
+
+	if (mutex->kind == __SCLIB_MUTEX_RECURSIVE && mutex->owner == self) {
+		mutex->recur_count++;
+		return 0;
+	}
+	value = atomic_exchange_and_add(&mutex->value, 1);
+	if ((value & (__SCLIB_PAGE_SIZE - 1)) != 0) {
+		if ((err = __sclib_get_queue(&mutex->value, value + 1, &queue)) != 0)
+			return err;
+		KTHREAD_SETMEM(KTHREAD_SELF, current_queue, queue);
+		__sclib_block(THREAD_SELF, __SCLIB_PTHREAD_BLOCKED_QUEUE);
+	}
+	mutex->recur_count++;
+	mutex->owner = self;
+	return 0;
+}
+INTDEF(__sclib_mutex_auto_lock)
+
+long
+attribute_protected
+__sclib_mutex_auto_trylock(struct __sclib_mutex_auto *mutex)
+{
+	struct pthread *self = THREAD_SELF;
+	unsigned long value;
+
+	if (mutex->kind == __SCLIB_MUTEX_RECURSIVE && mutex->owner == self) {
+		mutex->recur_count++;
+		return 0;
+	}
+	do {
+		value = VOLATILE_READ(mutex->value);
+		if ((value & (__SCLIB_PAGE_SIZE - 1)) != 0)
+			return EBUSY;
+	} while (atomic_compare_and_exchange_bool_acq(&mutex->value,
+		value + 1, value));
+	mutex->recur_count++;
+	mutex->owner = self;
+	return 0;
+}
+INTDEF(__sclib_mutex_auto_trylock)
+
+long
+attribute_protected
+__sclib_mutex_auto_unlock(struct __sclib_mutex_auto *mutex)
+{
+	struct pthread *thread;
+	struct syscall_queue *queue;
+	unsigned long value, newvalue, counter;
+	long err;
+
+	if (--mutex->recur_count != 0)
+		return 0;
+	mutex->owner = NULL;
+
+	do {
+		value = VOLATILE_READ(mutex->value);
+		newvalue = value - 1;
+		counter = newvalue & (__SCLIB_PAGE_SIZE - 1);
+		if (counter == 0)
+			newvalue = 0;
+	} while (atomic_compare_and_exchange_bool_acq(&mutex->value,
+		newvalue, value));
+
+	if (counter != 0) {
+		if ((err = __sclib_get_queue(&mutex->value, newvalue, &queue)) != 0)
+			return err;
+		thread = __sclib_queue_remove_mark(queue, true);
+		if (thread)
+			__sclib_unblock(thread);
+	} else {
+		queue = (struct syscall_queue *) (value - 1);
+		if (queue != NULL)
+			__sclib_free_queue(queue);
+	}
+
+	return 0;
+}
+INTDEF(__sclib_mutex_auto_unlock)
+
+attribute_hidden
+long __sclib_mutex_init(struct __sclib_mutex *mutex, int kind)
+{
+	mutex->counter = 0;
+	mutex->kind = kind;
+	mutex->recur_count = 0;
+	mutex->owner = NULL;
+	mutex->queue = __sclib_alloc_queue();
+	if (mutex->queue == NULL)
+		return ENOMEM;
+	__sync_synchronize();
+	return 0;
+}
+
+attribute_hidden
+long __sclib_mutex_reinit(struct __sclib_mutex *mutex)
+{
+	mutex->counter = 0;
+	mutex->recur_count = 0;
+	mutex->owner = NULL;
+	if (!mutex->queue) {
+		mutex->queue = __sclib_alloc_queue();
+		if (mutex->queue == NULL)
+			return ENOMEM;
+	} else {
+		sclib_queue_init(mutex->queue);
+	}
+	__sync_synchronize();
+	return 0;
+}
+
+attribute_hidden
+void __sclib_mutex_destroy(struct __sclib_mutex *mutex)
+{
+	if (mutex->queue)
+		__sclib_free_queue(mutex->queue);
+}
+
+attribute_hidden
+long __sclib_mutex_lock(struct __sclib_mutex *mutex)
+{
+	struct pthread *self = THREAD_SELF;
+	long err;
+
+	if (mutex->kind == __SCLIB_MUTEX_RECURSIVE && mutex->owner == self) {
+		mutex->recur_count++;
+		return 0;
+	}
+	if (atomic_increment_val(&mutex->counter) != 1) {
+		if ((err = __sclib_lazy_queue(&mutex->queue)) != 0)
+			return err;
+		KTHREAD_SETMEM(KTHREAD_SELF, current_queue, mutex->queue);
+		__sclib_block(THREAD_SELF, __SCLIB_PTHREAD_BLOCKED_QUEUE);
+	}
+	mutex->recur_count++;
+	mutex->owner = self;
+	return 0;
+}
+
+attribute_hidden
+long __sclib_mutex_trylock(struct __sclib_mutex *mutex)
+{
+	struct pthread *self = THREAD_SELF;
+	unsigned int counter;
+
+	if (mutex->kind == __SCLIB_MUTEX_RECURSIVE && mutex->owner == self) {
+		mutex->recur_count++;
+		return 0;
+	}
+	do {
+		counter = mutex->counter;
+		if (counter != 0)
+			return EBUSY;
+	} while (atomic_compare_and_exchange_bool_acq(&mutex->counter,
+		counter + 1, counter));
+	mutex->recur_count++;
+	mutex->owner = self;
+	return 0;
+}
+
+attribute_hidden
+long __sclib_mutex_unlock(struct __sclib_mutex *mutex)
+{
+	struct pthread *thread;
+	long err;
+
+	if (--mutex->recur_count != 0)
+		return 0;
+	mutex->owner = NULL;
+	if (!atomic_decrement_and_test(&mutex->counter)) {
+		if ((err = __sclib_lazy_queue(&mutex->queue)) != 0)
+			return err;
+		thread = __sclib_queue_remove_mark(mutex->queue, true);
+		if (thread)
+			__sclib_unblock(thread);
+	}
+	return 0;
+}
+
+static inline size_t __sclib_futex_hash(int *ptr)
+{
+	size_t val = (size_t) ptr;
+	return (val >> 4) % __SCLIB_FUTEX_TABLE_SIZE;
+}
+
+attribute_protected
+#if !defined SHARED && !defined IS_IN_libpthread
+weak_function
+#endif
+long __sclib_futex_wait(int *ptr, int val)
+{
+	struct __sclib_futex_queue *futex;
+	struct pthread *thread = THREAD_SELF;
+	size_t idx;
+
+	futex = malloc(sizeof(struct __sclib_futex_queue));
+	if (futex == NULL)
+		return ENOMEM;
+	futex->counter = 0x80000000;
+	futex->value = ptr;
+	futex->thread = thread;
+	idx = __sclib_futex_hash(ptr);
+	__sclib_mutex_lock(&__futex_table_lock);
+	if (*ptr != val) {
+		__sclib_mutex_unlock(&__futex_table_lock);
+		free(futex);
+		return 0;
+	}
+	list_add(&futex->list, &__futex_table[idx]);
+	__sclib_mutex_unlock(&__futex_table_lock);
+	KTHREAD_SETMEM(KTHREAD_SELF, current_queue, futex);
+	__sclib_block(thread, __SCLIB_PTHREAD_BLOCKED_FUTEX);
+	return 0;
+}
+hidden_def(__sclib_futex_wait)
+
+attribute_protected
+#if !defined SHARED && !defined IS_IN_libpthread
+weak_function
+#endif
+long __sclib_futex_wake(int *ptr, int val)
+{
+	struct pthread *thread;
+	struct __sclib_futex_queue *futex;
+	size_t idx;
+	list_t *entry, *p;
+
+	idx = __sclib_futex_hash(ptr);
+	__sclib_mutex_lock(&__futex_table_lock);
+	list_for_each_safe(entry, p, &__futex_table[idx]) {
+		futex = list_entry(entry, struct __sclib_futex_queue, list);
+		if (futex->value == ptr && futex->counter > 1) {
+			if (atomic_add_zero(&futex->counter, 0x80000001)) {
+				list_del(&futex->list);
+				thread = futex->thread;
+				free(futex);
+				__sclib_unblock(thread);
+			}
+			if (--val == 0)
+				break;
+		}
+	}
+	__sclib_mutex_unlock(&__futex_table_lock);
+	return 0;
+}
+hidden_def(__sclib_futex_wake)
+
+attribute_hidden
+long __sclib_cond_init(struct __sclib_cond *cond)
+{
+	if ((cond->queue = __sclib_alloc_queue()) == NULL)
+		return ENOMEM;
+	__sync_synchronize();
+	return 0;
+}
+
+attribute_hidden
+long __sclib_cond_wait(struct __sclib_cond *cond, struct __sclib_mutex *mutex)
+{
+	long err;
+	if ((err = __sclib_lazy_queue(&cond->queue)) != 0)
+		return err;
+	KTHREAD_SETMEM(KTHREAD_SELF, current_queue, cond->queue);
+	KTHREAD_SETMEM(KTHREAD_SELF, current_mutex, mutex);
+	__sclib_block(THREAD_SELF, __SCLIB_PTHREAD_BLOCKED_COND);
+	return __sclib_mutex_lock(mutex);
+}
+
+attribute_hidden
+long __sclib_cond_signal(struct __sclib_cond *cond)
+{
+	struct pthread *thread;
+	long err;
+	if ((err = __sclib_lazy_queue(&cond->queue)) != 0)
+		return err;
+	thread = __sclib_queue_remove_mark(cond->queue, false);
+	if (thread)
+		__sclib_unblock(thread);
+	return 0;
+}
+
+attribute_hidden
+long __sclib_cond_broadcast(struct __sclib_cond *cond)
+{
+	struct pthread *thread;
+	long err;
+	if ((err = __sclib_lazy_queue(&cond->queue)) != 0)
+		return err;
+	while ((thread = __sclib_queue_remove_mark(cond->queue, false)) != NULL)
+		__sclib_unblock(thread);
+	return 0;
+}
+
+attribute_hidden
+void __sclib_cond_destroy(struct __sclib_cond *cond)
+{
+	if (cond->queue)
+		__sclib_free_queue(cond->queue);
+}
+
+attribute_hidden
+long __sclib_sem_init(struct __sclib_sem *sem, unsigned int val)
+{
+	if ((sem->queue = __sclib_alloc_queue()) == NULL)
+		return ENOMEM;
+	sem->value = val;
+	__sync_synchronize();
+	return 0;
+}
+
+attribute_hidden
+void __sclib_sem_destroy(struct __sclib_sem *sem)
+{
+	__sclib_free_queue(sem->queue);
+}
+
+attribute_hidden
+long __sclib_sem_wait(struct __sclib_sem *sem)
+{
+	if (atomic_decrement_val(&sem->value) < 0) {
+		KTHREAD_SETMEM(KTHREAD_SELF, current_queue, sem->queue);
+		__sclib_block(THREAD_SELF, __SCLIB_PTHREAD_BLOCKED_QUEUE);
+	}
+	return 0;
+}
+
+attribute_hidden
+long __sclib_sem_trywait(struct __sclib_sem *sem)
+{
+	long value;
+
+	do {
+		value = sem->value;
+		if (value <= 0)
+			return EAGAIN;
+	} while (atomic_compare_and_exchange_bool_acq(&sem->value,
+		value - 1, value));
+	return 0;
+}
+
+attribute_hidden
+long __sclib_sem_post(struct __sclib_sem *sem)
+{
+	struct pthread *thread;
+
+	if (atomic_increment_val(&sem->value) <= 0) {
+		thread = __sclib_queue_remove_mark(sem->queue, true);
+		if (thread)
+			__sclib_unblock(thread);
+	}
+	return 0;
+}
+
+attribute_hidden
+long __sclib_rwlock_init(struct __sclib_rwlock *rwlock)
+{
+	long err;
+	rwlock->readers = 0;
+	rwlock->writer = 0;
+	if ((err = __sclib_mutex_init(&rwlock->access_mutex, __SCLIB_MUTEX_NORMAL)) != 0)
+		return err;
+	return __sclib_mutex_init(&rwlock->wait_mutex, __SCLIB_MUTEX_NORMAL);
+}
+
+attribute_hidden
+void __sclib_rwlock_destroy(struct __sclib_rwlock *rwlock)
+{
+	__sclib_mutex_destroy(&rwlock->access_mutex);
+	__sclib_mutex_destroy(&rwlock->wait_mutex);
+}
+
+attribute_hidden
+long __sclib_rwlock_rdlock(struct __sclib_rwlock *rwlock)
+{
+	__sclib_mutex_lock(&rwlock->wait_mutex);
+	if (atomic_increment_val(&rwlock->readers) == 1) {
+		__sclib_mutex_lock(&rwlock->access_mutex);
+		rwlock->writer = 0;
+	}
+	__sclib_mutex_unlock(&rwlock->wait_mutex);
+	return 0;
+}
+
+attribute_hidden
+long __sclib_rwlock_tryrdlock(struct __sclib_rwlock *rwlock)
+{
+	long err;
+	if ((err = __sclib_mutex_trylock(&rwlock->wait_mutex)) != 0)
+		return err;
+	if (atomic_increment_val(&rwlock->readers) == 1) {
+		if ((err = __sclib_mutex_trylock(&rwlock->access_mutex)) != 0)
+			atomic_decrement(&rwlock->readers);
+		else
+			rwlock->writer = 0;
+	}
+	__sclib_mutex_unlock(&rwlock->wait_mutex);
+	return err;
+}
+
+attribute_hidden
+long __sclib_rwlock_trywrlock(struct __sclib_rwlock *rwlock)
+{
+	long err;
+	if ((err = __sclib_mutex_trylock(&rwlock->wait_mutex)) != 0)
+		return err;
+	if ((err = __sclib_mutex_trylock(&rwlock->access_mutex)) == 0)
+		rwlock->writer = 1;
+	__sclib_mutex_unlock(&rwlock->wait_mutex);
+	return err;
+}
+
+attribute_hidden
+long __sclib_rwlock_wrlock(struct __sclib_rwlock *rwlock)
+{
+	__sclib_mutex_lock(&rwlock->wait_mutex);
+	__sclib_mutex_lock(&rwlock->access_mutex);
+	rwlock->writer = 1;
+	__sclib_mutex_unlock(&rwlock->wait_mutex);
+	return 0;
+}
+
+attribute_hidden
+void __sclib_rwlock_unlock(struct __sclib_rwlock *rwlock)
+{
+	if (rwlock->writer || atomic_decrement_and_test(&rwlock->readers))
+		__sclib_mutex_unlock(&rwlock->access_mutex);
+}
+
+static void __sclib_exit_context(struct kpthread *kpd)
+{
+	struct pthread *pd = THREAD_SELF;
+
+	/* Deallocate old thread */
+	if (IS_DETACHED(pd)) {
+		pd->tid = -1;
+	} else {
+		__sclib_sem_post(&pd->exit_sem);
+	}
+	pd = __sclib_queue_remove(__nptl_rqueue, true);
+	setcontextp(&pd->context, &kpd->context);
+}
+
+static void __sclib_wait_context(struct kpthread *kpd)
+{
+	struct pthread *thread;
+	__sclib_enqueue(THREAD_SELF);
+	thread = __sclib_queue_remove(__nptl_rqueue, true);
+	setcontextp(&thread->context, &kpd->wait_context);
+}
+
+attribute_hidden
+void __sclib_kthread_init(struct kpthread *kpd)
+{
+	getcontext(&kpd->context);
+	makecontext(&kpd->context, (void (*) (void)) __sclib_exit_context, 1, kpd);
+	memcpy(&kpd->wait_context.uc_sigmask, &kpd->context.uc_sigmask, sizeof(kpd->context.uc_sigmask));
+	memcpy(&kpd->wait_context.uc_mcontext, &kpd->context.uc_mcontext, sizeof(kpd->context.uc_mcontext));
+	memcpy(&kpd->wait_context.uc_stack, &kpd->context.uc_stack, sizeof(kpd->context.uc_stack));
+	memcpy(&kpd->wait_context.__fpregs_mem, &kpd->context.__fpregs_mem, sizeof(kpd->context.__fpregs_mem));
+	makecontext(&kpd->wait_context, (void (*) (void)) __sclib_wait_context, 1, kpd);
+}
+
+attribute_hidden
+void __sclib_thread_init(struct pthread *pd, struct kpthread *kpd)
+{
+	memcpy(&pd->context.uc_sigmask, &kpd->context.uc_sigmask, sizeof(kpd->context.uc_sigmask));
+	memcpy(&pd->context.uc_mcontext, &kpd->context.uc_mcontext, sizeof(kpd->context.uc_mcontext));
+	memcpy(&pd->context.__fpregs_mem, &kpd->context.__fpregs_mem, sizeof(kpd->context.__fpregs_mem));
+	pd->state = __SCLIB_PTHREAD_RUNNING;
+}
diff -urN uClibc-0.9.33/libpthread/nptl/schedule_defsP.h uClibc-0.9.33-new/libpthread/nptl/schedule_defsP.h
--- uClibc-0.9.33/libpthread/nptl/schedule_defsP.h	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libpthread/nptl/schedule_defsP.h	2013-09-23 20:39:32.974222861 -0400
@@ -0,0 +1,65 @@
+/**
+ * VM-Syscalls
+ * Copyright (c) 2013 Ruslan Nikolaev <rnikola@vt.edu>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef __SCLIB_SCHEDULE_DEFS_P_H
+#define __SCLIB_SCHEDULE_DEFS_P_H
+
+struct syscall_queue;
+struct pthread;
+
+#define __SCLIB_MUTEX_NORMAL	0
+#define __SCLIB_MUTEX_RECURSIVE	1
+
+struct __sclib_mutex_auto {
+	unsigned long value;
+	struct pthread *owner;
+	unsigned int kind; /* For compatibility with a static initializer. */
+	unsigned int recur_count;
+};
+
+struct __sclib_mutex {
+	struct syscall_queue *queue;
+	struct pthread *owner;
+	unsigned short kind; /* For compatibility with a static initializer. */
+	unsigned short recur_count;
+	unsigned int counter;
+};
+
+struct __sclib_sem {
+	struct syscall_queue *queue;
+	long value;
+};
+
+struct __sclib_rwlock {
+	struct __sclib_mutex access_mutex;
+	struct __sclib_mutex wait_mutex;
+	unsigned char pad; /* For compatibility with a static initializer. */
+	unsigned char writer;
+	unsigned short readers;
+};
+
+struct __sclib_cond {
+	struct syscall_queue *queue;
+};
+
+#endif
diff -urN uClibc-0.9.33/libpthread/nptl/scheduleP.h uClibc-0.9.33-new/libpthread/nptl/scheduleP.h
--- uClibc-0.9.33/libpthread/nptl/scheduleP.h	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libpthread/nptl/scheduleP.h	2013-09-23 20:39:32.974222861 -0400
@@ -0,0 +1,121 @@
+/**
+ * VM-Syscalls
+ * Copyright (c) 2013 Ruslan Nikolaev <rnikola@vt.edu>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef __SCLIB_SCHEDULEP_H
+#define __SCLIB_SCHEDULEP_H
+
+#include <sys/types.h>
+#include <stdbool.h>
+#include <ucontext.h>
+#include <libc-symbols.h>
+#include "schedule_defsP.h"
+
+#define __SCLIB_PTHREAD_RUNNING		0
+#define __SCLIB_PTHREAD_COMPLETE	1
+#define __SCLIB_PTHREAD_BLOCKED		2	/* Must be last */
+
+struct pthread;
+struct kpthread;
+struct syscall_entry;
+struct syscall_queue;
+
+extern size_t __sclib_num_kthreads attribute_hidden;
+extern struct syscall_queue *__nptl_rqueue
+#ifdef SHARED
+attribute_hidden
+#else
+__attribute ((weak))
+#endif
+;
+
+extern void __sclib_schedule_init(struct syscall_queue *rqueue) attribute_hidden;
+extern void __sclib_initial_switch(struct pthread *from, struct pthread *to) attribute_hidden;
+extern void __sclib_initial_add(struct pthread *thread) attribute_hidden;
+extern void __sclib_yield(void) attribute_hidden;
+extern long __sclib_mutex_init(struct __sclib_mutex *mutex, int kind) attribute_hidden;
+extern long __sclib_mutex_reinit(struct __sclib_mutex *mutex) attribute_hidden;
+extern void __sclib_mutex_destroy(struct __sclib_mutex *mutex) attribute_hidden;
+extern long __sclib_mutex_lock(struct __sclib_mutex *mutex) attribute_hidden;
+extern long __sclib_mutex_trylock(struct __sclib_mutex *mutex) attribute_hidden;
+extern long __sclib_mutex_unlock(struct __sclib_mutex *mutex) attribute_hidden;
+extern long __sclib_cond_init(struct __sclib_cond *cond) attribute_hidden;
+extern long __sclib_cond_wait(struct __sclib_cond *cond, struct __sclib_mutex *mutex) attribute_hidden;
+extern long __sclib_cond_signal(struct __sclib_cond *cond) attribute_hidden;
+extern long __sclib_cond_broadcast(struct __sclib_cond *cond) attribute_hidden;
+extern void __sclib_cond_destroy(struct __sclib_cond *cond) attribute_hidden;
+extern long __sclib_sem_init(struct __sclib_sem *sem, unsigned int val) attribute_hidden;
+extern void __sclib_sem_destroy(struct __sclib_sem *sem) attribute_hidden;
+extern long __sclib_sem_wait(struct __sclib_sem *sem) attribute_hidden;
+extern long __sclib_sem_trywait(struct __sclib_sem *sem) attribute_hidden;
+extern long __sclib_sem_post(struct __sclib_sem *sem) attribute_hidden;
+extern long __sclib_rwlock_init(struct __sclib_rwlock *rwlock) attribute_hidden;
+extern void __sclib_rwlock_destroy(struct __sclib_rwlock *rwlock) attribute_hidden;
+extern long __sclib_rwlock_rdlock(struct __sclib_rwlock *rwlock) attribute_hidden;
+extern long __sclib_rwlock_tryrdlock(struct __sclib_rwlock *rwlock) attribute_hidden;
+extern long __sclib_rwlock_wrlock(struct __sclib_rwlock *rwlock) attribute_hidden;
+extern long __sclib_rwlock_trywrlock(struct __sclib_rwlock *rwlock) attribute_hidden;
+extern void __sclib_rwlock_unlock(struct __sclib_rwlock *rwlock) attribute_hidden;
+extern long __sclib_futex_wait(int *ptr, int val)
+#if !defined SHARED && !defined IS_IN_libpthread
+	weak_function
+#endif
+;
+extern long __sclib_futex_wake(int *ptr, int val)
+#if !defined SHARED && !defined IS_IN_libpthread
+	weak_function
+#endif
+;
+extern void __sclib_schedule(int sysid, struct syscall_entry *entry)
+#if !defined SHARED && !defined IS_IN_libpthread
+	weak_function
+#endif
+;
+
+extern long __sclib_mutex_auto_init(struct __sclib_mutex_auto *mutex, int kind);
+extern long __sclib_mutex_auto_init_internal(struct __sclib_mutex_auto *mutex, int kind);
+
+extern long __sclib_mutex_auto_reinit(struct __sclib_mutex_auto *mutex);
+extern long __sclib_mutex_auto_reinit_internal(struct __sclib_mutex_auto *mutex);
+
+extern void __sclib_mutex_auto_destroy(struct __sclib_mutex_auto *mutex);
+extern void __sclib_mutex_auto_destroy_internal(struct __sclib_mutex_auto *mutex);
+
+extern long __sclib_mutex_auto_lock(struct __sclib_mutex_auto *mutex);
+extern long __sclib_mutex_auto_lock_internal(struct __sclib_mutex_auto *mutex);
+
+extern long __sclib_mutex_auto_trylock(struct __sclib_mutex_auto *mutex);
+extern long __sclib_mutex_auto_trylock_internal(struct __sclib_mutex_auto *mutex);
+
+extern long __sclib_mutex_auto_unlock(struct __sclib_mutex_auto *mutex);
+extern long __sclib_mutex_auto_unlock_internal(struct __sclib_mutex_auto *mutex);
+
+extern void __sclib_kthread_init(struct kpthread *kpd) attribute_hidden;
+extern void __sclib_thread_init(struct pthread *pd, struct kpthread *kpd) attribute_hidden;
+
+#if defined NOT_IN_libc && defined IS_IN_libpthread
+hidden_proto (__sclib_futex_wait)
+hidden_proto (__sclib_futex_wake)
+hidden_proto (__sclib_schedule)
+#endif
+
+#endif
diff -urN uClibc-0.9.33/libpthread/nptl/semaphore.h uClibc-0.9.33-new/libpthread/nptl/semaphore.h
--- uClibc-0.9.33/libpthread/nptl/semaphore.h	2013-09-23 20:39:09.070221871 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/semaphore.h	2013-09-23 20:39:32.974222861 -0400
@@ -59,8 +59,8 @@
 
    This function is a cancellation point and therefore not marked with
    __THROW.  */
-extern int sem_timedwait (sem_t *__restrict __sem,
-			  __const struct timespec *__restrict __abstime);
+/* extern int sem_timedwait (sem_t *__restrict __sem,
+			  __const struct timespec *__restrict __abstime); */
 #endif
 
 /* Test whether SEM is posted.  */
diff -urN uClibc-0.9.33/libpthread/nptl/semaphoreP.h uClibc-0.9.33-new/libpthread/nptl/semaphoreP.h
--- uClibc-0.9.33/libpthread/nptl/semaphoreP.h	2013-09-23 20:39:09.066221870 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/semaphoreP.h	2013-09-23 20:39:32.974222861 -0400
@@ -48,7 +48,7 @@
 extern void *__sem_mappings attribute_hidden;
 
 /* Lock to protect the search tree.  */
-extern int __sem_mappings_lock attribute_hidden;
+extern lll_lock_t __sem_mappings_lock attribute_hidden;
 
 
 /* Initializer for mountpoint.  */
diff -urN uClibc-0.9.33/libpthread/nptl/sem_close.c uClibc-0.9.33-new/libpthread/nptl/sem_close.c
--- uClibc-0.9.33/libpthread/nptl/sem_close.c	2013-09-23 20:39:09.378221883 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sem_close.c	2013-09-23 20:39:32.974222861 -0400
@@ -21,7 +21,7 @@
 #include <search.h>
 #include <sys/mman.h>
 #include "semaphoreP.h"
-
+#include "scheduleP.h"
 
 /* Global variables to parametrize the walk function.  This works
    since we always have to use locks.  And we have to use the twalk
@@ -62,6 +62,7 @@
 	  /* Remove the record from the tree.  */
 	  (void) tdelete (rec, &__sem_mappings, __sem_search);
 
+      __sclib_sem_destroy (&rec->sem->sclib_sem);
 	  result = munmap (rec->sem, sizeof (sem_t));
 
 	  free (rec);
diff -urN uClibc-0.9.33/libpthread/nptl/sem_destroy.c uClibc-0.9.33-new/libpthread/nptl/sem_destroy.c
--- uClibc-0.9.33/libpthread/nptl/sem_destroy.c	2013-09-23 20:39:09.066221870 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sem_destroy.c	2013-09-23 20:39:32.974222861 -0400
@@ -19,7 +19,7 @@
 
 #include <semaphore.h>
 #include "semaphoreP.h"
-
+#include "scheduleP.h"
 
 int
 __new_sem_destroy (
@@ -27,7 +27,7 @@
 {
   /* XXX Check for valid parameter.  */
 
-  /* Nothing to do.  */
+  __sclib_sem_destroy(&sem->sclib_sem);
   return 0;
 }
 weak_alias(__new_sem_destroy, sem_destroy)
diff -urN uClibc-0.9.33/libpthread/nptl/sem_getvalue.c uClibc-0.9.33-new/libpthread/nptl/sem_getvalue.c
--- uClibc-0.9.33/libpthread/nptl/sem_getvalue.c	2013-09-23 20:39:09.066221870 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sem_getvalue.c	2013-09-23 20:39:32.974222861 -0400
@@ -20,17 +20,20 @@
 #include <semaphore.h>
 #include "semaphoreP.h"
 
-
 int
 __new_sem_getvalue (
      sem_t *sem,
      int *sval)
 {
+#if 0
   struct new_sem *isem = (struct new_sem *) sem;
 
   /* XXX Check for valid SEM parameter.  */
 
   *sval = isem->value;
+#endif
+
+  *sval = sem->sclib_sem.value;
 
   return 0;
 }
diff -urN uClibc-0.9.33/libpthread/nptl/sem_init.c uClibc-0.9.33-new/libpthread/nptl/sem_init.c
--- uClibc-0.9.33/libpthread/nptl/sem_init.c	2013-09-23 20:39:09.378221883 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sem_init.c	2013-09-23 20:39:32.974222861 -0400
@@ -21,6 +21,7 @@
 #include <semaphore.h>
 #include <lowlevellock.h>
 #include "semaphoreP.h"
+#include "scheduleP.h"
 #include <bits/kernel-features.h>
 
 
@@ -30,6 +31,8 @@
      int pshared,
      unsigned int value)
 {
+  long err;
+
   /* Parameter sanity check.  */
   if (__builtin_expect (value > SEM_VALUE_MAX, 0))
     {
@@ -37,6 +40,15 @@
       return -1;
     }
 
+  err = __sclib_sem_init(&sem->sclib_sem, value);
+  if (__builtin_expect (err != 0, 0))
+    {
+      __set_errno (err);
+      return -1;
+    }
+  return 0;
+
+#if 0
   /* Map to the internal type.  */
   struct new_sem *isem = (struct new_sem *) sem;
 
@@ -52,5 +64,6 @@
   isem->nwaiters = 0;
 
   return 0;
+#endif
 }
 weak_alias(__new_sem_init, sem_init)
diff -urN uClibc-0.9.33/libpthread/nptl/sem_open.c uClibc-0.9.33-new/libpthread/nptl/sem_open.c
--- uClibc-0.9.33/libpthread/nptl/sem_open.c	2013-09-23 20:39:09.106221872 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sem_open.c	2013-09-23 20:39:32.974222861 -0400
@@ -1,4 +1,5 @@
 /* Copyright (C) 2002, 2003, 2006, 2007, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -36,6 +37,8 @@
 #include "semaphoreP.h"
 #include "../../libc/misc/internals/tempname.h"
 
+#include <bits/sclib.h>
+#include <bits/sclib_syscalls.h>
 
 /* Compatibility defines. */
 #define __endmntent                    endmntent
@@ -164,7 +167,7 @@
 void *__sem_mappings attribute_hidden;
 
 /* Lock to protect the search tree.  */
-int __sem_mappings_lock attribute_hidden = LLL_LOCK_INITIALIZER;
+lll_lock_t __sem_mappings_lock attribute_hidden = LLL_LOCK_INITIALIZER;
 
 
 /* Search for existing mapping and if possible add the one provided.  */
@@ -322,16 +325,15 @@
       union
       {
 	sem_t initsem;
-	struct new_sem newsem;
+    struct __sclib_sem newsem;
       } sem;
 
       sem.newsem.value = value;
-      sem.newsem.private = 0;
-      sem.newsem.nwaiters = 0;
+      sem.newsem.queue = NULL;
 
       /* Initialize the remaining bytes as well.  */
-      memset ((char *) &sem.initsem + sizeof (struct new_sem), '\0',
-	      sizeof (sem_t) - sizeof (struct new_sem));
+      memset ((char *) &sem.initsem + sizeof (struct __sclib_sem), '\0',
+	      sizeof (sem_t) - sizeof (struct __sclib_sem));
 
       tmpfname = (char *) alloca (mountpoint.dirlen + 6 + 1);
       mempcpy (mempcpy (tmpfname, mountpoint.dir, mountpoint.dirlen),
@@ -390,8 +392,7 @@
   if (fd != -1)
     {
       /* Do not disturb errno.  */
-      INTERNAL_SYSCALL_DECL (err);
-      INTERNAL_SYSCALL (close, err, 1, fd);
+      __internal_sys_close(fd);
     }
 
   return result;
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/generic/_dcmpxchg.h uClibc-0.9.33-new/libpthread/nptl/sysdeps/generic/_dcmpxchg.h
--- uClibc-0.9.33/libpthread/nptl/sysdeps/generic/_dcmpxchg.h	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/generic/_dcmpxchg.h	2013-09-23 20:39:32.974222861 -0400
@@ -0,0 +1,30 @@
+#ifndef _SYSCALL_COMMON_DCMPXCHG_H
+#define _SYSCALL_COMMON_DCMPXCHG_H 1
+
+/* Double CAS implementation */
+# if defined(__x86_64__) || defined(__i386__)
+
+#  if defined(__x86_64__)
+#   define __DCMPXCHG "cmpxchg16b"
+#  else
+#   define __DCMPXCHG "cmpxchg8b"
+#  endif
+
+static inline bool dcmpxchg(size_t *addr, size_t prev_lo, size_t prev_hi,
+	size_t new_lo, size_t new_hi)
+{
+	bool result;
+	__asm__ __volatile__ ("lock " __DCMPXCHG " %0\n\t"
+						  "setz %b1"
+						  : "+m" (*addr), "=a" (result), "+d" (prev_hi)
+						  : "a" (prev_lo), "b" (new_lo), "c" (new_hi)
+						  : "cc"
+	);
+	return result;
+}
+
+#  undef __DCMPXCHG
+
+# endif
+
+#endif /* !_SYSCALL_COMMON_DCMPXCHG */
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/generic/dl-tls.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/generic/dl-tls.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/generic/dl-tls.c	2013-09-23 20:39:09.358221883 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/generic/dl-tls.c	2013-09-23 20:39:32.974222861 -0400
@@ -1,5 +1,6 @@
 /* Thread-local storage handling in the ELF dynamic linker.  Generic version.
    Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -430,6 +431,42 @@
   *alignp = GL(dl_tls_static_align);
 }
 
+void *
+internal_function
+_dl_allocate_ktls_storage (void)
+{
+  size_t size = 4096; /* Page size */
+  void *result = _dl_memalign (_dl_tls_static_align, size);
+  struct kpthread *kpd;
+
+  if (__builtin_expect (result != NULL, 1))
+    {
+      void *end, *mem = result;
+
+# ifdef TLS_TCB_AT_TP
+      /* The TCB follows the TLS blocks.  */
+      result = (char *) result + size - TLS_KTCB_SIZE;
+
+      /* Clear the TCB data structure.  We can't ask the caller (i.e.
+     libpthread) to do it, because we will initialize the DTV et al.  */
+      _dl_memset (result, '\0', TLS_KTCB_SIZE);
+      end = result;
+# elif defined(TLS_DTV_AT_TP)
+      result = (char *) result + size - TLS_KTCB_SIZE;
+
+      /* Clear the TCB data structure and TLS_PRE_TCB_SIZE bytes before it.
+     We can't ask the caller (i.e. libpthread) to do it, because we will
+     initialize the DTV et al.  */
+      _dl_memset ((char *) result - TLS_PRE_KTCB_SIZE, '\0',
+          TLS_PRE_KTCB_SIZE + TLS_KTCB_SIZE);
+      end = (char *) result - TLS_PRE_KTCB_SIZE;
+# endif
+      kpd = (struct kpthread *) result;
+      kpd->context.uc_stack.ss_sp = mem;
+      kpd->context.uc_stack.ss_size = (size_t) (end - mem);
+    }
+  return result;
+}
 
 void *
 internal_function
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/generic/libc-tls.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/generic/libc-tls.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/generic/libc-tls.c	2013-09-23 20:39:09.366221882 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/generic/libc-tls.c	2013-09-23 20:39:32.974222861 -0400
@@ -1,5 +1,6 @@
 /* Initialization code for TLS in statically linked application.
    Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -114,8 +115,9 @@
 void
 __libc_setup_tls (size_t tcbsize, size_t tcbalign)
 {
-  void *tlsblock;
-  size_t memsz = 0;
+  struct kpthread *ktcb;
+  void *tlsblock, *kbegin, *kend;
+  size_t memsz = 0, ksize;
   size_t filesz = 0;
   void *initimage = NULL;
   size_t align = 0;
@@ -138,6 +140,20 @@
 	  break;
 	}
 
+  ksize = 4096; /* Page size */
+  kbegin = sbrk (ksize + _dl_tls_static_align - 1);
+  if (__builtin_expect (kbegin == NULL, 0))
+    abort();
+  kbegin = (void *) (((size_t) kbegin + _dl_tls_static_align - 1) & ~(_dl_tls_static_align - 1));
+  ktcb = (struct kpthread *) ((char *) kbegin + ksize - TLS_KTCB_SIZE);
+# if defined(TLS_TCB_AT_TP)
+  kend = ktcb;
+# elif defined(TLS_DTV_AT_TP)
+  kend = (char *) ktcb - TLS_PRE_KTCB_SIZE;
+#endif
+  ktcb->context.uc_stack.ss_sp = kbegin;
+  ktcb->context.uc_stack.ss_size = (size_t) (kend - kbegin);
+
   /* We have to set up the TCB block which also (possibly) contains
      'errno'.  Therefore we avoid 'malloc' which might touch 'errno'.
      Instead we use 'sbrk' which would only uses 'errno' if it fails.
@@ -187,18 +203,19 @@
   /* Install the pointer to the dtv.  */
 
   /* Initialize the thread pointer.  */
+
+  const char *lossage = (char *)TLS_INIT_KTP (ktcb, 0);
+  if (__builtin_expect (lossage != NULL, 0))
+    abort();
 # if defined(TLS_TCB_AT_TP)
   INSTALL_DTV ((char *) tlsblock + tcb_offset, static_dtv);
-
-  const char *lossage = TLS_INIT_TP ((char *) tlsblock + tcb_offset, 0);
+  TLS_INIT_TP ((char *) tlsblock + tcb_offset, 0);
 # elif defined(TLS_DTV_AT_TP)
   INSTALL_DTV (tlsblock, static_dtv);
-  const char *lossage = (char *)TLS_INIT_TP (tlsblock, 0);
+  TLS_INIT_TP (tlsblock, 0);
 # else
 #  error "Either TLS_TCB_AT_TP or TLS_DTV_AT_TP must be defined"
 # endif
-  if (__builtin_expect (lossage != NULL, 0))
-    abort();
 
   /* We have to create a fake link map which normally would be created
      by the dynamic linker.  It just has to have enough information to
@@ -242,13 +259,15 @@
   return 0;
 }
 
-extern void __pthread_initialize_minimal(void) __attribute__((weak));
+struct syscall_queue;
+
+extern void __pthread_initialize_minimal(struct syscall_queue *) __attribute__((weak));
 
 /* This is the minimal initialization function used when libpthread is
    not used.  */
 void
 __attribute__ ((weak))
-__pthread_initialize_minimal (void)
+__pthread_initialize_minimal (struct syscall_queue *rqueue)
 {
   __libc_setup_tls (TLS_INIT_TCB_SIZE, TLS_INIT_TCB_ALIGN);
 }
@@ -259,7 +278,7 @@
    not used.  */
 void
 __attribute__ ((weak))
-__pthread_initialize_minimal (void)
+__pthread_initialize_minimal (struct syscall_queue *rqueue)
 {
   NONTLS_INIT_TP;
 }
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/bits/libc-lock.h uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/bits/libc-lock.h
--- uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/bits/libc-lock.h	2013-09-23 20:39:09.354221884 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/bits/libc-lock.h	2013-09-23 20:39:32.974222861 -0400
@@ -40,7 +40,7 @@
 
 /* Mutex type.  */
 #if defined _LIBC || defined _IO_MTSAFE_IO
-# if (defined NOT_IN_libc && !defined IS_IN_libpthread) || !defined _LIBC
+# if 1
 typedef pthread_mutex_t __libc_lock_t;
 typedef struct { pthread_mutex_t mutex; } __libc_lock_recursive_t;
 # else
@@ -91,7 +91,7 @@
    initialized locks must be set to one due to the lack of normal
    atomic operations.) */
 
-#if defined _LIBC && (!defined NOT_IN_libc || defined IS_IN_libpthread)
+#if 0
 # if LLL_LOCK_INITIALIZER == 0
 #  define __libc_lock_define_initialized(CLASS,NAME) \
   CLASS __libc_lock_t NAME;
@@ -107,6 +107,7 @@
 #  define __libc_lock_define_initialized(CLASS,NAME) \
   CLASS __libc_lock_t NAME = PTHREAD_MUTEX_INITIALIZER;
 # endif
+# define __LIBC_LOCK_INITIALIZER PTHREAD_MUTEX_INITIALIZER
 #endif
 
 #define __libc_rwlock_define_initialized(CLASS,NAME) \
@@ -114,7 +115,7 @@
 
 /* Define an initialized recursive lock variable NAME with storage
    class CLASS.  */
-#if defined _LIBC && (!defined NOT_IN_libc || defined IS_IN_libpthread)
+#if 0
 # if LLL_LOCK_INITIALIZER == 0
 #  define __libc_lock_define_initialized_recursive(CLASS,NAME) \
   CLASS __libc_lock_recursive_t NAME;
@@ -168,10 +169,16 @@
   FUNC ARGS
 #endif
 
+#define __libc_lock_reinit(NAME) \
+  __libc_maybe_call (__pthread_mutex_reinit, (&(NAME)), 0)
+#define __libc_futex_wake(A, B) \
+  __libc_maybe_call (__sclib_futex_wake, ((int *) (A), (B)), 0)
+#define __libc_futex_wait(A, B) \
+  __libc_maybe_call (__sclib_futex_wait, ((int *) (A), (B)), 0)
 
 /* Initialize the named lock variable, leaving it in a consistent, unlocked
    state.  */
-#if defined _LIBC && (!defined NOT_IN_libc || defined IS_IN_libpthread)
+#if 0
 # define __libc_lock_init(NAME) ((NAME) = LLL_LOCK_INITIALIZER, 0)
 #else
 # define __libc_lock_init(NAME) \
@@ -188,7 +195,7 @@
 #endif
 
 /* Same as last but this time we initialize a recursive mutex.  */
-#if defined _LIBC && (!defined NOT_IN_libc || defined IS_IN_libpthread)
+#if 0
 # define __libc_lock_init_recursive(NAME) \
   ((NAME) = (__libc_lock_recursive_t) _LIBC_LOCK_RECURSIVE_INITIALIZER, 0)
 #else
@@ -220,7 +227,7 @@
 /* Finalize the named lock variable, which must be locked.  It cannot be
    used again until __libc_lock_init is called again on it.  This must be
    called on a lock variable before the containing storage is reused.  */
-#if defined _LIBC && (!defined NOT_IN_libc || defined IS_IN_libpthread)
+#if 0
 # define __libc_lock_fini(NAME) ((void) 0)
 #else
 # define __libc_lock_fini(NAME) \
@@ -234,7 +241,7 @@
 #endif
 
 /* Finalize recursive named lock.  */
-#if defined _LIBC && (!defined NOT_IN_libc || defined IS_IN_libpthread)
+#if 0
 # define __libc_lock_fini_recursive(NAME) ((void) 0)
 #else
 # define __libc_lock_fini_recursive(NAME) \
@@ -242,7 +249,7 @@
 #endif
 
 /* Lock the named lock variable.  */
-#if defined _LIBC && (!defined NOT_IN_libc || defined IS_IN_libpthread)
+#if 0
 # define __libc_lock_lock(NAME) \
   ({ lll_lock (NAME, LLL_PRIVATE); 0; })
 #else
@@ -255,7 +262,7 @@
   __libc_ptf_call (__pthread_rwlock_wrlock, (&(NAME)), 0)
 
 /* Lock the recursive named lock variable.  */
-#if defined _LIBC && (!defined NOT_IN_libc || defined IS_IN_libpthread)
+#if 0
 # define __libc_lock_lock_recursive(NAME) \
   do {									      \
     void *self = THREAD_SELF;						      \
@@ -272,7 +279,7 @@
 #endif
 
 /* Try to lock the named lock variable.  */
-#if defined _LIBC && (!defined NOT_IN_libc || defined IS_IN_libpthread)
+#if 0
 # define __libc_lock_trylock(NAME) \
   lll_trylock (NAME)
 #else
@@ -285,7 +292,7 @@
   __libc_maybe_call (__pthread_rwlock_trywrlock, (&(NAME)), 0)
 
 /* Try to lock the recursive named lock variable.  */
-#if defined _LIBC && (!defined NOT_IN_libc || defined IS_IN_libpthread)
+#if 0
 # define __libc_lock_trylock_recursive(NAME) \
   ({									      \
     int result = 0;							      \
@@ -313,7 +320,7 @@
   __libc_maybe_call (__pthread_mutex_trylock, (&(NAME).mutex), 0)
 
 /* Unlock the named lock variable.  */
-#if defined _LIBC && (!defined NOT_IN_libc || defined IS_IN_libpthread)
+#if 0
 # define __libc_lock_unlock(NAME) \
   lll_unlock (NAME, LLL_PRIVATE)
 #else
@@ -324,7 +331,7 @@
   __libc_ptf_call (__pthread_rwlock_unlock, (&(NAME)), 0)
 
 /* Unlock the recursive named lock variable.  */
-#if defined _LIBC && (!defined NOT_IN_libc || defined IS_IN_libpthread)
+#if 0
 /* We do no error checking here.  */
 # define __libc_lock_unlock_recursive(NAME) \
   do {									      \
@@ -477,6 +484,8 @@
 extern int __pthread_mutex_init (pthread_mutex_t *__mutex,
 				 __const pthread_mutexattr_t *__mutex_attr);
 
+extern int __pthread_mutex_reinit (pthread_mutex_t *__mutex);
+
 extern int __pthread_mutex_destroy (pthread_mutex_t *__mutex);
 
 extern int __pthread_mutex_trylock (pthread_mutex_t *__mutex);
@@ -531,6 +540,7 @@
 #ifndef __NO_WEAK_PTHREAD_ALIASES
 # ifdef weak_extern
 weak_extern (__pthread_mutex_init)
+weak_extern (__pthread_mutex_reinit)
 weak_extern (__pthread_mutex_destroy)
 weak_extern (__pthread_mutex_lock)
 weak_extern (__pthread_mutex_trylock)
@@ -556,6 +566,7 @@
 weak_extern (pthread_setcancelstate)
 # else
 #  pragma weak __pthread_mutex_init
+#  pragma weak __pthread_mutex_reinit
 #  pragma weak __pthread_mutex_destroy
 #  pragma weak __pthread_mutex_lock
 #  pragma weak __pthread_mutex_trylock
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/bits/stdio-lock.h uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/bits/stdio-lock.h
--- uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/bits/stdio-lock.h	2013-09-23 20:39:09.354221884 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/bits/stdio-lock.h	2013-09-23 20:39:32.974222861 -0400
@@ -22,27 +22,32 @@
 
 #include <bits/libc-lock.h>
 #include <lowlevellock.h>
+#include <schedule_defsP.h>
 
 
 /* The locking here is very inexpensive, even for inlining.  */
 #define _IO_lock_inexpensive	1
 
-typedef struct { int lock; int cnt; void *owner; } _IO_lock_t;
+typedef struct { struct __sclib_mutex_auto lock; int cnt; void *owner; } _IO_lock_t;
 
 #define _IO_lock_initializer { LLL_LOCK_INITIALIZER, 0, NULL }
 
-#define _IO_lock_init(_name) \
-  ((_name) = (_IO_lock_t) _IO_lock_initializer , 0)
+#define _IO_lock_init(_name)   \
+  do {  \
+     (_name).cnt = 0; \
+     (_name).owner = NULL; \
+     __sclib_mutex_auto_init (&(_name).lock, 0); \
+  } while (0)
 
 #define _IO_lock_fini(_name) \
-  ((void) 0)
+  __sclib_mutex_auto_destroy (&(_name).lock)
 
 #define _IO_lock_lock(_name) \
   do {									      \
     void *__meself = THREAD_SELF;						      \
     if ((_name).owner != __meself)					      \
       {									      \
-	lll_lock ((_name).lock, LLL_PRIVATE);				      \
+	__sclib_mutex_auto_lock (&(_name).lock);				      \
         (_name).owner = __meself;						      \
       }									      \
     ++(_name).cnt;							      \
@@ -54,7 +59,7 @@
     void *__meself = THREAD_SELF;						      \
     if ((_name).owner != __meself)					      \
       {									      \
-        if (lll_trylock ((_name).lock) == 0)				      \
+        if (__sclib_mutex_auto_trylock (&(_name).lock) == 0)		\
           {								      \
             (_name).owner = __meself;					      \
             (_name).cnt = 1;						      \
@@ -72,7 +77,7 @@
     if (--(_name).cnt == 0)						      \
       {									      \
         (_name).owner = NULL;						      \
-	lll_unlock ((_name).lock, LLL_PRIVATE);				      \
+	__sclib_mutex_auto_unlock (&(_name).lock);				      \
       }									      \
   } while (0)
 
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/createthread.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/createthread.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/createthread.c	2013-09-23 20:39:09.354221884 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/createthread.c	2013-09-23 20:39:32.974222861 -0400
@@ -1,4 +1,5 @@
 /* Copyright (C) 2002-2007, 2008 Free Software Foundation, Inc.
+   Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -27,13 +28,15 @@
 
 #include <bits/kernel-features.h>
 
+#include <scheduleP.h>
+#include <bits/sclib.h>
 
 #define CLONE_SIGNAL    	(CLONE_SIGHAND | CLONE_THREAD)
 
 /* Unless otherwise specified, the thread "register" is going to be
    initialized with a pointer to the TCB.  */
 #ifndef TLS_VALUE
-# define TLS_VALUE pd
+# define TLS_VALUE kpd
 #endif
 
 #ifndef ARCH_CLONE
@@ -46,12 +49,34 @@
 int *__libc_multiple_threads_ptr attribute_hidden;
 #endif
 
+static int start_kthread(void *_kpd)
+{
+  struct kpthread *kpd = (struct kpthread *) _kpd;
+  struct pthread *pd;
+  __sclib_kthread_init (kpd);
+  pd = THREAD_SELF;
+  __sclib_thread_init (pd, kpd);
+  start_thread (NULL, pd);
+  return 0;
+}
+
+static inline bool
+increment_nkthreads(void)
+{
+	unsigned long val;
+	do {
+		val = __nptl_rqueue->nkthreads;
+		if (val == __sclib_num_kthreads)
+			return false;
+	} while (atomic_compare_and_exchange_bool_acq(&__nptl_rqueue->nkthreads, val + 1, val));
+	return true;
+}
 
 static int
 do_clone (struct pthread *pd, const struct pthread_attr *attr,
-	  int clone_flags, int (*fct) (void *), STACK_VARIABLES_PARMS,
-	  int stopped)
+	  int clone_flags, STACK_VARIABLES_PARMS, int stopped)
 {
+  struct pthread *self = THREAD_SELF;
 #ifdef PREPARE_CREATE
   PREPARE_CREATE;
 #endif
@@ -72,9 +97,38 @@
      that cares whether the thread count is correct.  */
   atomic_increment (&__nptl_nthreads);
 
-  if (ARCH_CLONE (fct, STACK_VARIABLES_ARGS, clone_flags,
-		  pd, &pd->tid, TLS_VALUE, &pd->tid) == -1)
+  pd->tid = GET_TID ();
+  if (!increment_nkthreads ()) {
+    __sclib_thread_init (pd, KTHREAD_SELF);
+    makecontext (&pd->context, (void (*)(void)) start_thread, 2, self, pd);
+    __sclib_initial_switch (self, pd);
+  } else {
+    struct kpthread *kpd;
+    int err = allocate_kpd (&kpd);
+    if (__builtin_expect (err != 0, 0))
+      /* Something went wrong.  Maybe a parameter of the attributes is
+        invalid or we could not allocate memory.  */
+      return err;
+
+#ifdef TLS_TCB_AT_TP
+    /* Reference to the TCB itself.  */
+    kpd->header.self = kpd;
+    /* Self-reference for TLS.  */
+    kpd->header.tcb = pd;
+#endif
+  /* Copy the stack guard canary.  */
+#ifdef KTHREAD_COPY_STACK_GUARD
+    KTHREAD_COPY_STACK_GUARD (kpd);
+#endif
+  /* Copy the pointer guard value.  */
+#ifdef KTHREAD_COPY_POINTER_GUARD
+    KTHREAD_COPY_POINTER_GUARD (kpd);
+#endif
+
+    if (ARCH_CLONE (start_kthread, STACK_VARIABLES_ARGS, clone_flags,
+		  kpd, &kpd->ktid, TLS_VALUE, &kpd->ktid) == -1)
     {
+      atomic_decrement (&__nptl_rqueue->nkthreads);
       atomic_decrement (&__nptl_nthreads); /* Oops, we lied for a second.  */
 
       /* Failed.  If the thread is detached, remove the TCB here since
@@ -87,7 +141,9 @@
       /* We have to translate error codes.  */
       return errno == ENOMEM ? EAGAIN : errno;
     }
+  }
 
+#if 0
   /* Now we have the possibility to set scheduling parameters etc.  */
   if (__builtin_expect (stopped != 0, 0))
     {
@@ -108,7 +164,7 @@
 	    err_out:
 #if defined (__ASSUME_TGKILL) && __ASSUME_TGKILL
 	      (void) INTERNAL_SYSCALL (tgkill, err2, 3,
-				       THREAD_GETMEM (THREAD_SELF, pid),
+				       THREAD_GETMEM (self, pid),
 				       pd->tid, SIGCANCEL);
 #else
 	      (void) INTERNAL_SYSCALL (tkill, err2, 2, pd->tid, SIGCANCEL);
@@ -130,11 +186,12 @@
 	    goto err_out;
 	}
     }
+#endif
 
   /* We now have for sure more than one thread.  The main thread might
      not yet have the flag set.  No need to set the global variable
      again if this is what we use.  */
-  THREAD_SETMEM (THREAD_SELF, header.multiple_threads, 1);
+  THREAD_SETMEM (self, header.multiple_threads, 1);
 
   return 0;
 }
@@ -202,7 +259,7 @@
 
 	  /* Create the thread.  We always create the thread stopped
 	     so that it does not get far before we tell the debugger.  */
-	  int res = do_clone (pd, attr, clone_flags, start_thread,
+	  int res = do_clone (pd, attr, clone_flags,
 			      STACK_VARIABLES_ARGS, 1);
 	  if (res == 0)
 	    {
@@ -246,7 +303,7 @@
   pd->parent_cancelhandling = THREAD_GETMEM (THREAD_SELF, cancelhandling);
 
   /* Actually create the thread.  */
-  int res = do_clone (pd, attr, clone_flags, start_thread,
+  int res = do_clone (pd, attr, clone_flags,
 		      STACK_VARIABLES_ARGS, stopped);
 
   if (res == 0 && stopped)
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/list.h uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/list.h
--- uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/list.h	2013-09-23 20:39:09.346221883 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/list.h	2013-09-23 20:39:32.974222861 -0400
@@ -1,4 +1,5 @@
 /* Copyright (C) 2002, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -52,6 +53,15 @@
   head->next = newp;
 }
 
+/* Add new element at the tail of the list.  */
+static inline void
+list_add_tail (list_t *newp, list_t *head)
+{
+  newp->prev = head->prev;
+  newp->next = head;
+  head->prev->next = newp;
+  head->prev = newp;
+}
 
 /* Remove element from list.  */
 static inline void
@@ -78,15 +88,20 @@
 
 
 /* Get typed element from list at a given position.  */
-#define list_entry(ptr, type, member) \
+#define container_of(ptr, type, member) \
   ((type *) ((char *) (ptr) - (unsigned long) (&((type *) 0)->member)))
 
-
+#define list_entry(ptr, type, member) \
+	container_of(ptr, type, member)
 
 /* Iterate forward over the elements of the list.  */
 #define list_for_each(pos, head) \
   for (pos = (head)->next; pos != (head); pos = pos->next)
 
+#define list_for_each_safe(pos, p, head) \
+  for (pos = (head)->next, p = pos->next; \
+	   pos != (head); \
+	   pos = p, p = pos->next)
 
 /* Iterate forward over the elements of the list.  */
 #define list_for_each_prev(pos, head) \
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_barrier_destroy.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_barrier_destroy.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_barrier_destroy.c	2013-09-23 20:39:09.346221883 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_barrier_destroy.c	2013-09-23 20:39:32.974222861 -0400
@@ -33,12 +33,14 @@
 
   lll_lock (ibarrier->lock, ibarrier->private ^ FUTEX_PRIVATE_FLAG);
 
-  if (__builtin_expect (ibarrier->left == ibarrier->init_count, 1))
+  if (__builtin_expect (ibarrier->left == ibarrier->init_count, 1)) {
     /* The barrier is not used anymore.  */
     result = 0;
-  else
+    __sclib_mutex_auto_destroy(&ibarrier->lock);
+  } else {
     /* Still used, return with an error.  */
     lll_unlock (ibarrier->lock, ibarrier->private ^ FUTEX_PRIVATE_FLAG);
+  }
 
   return result;
 }
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_barrier_init.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_barrier_init.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_barrier_init.c	2013-09-23 20:39:09.346221883 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_barrier_init.c	2013-09-23 20:39:32.974222861 -0400
@@ -53,7 +53,7 @@
   ibarrier = (struct pthread_barrier *) barrier;
 
   /* Initialize the individual fields.  */
-  ibarrier->lock = LLL_LOCK_INITIALIZER;
+  __sclib_mutex_auto_init(&ibarrier->lock, __SCLIB_MUTEX_NORMAL);
   ibarrier->left = count;
   ibarrier->init_count = count;
   ibarrier->curr_event = 0;
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_cond_broadcast.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_cond_broadcast.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_cond_broadcast.c	2013-09-23 20:39:09.342221882 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_cond_broadcast.c	2013-09-23 20:39:32.978222862 -0400
@@ -23,6 +23,7 @@
 #include <lowlevellock.h>
 #include <pthread.h>
 #include <pthreadP.h>
+#include <scheduleP.h>
 
 #include <bits/kernel-features.h>
 
@@ -32,6 +33,8 @@
 __pthread_cond_broadcast (
      pthread_cond_t *cond)
 {
+  return __sclib_cond_broadcast(&cond->sclib_cond);
+#if 0
   int pshared = (cond->__data.__mutex == (void *) ~0l)
 		? LLL_SHARED : LLL_PRIVATE;
   /* Make sure we are alone.  */
@@ -85,6 +88,7 @@
   lll_unlock (cond->__data.__lock, pshared);
 
   return 0;
+#endif
 }
 
 weak_alias(__pthread_cond_broadcast, pthread_cond_broadcast)
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_cond_signal.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_cond_signal.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_cond_signal.c	2013-09-23 20:39:09.346221883 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_cond_signal.c	2013-09-23 20:39:32.978222862 -0400
@@ -23,6 +23,7 @@
 #include <lowlevellock.h>
 #include <pthread.h>
 #include <pthreadP.h>
+#include <scheduleP.h>
 
 #include <bits/kernel-features.h>
 
@@ -32,6 +33,8 @@
 __pthread_cond_signal (
      pthread_cond_t *cond)
 {
+  return __sclib_cond_signal(&cond->sclib_cond);
+#if 0
   int pshared = (cond->__data.__mutex == (void *) ~0l)
 		? LLL_SHARED : LLL_PRIVATE;
 
@@ -58,6 +61,7 @@
   lll_unlock (cond->__data.__lock, pshared);
 
   return 0;
+#endif
 }
 
 weak_alias(__pthread_cond_signal, pthread_cond_signal)
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_cond_timedwait.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_cond_timedwait.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_cond_timedwait.c	2013-09-23 20:39:09.354221884 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_cond_timedwait.c	2013-09-23 20:39:32.978222862 -0400
@@ -23,9 +23,10 @@
 #include <lowlevellock.h>
 #include <pthread.h>
 #include <pthreadP.h>
+#include <scheduleP.h>
 #include <bits/kernel-features.h>
 
-
+#if 0
 /* Cleanup handler, defined in pthread_cond_wait.c.  */
 extern void __condvar_cleanup (void *arg)
      __attribute__ ((visibility ("hidden")));
@@ -37,6 +38,7 @@
   pthread_mutex_t *mutex;
   unsigned int bc_seq;
 };
+#endif
 
 int
 attribute_protected
@@ -45,6 +47,8 @@
      pthread_mutex_t *mutex,
      const struct timespec *abstime)
 {
+  return __sclib_cond_wait(&cond->sclib_cond, &mutex->sclib_mutex);
+#if 0
   struct _pthread_cleanup_buffer buffer;
   struct _condvar_cleanup_buffer cbuffer;
   int result = 0;
@@ -211,6 +215,7 @@
   err = __pthread_mutex_cond_lock (mutex);
 
   return err ?: result;
+#endif
 }
 
 weak_alias(__pthread_cond_timedwait, pthread_cond_timedwait)
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_cond_wait.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_cond_wait.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_cond_wait.c	2013-09-23 20:39:09.346221883 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_cond_wait.c	2013-09-23 20:39:32.978222862 -0400
@@ -23,8 +23,9 @@
 #include <lowlevellock.h>
 #include <pthread.h>
 #include <pthreadP.h>
+#include <scheduleP.h>
 
-
+#if 0
 struct _condvar_cleanup_buffer
 {
   int oldtype;
@@ -86,7 +87,7 @@
      is in effect.  */
   __pthread_mutex_cond_lock (cbuffer->mutex);
 }
-
+#endif
 
 int
 attribute_protected
@@ -94,6 +95,8 @@
      pthread_cond_t *cond,
      pthread_mutex_t *mutex)
 {
+  return __sclib_cond_wait(&cond->sclib_cond, &mutex->sclib_mutex);
+#if 0
   struct _pthread_cleanup_buffer buffer;
   struct _condvar_cleanup_buffer cbuffer;
   int err;
@@ -188,6 +191,7 @@
 
   /* Get the mutex before returning.  */
   return __pthread_mutex_cond_lock (mutex);
+#endif
 }
 
 weak_alias(__pthread_cond_wait, pthread_cond_wait)
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread-functions.h uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread-functions.h
--- uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread-functions.h	2013-09-23 20:39:09.342221882 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread-functions.h	2013-09-23 20:39:32.978222862 -0400
@@ -26,6 +26,8 @@
 #include <sysdep.h>
 
 struct xid_command;
+struct syscall_entry;
+struct __sclib_mutex_auto;
 
 /* Data type shared with libc.  The libc uses it to pass on calls to
    the thread functions.  */
@@ -73,6 +75,7 @@
   int (*ptr_pthread_mutex_destroy) (pthread_mutex_t *);
   int (*ptr_pthread_mutex_init) (pthread_mutex_t *,
 				 const pthread_mutexattr_t *);
+  int (*ptr___pthread_mutex_reinit) (pthread_mutex_t *);
   int (*ptr_pthread_mutex_lock) (pthread_mutex_t *);
   int (*ptr_pthread_mutex_unlock) (pthread_mutex_t *);
   pthread_t (*ptr_pthread_self) (void);
@@ -97,6 +100,15 @@
   void (*ptr__nptl_deallocate_tsd) (void);
   int (*ptr__nptl_setxid) (struct xid_command *);
   void (*ptr_freeres) (void);
+  long (*ptr___sclib_futex_wake) (int *, int);
+  long (*ptr___sclib_futex_wait) (int *, int);
+  void (*ptr___sclib_schedule) (int, struct syscall_entry *);
+  long (*ptr___sclib_mutex_auto_init) (struct __sclib_mutex_auto *, int);
+  long (*ptr___sclib_mutex_auto_reinit) (struct __sclib_mutex_auto *);
+  void (*ptr___sclib_mutex_auto_destroy) (struct __sclib_mutex_auto *);
+  long (*ptr___sclib_mutex_auto_trylock) (struct __sclib_mutex_auto *);
+  long (*ptr___sclib_mutex_auto_lock) (struct __sclib_mutex_auto *);
+  long (*ptr___sclib_mutex_auto_unlock) (struct __sclib_mutex_auto *);
 };
 
 /* Variable in libc.so.  */
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread.h uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread.h
--- uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread.h	2013-09-23 20:39:09.354221884 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread.h	2013-09-23 20:39:32.978222862 -0400
@@ -741,9 +741,9 @@
 
 #ifdef __USE_XOPEN2K
 /* Wait until lock becomes available, or specified time passes. */
-extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
+/* extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
 				    __const struct timespec *__restrict
-				    __abstime) __THROW __nonnull ((1, 2));
+				    __abstime) __THROW __nonnull ((1, 2)); */
 #endif
 
 /* Unlock a mutex.  */
@@ -880,9 +880,9 @@
 
 # ifdef __USE_XOPEN2K
 /* Try to acquire read lock for RWLOCK or return after specfied time.  */
-extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
+/* extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
 				       __const struct timespec *__restrict
-				       __abstime) __THROW __nonnull ((1, 2));
+				       __abstime) __THROW __nonnull ((1, 2)); */
 # endif
 
 /* Acquire write lock for RWLOCK.  */
@@ -895,9 +895,9 @@
 
 # ifdef __USE_XOPEN2K
 /* Try to acquire write lock for RWLOCK or return after specfied time.  */
-extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
+/* extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
 				       __const struct timespec *__restrict
-				       __abstime) __THROW __nonnull ((1, 2));
+				       __abstime) __THROW __nonnull ((1, 2)); */
 # endif
 
 /* Unlock RWLOCK.  */
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_once.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_once.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_once.c	2013-09-23 20:39:09.342221882 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_once.c	2013-09-23 20:39:32.978222862 -0400
@@ -22,7 +22,7 @@
 
 
 
-static int once_lock = LLL_LOCK_INITIALIZER;
+static lll_lock_t once_lock = LLL_LOCK_INITIALIZER;
 
 
 int
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_rwlock_rdlock.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_rwlock_rdlock.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_rwlock_rdlock.c	2013-09-23 20:39:09.350221884 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_rwlock_rdlock.c	2013-09-23 20:39:32.978222862 -0400
@@ -22,6 +22,7 @@
 #include <lowlevellock.h>
 #include <pthread.h>
 #include <pthreadP.h>
+#include <scheduleP.h>
 
 
 /* Acquire read lock for RWLOCK.  */
@@ -30,6 +31,9 @@
 __pthread_rwlock_rdlock (
      pthread_rwlock_t *rwlock)
 {
+  return __sclib_rwlock_rdlock(&rwlock->sclib_rwlock);
+
+#if 0
   int result = 0;
 
   /* Make sure we are along.  */
@@ -91,6 +95,7 @@
   lll_unlock (rwlock->__data.__lock, rwlock->__data.__shared);
 
   return result;
+#endif
 }
 
 weak_alias (__pthread_rwlock_rdlock, pthread_rwlock_rdlock)
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_rwlock_timedrdlock.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_rwlock_timedrdlock.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_rwlock_timedrdlock.c	2013-09-23 20:39:09.342221882 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_rwlock_timedrdlock.c	2013-09-23 20:39:32.978222862 -0400
@@ -23,7 +23,7 @@
 #include <pthread.h>
 #include <pthreadP.h>
 
-
+#if 0
 /* Try to acquire read lock for RWLOCK or return after specfied time.  */
 int
 pthread_rwlock_timedrdlock (
@@ -135,3 +135,4 @@
 
   return result;
 }
+#endif
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_rwlock_timedwrlock.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_rwlock_timedwrlock.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_rwlock_timedwrlock.c	2013-09-23 20:39:09.342221882 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_rwlock_timedwrlock.c	2013-09-23 20:39:32.978222862 -0400
@@ -23,7 +23,7 @@
 #include <pthread.h>
 #include <pthreadP.h>
 
-
+#if 0
 /* Try to acquire write lock for RWLOCK or return after specfied time.	*/
 int
 pthread_rwlock_timedwrlock (
@@ -125,3 +125,4 @@
 
   return result;
 }
+#endif
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_rwlock_unlock.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_rwlock_unlock.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_rwlock_unlock.c	2013-09-23 20:39:09.350221884 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_rwlock_unlock.c	2013-09-23 20:39:32.978222862 -0400
@@ -22,12 +22,17 @@
 #include <lowlevellock.h>
 #include <pthread.h>
 #include <pthreadP.h>
+#include <scheduleP.h>
 
 /* Unlock RWLOCK.  */
 int
 attribute_protected
 __pthread_rwlock_unlock (pthread_rwlock_t *rwlock)
 {
+  __sclib_rwlock_unlock(&rwlock->sclib_rwlock);
+  return 0;
+
+#if 0
   lll_lock (rwlock->__data.__lock, rwlock->__data.__shared);
   if (rwlock->__data.__writer)
     rwlock->__data.__writer = 0;
@@ -54,6 +59,7 @@
     }
   lll_unlock (rwlock->__data.__lock, rwlock->__data.__shared);
   return 0;
+#endif
 }
 
 weak_alias (__pthread_rwlock_unlock, pthread_rwlock_unlock)
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_rwlock_wrlock.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_rwlock_wrlock.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/pthread_rwlock_wrlock.c	2013-09-23 20:39:09.342221882 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/pthread_rwlock_wrlock.c	2013-09-23 20:39:32.978222862 -0400
@@ -22,7 +22,7 @@
 #include <lowlevellock.h>
 #include <pthread.h>
 #include <pthreadP.h>
-
+#include <scheduleP.h>
 
 /* Acquire write lock for RWLOCK.  */
 int
@@ -30,6 +30,9 @@
 __pthread_rwlock_wrlock (
      pthread_rwlock_t *rwlock)
 {
+  return __sclib_rwlock_wrlock(&rwlock->sclib_rwlock);
+
+#if 0
   int result = 0;
 
   /* Make sure we are along.  */
@@ -83,6 +86,7 @@
   lll_unlock (rwlock->__data.__lock, rwlock->__data.__shared);
 
   return result;
+#endif
 }
 
 weak_alias (__pthread_rwlock_wrlock, pthread_rwlock_wrlock)
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/tpp.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/tpp.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/pthread/tpp.c	2013-09-23 20:39:09.358221883 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/pthread/tpp.c	2013-09-23 20:39:32.978222862 -0400
@@ -37,6 +37,7 @@
   __sched_fifo_min_prio = sched_get_priority_min (SCHED_FIFO);
 }
 
+#if 0
 int
 __pthread_tpp_change_priority (int previous_prio, int new_prio)
 {
@@ -170,3 +171,5 @@
 
   return result;
 }
+
+#endif
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/alpha/createthread.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/alpha/createthread.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/alpha/createthread.c	2013-09-23 20:39:09.166221874 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/alpha/createthread.c	2013-09-23 20:39:32.978222862 -0400
@@ -17,7 +17,7 @@
    02111-1307 USA.  */
 
 /* Value passed to 'clone' for initialization of the thread register.  */
-#define TLS_VALUE (pd + 1)
+#define TLS_VALUE (kpd + 1)
 
 /* Get the real implementation.	 */
 #include <sysdeps/pthread/createthread.c>
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/arm/createthread.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/arm/createthread.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/arm/createthread.c	2013-09-23 20:39:09.234221876 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/arm/createthread.c	2013-09-23 20:39:32.978222862 -0400
@@ -17,7 +17,7 @@
    02111-1307 USA.  */
 
 /* Value passed to 'clone' for initialization of the thread register.  */
-#define TLS_VALUE (pd + 1)
+#define TLS_VALUE (kpd + 1)
 
 /* Get the real implementation.	 */
 #include <sysdeps/pthread/createthread.c>
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/arm/fork.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/arm/fork.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/arm/fork.c	2013-09-23 20:39:09.234221876 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/arm/fork.c	2013-09-23 20:39:32.978222862 -0400
@@ -26,6 +26,6 @@
 #define ARCH_FORK()							\
   INLINE_SYSCALL (clone, 5,						\
 		  CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID | SIGCHLD,	\
-		  NULL, NULL, NULL, &THREAD_SELF->tid)
+		  NULL, NULL, NULL, &KTHREAD_SELF->ktid)
 
 #include "../fork.c"
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/close.S uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/close.S
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/close.S	2013-09-23 20:39:09.142221873 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/close.S	2013-09-23 20:39:32.978222862 -0400
@@ -6,7 +6,7 @@
 #if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
 
 
-PSEUDO (__libc_close, close, 1)
+PSEUDO_SCLIB (__libc_close, close, 1)
 ret
 PSEUDO_END(__libc_close)
 
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/createthread.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/createthread.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/createthread.c	2013-09-23 20:39:09.262221878 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/createthread.c	2013-09-23 20:39:32.978222862 -0400
@@ -18,7 +18,7 @@
    02111-1307 USA.  */
 
 /* Value passed to 'clone' for initialization of the thread register.  */
-#define TLS_VALUE pd
+#define TLS_VALUE kpd
 
 /* Get the real implementation.	 */
 #include <sysdeps/pthread/createthread.c>
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/fork.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/fork.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/fork.c	2013-09-23 20:39:09.242221878 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/fork.c	2013-09-23 20:39:32.978222862 -0400
@@ -1,4 +1,5 @@
 /* Copyright (C) 2002, 2003, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -42,7 +43,7 @@
 fresetlockfiles (void)
 {
   FILE *fp;
-#ifdef __USE_STDIO_FUTEXES__
+#if 1
   for (fp = _stdio_openlist; fp != NULL; fp = fp->__nextopen)
     STDIO_INIT_MUTEX(fp->__lock);
 #else
@@ -127,14 +128,14 @@
   __UCLIBC_IO_MUTEX_LOCK_CANCEL_UNSAFE(_stdio_openlist_add_lock);
 
 #ifndef NDEBUG
-  pid_t ppid = THREAD_GETMEM (THREAD_SELF, tid);
+  pid_t ppid = KTHREAD_GETMEM (KTHREAD_SELF, ktid);
 #endif
 
   /* We need to prevent the getpid() code to update the PID field so
      that, if a signal arrives in the child very early and the signal
      handler uses getpid(), the value returned is correct.  */
-  pid_t parentpid = THREAD_GETMEM (THREAD_SELF, pid);
-  THREAD_SETMEM (THREAD_SELF, pid, -parentpid);
+  pid_t parentpid = KTHREAD_GETMEM (KTHREAD_SELF, pid);
+  KTHREAD_SETMEM (KTHREAD_SELF, pid, -parentpid);
 
 #ifdef ARCH_FORK
   pid = ARCH_FORK ();
@@ -146,15 +147,16 @@
 
   if (pid == 0)
     {
+      struct kpthread *kself = KTHREAD_SELF;
       struct pthread *self = THREAD_SELF;
 
-      assert (THREAD_GETMEM (self, tid) != ppid);
+      assert (KTHREAD_GETMEM (kself, ktid) != ppid);
 
       if (__fork_generation_pointer != NULL)
 	*__fork_generation_pointer += 4;
 
       /* Adjust the PID field for the new process.  */
-      THREAD_SETMEM (self, pid, THREAD_GETMEM (self, tid));
+      KTHREAD_SETMEM (kself, pid, KTHREAD_GETMEM (kself, ktid));
 
 #if HP_TIMING_AVAIL
       /* The CPU clock of the thread and process have to be set to zero.  */
@@ -195,14 +197,14 @@
 	}
 
       /* Initialize the fork lock.  */
-      __fork_lock = LLL_LOCK_INITIALIZER;
+      __libc_lock_reinit (__fork_lock);
     }
   else
     {
-      assert (THREAD_GETMEM (THREAD_SELF, tid) == ppid);
+      assert (KTHREAD_GETMEM (KTHREAD_SELF, ktid) == ppid);
 
       /* Restore the PID value.  */
-      THREAD_SETMEM (THREAD_SELF, pid, parentpid);
+      KTHREAD_SETMEM (KTHREAD_SELF, pid, parentpid);
 
       /* We execute this even if the 'fork' call failed.  */
       __UCLIBC_IO_MUTEX_UNLOCK_CANCEL_UNSAFE(_stdio_openlist_add_lock);
@@ -215,7 +217,7 @@
 
 	  if (atomic_decrement_and_test (&allp->handler->refcntr)
 	      && allp->handler->need_signal)
-	    lll_futex_wake (allp->handler->refcntr, 1, LLL_PRIVATE);
+	    __libc_futex_wake (&allp->handler->refcntr, 1);
 
 	  allp = allp->next;
 	}
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/fork.h uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/fork.h
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/fork.h	2013-09-23 20:39:09.162221874 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/fork.h	2013-09-23 20:39:32.978222862 -0400
@@ -18,6 +18,7 @@
    02111-1307 USA.  */
 
 #include <lowlevellock.h>
+#include <libc-lock.h>
 
 /* The fork generation counter, defined in libpthread.  */
 extern unsigned long int __fork_generation attribute_hidden;
@@ -26,7 +27,7 @@
 extern unsigned long int *__fork_generation_pointer attribute_hidden;
 
 /* Lock to protect allocation and deallocation of fork handlers.  */
-extern int __fork_lock attribute_hidden;
+extern __libc_lock_t __fork_lock attribute_hidden;
 
 /* Elements of the fork handler lists.  */
 struct fork_handler
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/getpid.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/getpid.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/getpid.c	2013-09-23 20:39:09.262221878 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/getpid.c	2013-09-23 20:39:32.978222862 -0400
@@ -30,7 +30,7 @@
 {
   if (__builtin_expect (oldval == 0, 1))
     {
-      pid_t selftid = THREAD_GETMEM (THREAD_SELF, tid);
+      pid_t selftid = KTHREAD_GETMEM (KTHREAD_SELF, ktid);
       if (__builtin_expect (selftid != 0, 1))
 	return selftid;
     }
@@ -41,7 +41,7 @@
   /* We do not set the PID field in the TID here since we might be
      called from a signal handler while the thread executes fork.  */
   if (oldval == 0)
-    THREAD_SETMEM (THREAD_SELF, tid, result);
+    KTHREAD_SETMEM (KTHREAD_SELF, ktid, result);
   return result;
 }
 #endif
@@ -54,7 +54,7 @@
   INTERNAL_SYSCALL_DECL (err);
   pid_t result = INTERNAL_SYSCALL (getpid, err, 0);
 #else
-  pid_t result = THREAD_GETMEM (THREAD_SELF, pid);
+  pid_t result = KTHREAD_GETMEM (KTHREAD_SELF, pid);
   if (__builtin_expect (result <= 0, 0))
     result = really_getpid (result);
 #endif
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/i386/createthread.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/i386/createthread.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/i386/createthread.c	2013-09-23 20:39:09.186221875 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/i386/createthread.c	2013-09-23 20:39:32.978222862 -0400
@@ -29,7 +29,7 @@
      from the value of the %gs register in the current thread.  */	      \
   desc.vals[0] = TLS_GET_GS () >> 3;					      \
   /* The 'base_addr' field.  Pointer to the TCB.  */			      \
-  desc.vals[1] = (unsigned long int) pd;				      \
+  desc.vals[1] = (unsigned long int) kpd;				      \
   /* The 'limit' field.  We use 4GB which is 0xfffff pages.  */		      \
   desc.vals[2] = 0xfffff;						      \
   /* Collapsed value of the bitfield:					      \
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/internaltypes.h uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/internaltypes.h
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/internaltypes.h	2013-09-23 20:39:09.162221874 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/internaltypes.h	2013-09-23 20:39:32.978222862 -0400
@@ -22,6 +22,7 @@
 
 #include <stdint.h>
 #include <sched.h>
+#include <lowlevellock.h>
 
 struct pthread_attr
 {
@@ -94,8 +95,8 @@
 /* Barrier data structure.  */
 struct pthread_barrier
 {
+  lll_lock_t lock;
   unsigned int curr_event;
-  int lock;
   unsigned int left;
   unsigned int init_count;
   int private;
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/lowlevellock.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/lowlevellock.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/lowlevellock.c	2013-09-23 20:39:09.166221874 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/lowlevellock.c	2013-09-23 20:39:32.978222862 -0400
@@ -25,7 +25,7 @@
 #include <tls.h>
 #include <tcb-offsets.h>
 
-
+#if 0
 void
 __lll_lock_wait_private (int *futex)
 {
@@ -125,3 +125,4 @@
   return 0;
 }
 #endif
+#endif
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/lowlevelrobustlock.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/lowlevelrobustlock.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/lowlevelrobustlock.c	2013-09-23 20:39:09.162221874 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/lowlevelrobustlock.c	2013-09-23 20:39:32.978222862 -0400
@@ -24,6 +24,7 @@
 #include <pthreadP.h>
 
 
+#if 0
 int
 __lll_robust_lock_wait (int *futex, int private)
 {
@@ -112,3 +113,4 @@
 
   return 0;
 }
+#endif
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/mips/createthread.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/mips/createthread.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/mips/createthread.c	2013-09-23 20:39:09.138221873 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/mips/createthread.c	2013-09-23 20:39:32.982222863 -0400
@@ -17,7 +17,7 @@
    02111-1307 USA.  */
 
 /* Value passed to 'clone' for initialization of the thread register.  */
-#define TLS_VALUE ((void *) (pd) \
+#define TLS_VALUE ((void *) (kpd) \
 		   + TLS_TCB_OFFSET + TLS_PRE_TCB_SIZE)
 
 /* Get the real implementation.	 */
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/not-cancel.h uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/not-cancel.h
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/not-cancel.h	2013-09-23 20:39:09.314221882 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/not-cancel.h	2013-09-23 20:39:32.982222863 -0400
@@ -21,53 +21,54 @@
 #include <sys/types.h>
 #include <sysdep.h>
 
+#include <bits/sclib.h>
+#include <bits/sclib_syscalls.h>
+
 /* Uncancelable open.  */
-#define open_not_cancel(name, flags, mode) \
-   INLINE_SYSCALL (open, 3, (const char *) (name), (flags), (mode))
-#define open_not_cancel_2(name, flags) \
-   INLINE_SYSCALL (open, 2, (const char *) (name), (flags))
-
-/* Uncancelable openat.  */
-#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
-extern int __openat_nocancel (int fd, const char *fname, int oflag,
-			      mode_t mode) attribute_hidden;
-extern int __openat64_nocancel (int fd, const char *fname, int oflag,
-				mode_t mode) attribute_hidden;
-#else
-# define __openat_nocancel(fd, fname, oflag, mode) \
-  openat (fd, fname, oflag, mode)
-# define __openat64_nocancel(fd, fname, oflag, mode) \
-  openat64 (fd, fname, oflag, mode)
-#endif
-
-#define openat_not_cancel(fd, fname, oflag, mode) \
-  __openat_nocancel (fd, fname, oflag, mode)
-#define openat_not_cancel_3(fd, fname, oflag) \
-  __openat_nocancel (fd, fname, oflag, 0)
-#define openat64_not_cancel(fd, fname, oflag, mode) \
-  __openat64_nocancel (fd, fname, oflag, mode)
-#define openat64_not_cancel_3(fd, fname, oflag) \
-  __openat64_nocancel (fd, fname, oflag, 0)
+static __always_inline int open_not_cancel(const char *name, int flags, mode_t mode)
+{
+	long ret = __internal_sys_open(name, flags, mode);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
+
+static __always_inline int open_not_cancel_2(const char *name, int flags)
+{
+	long ret = __internal_sys_open(name, flags, 0);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
 /* Uncancelable close.  */
-#define close_not_cancel(fd) \
-  INLINE_SYSCALL (close, 1, fd)
-#define close_not_cancel_no_status(fd) \
-  (void) ({ INTERNAL_SYSCALL_DECL (err);				      \
-	    INTERNAL_SYSCALL (close, err, 1, (fd)); })
+static __always_inline int close_not_cancel(int fd)
+{
+	long ret = __internal_sys_close(fd);
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
+
+static __always_inline void close_not_cancel_no_status(int fd)
+{
+	__internal_sys_close(fd);
+}
 
 /* Uncancelable read.  */
-#define read_not_cancel(fd, buf, n) \
-  INLINE_SYSCALL (read, 3, (fd), (buf), (n))
+static __always_inline ssize_t read_not_cancel(int fd, void *buf, size_t n)
+{
+	return SCLIB_LFD_SYSCALL(read, 3, fd, buf, n);
+}
 
 /* Uncancelable write.  */
-#define write_not_cancel(fd, buf, n) \
-  INLINE_SYSCALL (write, 3, (fd), (buf), (n))
+static __always_inline ssize_t write_not_cancel(int fd, const void *buf, size_t n)
+{
+	return SCLIB_LFD_SYSCALL(write, 3, fd, buf, n);
+}
 
 /* Uncancelable writev.  */
-#define writev_not_cancel_no_status(fd, iov, n) \
-  (void) ({ INTERNAL_SYSCALL_DECL (err);				      \
-	    INTERNAL_SYSCALL (writev, err, 3, (fd), (iov), (n)); })
+static __always_inline void writev_not_cancel_no_status(int fd, const struct iovec *iov, int n)
+{
+	SCLIB_LFD_SYSCALL_NOSTATUS(writev, 3, fd, iov, n);
+}
 
 /* Uncancelable fcntl.  */
 #define fcntl_not_cancel(fd, cmd, val) \
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/open.S uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/open.S
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/open.S	2013-09-23 20:39:09.306221878 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/open.S	2013-09-23 20:39:32.982222863 -0400
@@ -5,7 +5,7 @@
 */
 #if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
 
-PSEUDO (__libc_open, open, 3)
+PSEUDO_SCLIB (__libc_open, open, 3)
 ret
 PSEUDO_END(__libc_open)
 
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/powerpc/createthread.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/powerpc/createthread.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/powerpc/createthread.c	2013-09-23 20:39:09.162221874 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/powerpc/createthread.c	2013-09-23 20:39:32.982222863 -0400
@@ -18,7 +18,7 @@
    02111-1307 USA.  */
 
 /* Value passed to 'clone' for initialization of the thread register.  */
-#define TLS_VALUE ((void *) (pd) \
+#define TLS_VALUE ((void *) (kpd) \
 		   + TLS_TCB_OFFSET + TLS_PRE_TCB_SIZE)
 
 /* Get the real implementation.	 */
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pt-close.S uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pt-close.S
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pt-close.S	2013-09-23 20:39:09.238221877 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pt-close.S	2013-09-23 20:39:32.982222863 -0400
@@ -1,5 +1,5 @@
 #include <sysdep-cancel.h>
-PSEUDO (__libc_close, close, 1)
+PSEUDO_SCLIB (__libc_close, close, 1)
 ret
 PSEUDO_END (__libc_close)
 libpthread_hidden_def (__libc_close)
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_attr_setaffinity.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_attr_setaffinity.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_attr_setaffinity.c	2013-09-23 20:39:09.166221874 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_attr_setaffinity.c	2013-09-23 20:39:32.982222863 -0400
@@ -24,16 +24,19 @@
 #include <string.h>
 #include <pthreadP.h>
 
-
+#if 0
 /* Defined in pthread_setaffinity.c.  */
 extern size_t __kernel_cpumask_size attribute_hidden;
+
 extern int __determine_cpumask_size (pid_t tid);
 libpthread_hidden_proto(__determine_cpumask_size)
+#endif
 
 int
 pthread_attr_setaffinity_np (pthread_attr_t *attr, size_t cpusetsize,
 				const cpu_set_t *cpuset)
 {
+#if 0
   struct pthread_attr *iattr;
 
   assert (sizeof (*attr) >= sizeof (struct pthread_attr));
@@ -76,6 +79,7 @@
 
       memcpy (iattr->cpuset, cpuset, cpusetsize);
     }
+#endif
 
   return 0;
 }
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_getaffinity.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_getaffinity.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_getaffinity.c	2013-09-23 20:39:09.242221878 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_getaffinity.c	2013-09-23 20:39:32.982222863 -0400
@@ -32,7 +32,7 @@
   const struct pthread *pd = (const struct pthread *) th;
 
   INTERNAL_SYSCALL_DECL (err);
-  int res = INTERNAL_SYSCALL (sched_getaffinity, err, 3, pd->tid,
+  int res = INTERNAL_SYSCALL (sched_getaffinity, err, 3, pd->pid,
 			      MIN (INT_MAX, cpusetsize), cpuset);
   if (INTERNAL_SYSCALL_ERROR_P (res, err))
     return INTERNAL_SYSCALL_ERRNO (res, err);
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_kill.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_kill.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_kill.c	2013-09-23 20:39:09.262221878 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_kill.c	2013-09-23 20:39:32.982222863 -0400
@@ -30,6 +30,9 @@
      pthread_t threadid,
      int signo)
 {
+  return ENOSYS;
+
+#if 0
   struct pthread *pd = (struct pthread *) threadid;
 
   /* Make sure the descriptor is valid.  */
@@ -74,5 +77,6 @@
 
   return (INTERNAL_SYSCALL_ERROR_P (val, err)
 	  ? INTERNAL_SYSCALL_ERRNO (val, err) : 0);
+#endif
 }
 strong_alias (__pthread_kill, pthread_kill)
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_mutex_cond_lock.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_mutex_cond_lock.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_mutex_cond_lock.c	2013-09-23 20:39:09.138221873 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_mutex_cond_lock.c	2013-09-23 20:39:32.982222863 -0400
@@ -1,3 +1,4 @@
+#if 0
 #include <pthreadP.h>
 
 #define LLL_MUTEX_LOCK(mutex) \
@@ -12,3 +13,4 @@
 #define NO_INCR
 
 #include <pthread_mutex_lock.c>
+#endif
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_setaffinity.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_setaffinity.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_setaffinity.c	2013-09-23 20:39:09.238221877 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_setaffinity.c	2013-09-23 20:39:32.982222863 -0400
@@ -23,10 +23,9 @@
 #include <sysdep.h>
 #include <sys/types.h>
 
-
+#if 0
 size_t __kernel_cpumask_size attribute_hidden;
 
-
 /* Determine the current affinity.  As a side affect we learn
    about the size of the cpumask_t in the kernel.  */
 extern int __determine_cpumask_size (pid_t tid);
@@ -52,11 +51,15 @@
   return 0;
 }
 libpthread_hidden_def(__determine_cpumask_size)
+#endif
 
 int
 pthread_setaffinity_np (pthread_t th, size_t cpusetsize,
 			   const cpu_set_t *cpuset)
 {
+  return 0;
+
+#if 0
   const struct pthread *pd = (const struct pthread *) th;
 
   INTERNAL_SYSCALL_DECL (err);
@@ -89,4 +92,5 @@
   return (INTERNAL_SYSCALL_ERROR_P (res, err)
 	  ? INTERNAL_SYSCALL_ERRNO (res, err)
 	  : 0);
+#endif
 }
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_sigqueue.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_sigqueue.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_sigqueue.c	2013-09-23 20:39:09.166221874 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pthread_sigqueue.c	2013-09-23 20:39:32.982222863 -0400
@@ -33,6 +33,8 @@
      int signo,
      const union sigval value)
 {
+  return ENOSYS;
+#if 0
 #ifdef __NR_rt_tgsigqueueinfo
   struct pthread *pd = (struct pthread *) threadid;
 
@@ -80,4 +82,5 @@
 #else
   return ENOSYS;
 #endif
+#endif
 }
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pt-open.S uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pt-open.S
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pt-open.S	2013-09-23 20:39:09.138221873 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pt-open.S	2013-09-23 20:39:32.982222863 -0400
@@ -1,5 +1,5 @@
 #include <sysdep-cancel.h>
-PSEUDO (__libc_open, open, 3)
+PSEUDO_SCLIB (__libc_open, open, 3)
 ret
 PSEUDO_END (__libc_open)
 libpthread_hidden_def (__libc_open)
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pt-raise.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pt-raise.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pt-raise.c	2013-09-23 20:39:09.238221877 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pt-raise.c	2013-09-23 20:39:32.982222863 -0400
@@ -32,21 +32,21 @@
   /* raise is an async-safe function.  It could be called while the
      fork function temporarily invalidated the PID field.  Adjust for
      that.  */
-  pid_t pid = THREAD_GETMEM (THREAD_SELF, pid);
+  pid_t pid = KTHREAD_GETMEM (KTHREAD_SELF, pid);
   if (__builtin_expect (pid < 0, 0))
     pid = -pid;
 #endif
 
 #if defined(__ASSUME_TGKILL) && __ASSUME_TGKILL
-  return INLINE_SYSCALL (tgkill, 3, pid, THREAD_GETMEM (THREAD_SELF, tid),
+  return INLINE_SYSCALL (tgkill, 3, pid, KTHREAD_GETMEM (KTHREAD_SELF, ktid),
 			 sig);
 #else
 # ifdef __NR_tgkill
-  int res = INLINE_SYSCALL (tgkill, 3, pid, THREAD_GETMEM (THREAD_SELF, tid),
+  int res = INLINE_SYSCALL (tgkill, 3, pid, KTHREAD_GETMEM (KTHREAD_SELF, ktid),
 			    sig);
   if (res != -1 || errno != ENOSYS)
     return res;
 # endif
-  return INLINE_SYSCALL (tkill, 2, THREAD_GETMEM (THREAD_SELF, tid), sig);
+  return INLINE_SYSCALL (tkill, 2, KTHREAD_GETMEM (KTHREAD_SELF, ktid), sig);
 #endif
 }
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pt-read.S uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pt-read.S
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pt-read.S	2013-09-23 20:39:09.142221873 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pt-read.S	2013-09-23 20:39:32.982222863 -0400
@@ -1,5 +1,5 @@
 #include <sysdep-cancel.h>
-PSEUDO (__libc_read, read, 3)
+PSEUDO_SCLIB (__libc_read, read, 3)
 ret
 PSEUDO_END (__libc_read)
 libpthread_hidden_def (__libc_read)
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pt-write.S uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pt-write.S
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/pt-write.S	2013-09-23 20:39:09.162221874 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/pt-write.S	2013-09-23 20:39:32.982222863 -0400
@@ -1,5 +1,6 @@
 #include <sysdep-cancel.h>
-PSEUDO (__libc_write, write, 3)
+
+PSEUDO_SCLIB (__libc_write, write, 3)
 ret
 PSEUDO_END (__libc_write)
 libpthread_hidden_def (__libc_write)
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/raise.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/raise.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/raise.c	2013-09-23 20:39:09.138221873 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/raise.c	2013-09-23 20:39:32.982222863 -0400
@@ -29,11 +29,11 @@
 raise (
      int sig)
 {
-  struct pthread *pd = THREAD_SELF;
+  struct kpthread *kpd = KTHREAD_SELF;
 #if (defined(__ASSUME_TGKILL) && __ASSUME_TGKILL) || defined __NR_tgkill
-  pid_t pid = THREAD_GETMEM (pd, pid);
+  pid_t pid = KTHREAD_GETMEM (kpd, pid);
 #endif
-  pid_t selftid = THREAD_GETMEM (pd, tid);
+  pid_t selftid = KTHREAD_GETMEM (kpd, ktid);
   if (selftid == 0)
     {
       /* This system call is not supposed to fail.  */
@@ -43,7 +43,7 @@
 #else
       selftid = INLINE_SYSCALL (gettid, 0);
 #endif
-      THREAD_SETMEM (pd, tid, selftid);
+      KTHREAD_SETMEM (kpd, ktid, selftid);
 
 #if (defined(__ASSUME_TGKILL) && __ASSUME_TGKILL) || defined __NR_tgkill
       /* We do not set the PID field in the TID here since we might be
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/read.S uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/read.S
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/read.S	2013-09-23 20:39:09.314221882 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/read.S	2013-09-23 20:39:32.982222863 -0400
@@ -5,7 +5,7 @@
 */
 #if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
 
-PSEUDO (__libc_read, read, 3)
+PSEUDO_SCLIB (__libc_read, read, 3)
 ret
 PSEUDO_END(__libc_read)
 
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/register-atfork.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/register-atfork.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/register-atfork.c	2013-09-23 20:39:09.314221882 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/register-atfork.c	2013-09-23 20:39:32.982222863 -0400
@@ -26,8 +26,7 @@
 
 
 /* Lock to protect allocation and deallocation of fork handlers.  */
-int __fork_lock = LLL_LOCK_INITIALIZER;
-
+__libc_lock_define_initialized(, __fork_lock);
 
 /* Number of pre-allocated handler entries.  */
 #define NHANDLER 48
@@ -87,7 +86,7 @@
      void *dso_handle)
 {
   /* Get the lock to not conflict with other allocations.  */
-  lll_lock (__fork_lock, LLL_PRIVATE);
+  __libc_lock_lock (__fork_lock);
 
   struct fork_handler *newp = fork_handler_alloc ();
 
@@ -103,7 +102,7 @@
     }
 
   /* Release the lock.  */
-  lll_unlock (__fork_lock, LLL_PRIVATE);
+  __libc_lock_unlock (__fork_lock);
 
   return newp == NULL ? ENOMEM : 0;
 }
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/sem_post.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/sem_post.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/sem_post.c	2013-09-23 20:39:09.166221874 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/sem_post.c	2013-09-23 20:39:32.982222863 -0400
@@ -24,10 +24,20 @@
 #include <internaltypes.h>
 #include <semaphore.h>
 #include <tls.h>
+#include <scheduleP.h>
 
 int
 __new_sem_post (sem_t *sem)
 {
+  long err = __sclib_sem_post (&sem->sclib_sem);
+  if (__builtin_expect (err != 0, 0))
+    {
+      __set_errno (err);
+      return -1;
+    }
+  return 0;
+
+#if 0
   struct new_sem *isem = (struct new_sem *) sem;
 
   __typeof (isem->value) cur;
@@ -54,5 +64,6 @@
 	}
     }
   return 0;
+#endif
 }
 weak_alias(__new_sem_post, sem_post)
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/sem_timedwait.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/sem_timedwait.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/sem_timedwait.c	2013-09-23 20:39:09.142221873 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/sem_timedwait.c	2013-09-23 20:39:32.982222863 -0400
@@ -26,7 +26,7 @@
 
 #include <pthreadP.h>
 
-
+#if 0
 extern void __sem_wait_cleanup (void *arg) attribute_hidden;
 
 
@@ -109,3 +109,4 @@
 
   return err;
 }
+#endif
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/sem_trywait.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/sem_trywait.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/sem_trywait.c	2013-09-23 20:39:09.142221873 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/sem_trywait.c	2013-09-23 20:39:32.982222863 -0400
@@ -23,11 +23,20 @@
 #include <lowlevellock.h>
 #include <internaltypes.h>
 #include <semaphore.h>
-
+#include <scheduleP.h>
 
 int
 __new_sem_trywait (sem_t *sem)
 {
+  long err = __sclib_sem_trywait (&sem->sclib_sem);
+  if (__builtin_expect (err != 0, 0))
+    {
+      __set_errno (err);
+      return -1;
+    }
+  return 0;
+
+#if 0
   int *futex = (int *) sem;
   int val;
 
@@ -40,5 +49,6 @@
 
   __set_errno (EAGAIN);
   return -1;
+#endif
 }
 weak_alias(__new_sem_trywait, sem_trywait)
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/sem_wait.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/sem_wait.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/sem_wait.c	2013-09-23 20:39:09.238221877 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/sem_wait.c	2013-09-23 20:39:32.982222863 -0400
@@ -25,8 +25,9 @@
 #include <semaphore.h>
 
 #include <pthreadP.h>
+#include <scheduleP.h>
 
-
+#if 0
 void
 attribute_hidden
 __sem_wait_cleanup (void *arg)
@@ -35,11 +36,20 @@
 
   atomic_decrement (&isem->nwaiters);
 }
-
+#endif
 
 int
 __new_sem_wait (sem_t *sem)
 {
+  long err = __sclib_sem_wait (&sem->sclib_sem);
+  if (__builtin_expect (err != 0, 0))
+    {
+      __set_errno (err);
+      return -1;
+    }
+  return 0;
+
+#if 0
   struct new_sem *isem = (struct new_sem *) sem;
   int err;
 
@@ -80,5 +90,6 @@
   atomic_decrement (&isem->nwaiters);
 
   return err;
+#endif
 }
 weak_alias(__new_sem_wait, sem_wait)
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/sh/createthread.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/sh/createthread.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/sh/createthread.c	2013-09-23 20:39:09.286221880 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/sh/createthread.c	2013-09-23 20:39:32.982222863 -0400
@@ -17,7 +17,7 @@
    02111-1307 USA.  */
 
 /* Value passed to 'clone' for initialization of the thread register.  */
-#define TLS_VALUE (pd + 1)
+#define TLS_VALUE (kpd + 1)
 
 
 /* Get the real implementation.  */
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/unregister-atfork.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/unregister-atfork.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/unregister-atfork.c	2013-09-23 20:39:09.262221878 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/unregister-atfork.c	2013-09-23 20:39:32.986222863 -0400
@@ -55,7 +55,7 @@
      that there couldn't have been another thread deleting something.
      The __unregister_atfork function is only called from the
      dlclose() code which itself serializes the operations.  */
-  lll_lock (__fork_lock, LLL_PRIVATE);
+  __libc_lock_lock (__fork_lock);
 
   /* We have to create a new list with all the entries we don't remove.  */
   struct deleted_handler
@@ -101,7 +101,7 @@
   while (runp != NULL);
 
   /* Release the lock.  */
-  lll_unlock (__fork_lock, LLL_PRIVATE);
+  __libc_lock_unlock (__fork_lock);
 
   /* Walk the list of all entries which have to be deleted.  */
   while (deleted != NULL)
@@ -116,7 +116,7 @@
       atomic_decrement (&deleted->handler->refcntr);
       unsigned int val;
       while ((val = deleted->handler->refcntr) != 0)
-	lll_futex_wait (&deleted->handler->refcntr, val, LLL_PRIVATE);
+	__libc_futex_wait (&deleted->handler->refcntr, val);
 
       deleted = deleted->next;
     }
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/write.S uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/write.S
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/write.S	2013-09-23 20:39:09.238221877 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/write.S	2013-09-23 20:39:32.986222863 -0400
@@ -5,7 +5,7 @@
 */
 #if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
 
-PSEUDO (__libc_write, write, 3)
+PSEUDO_SCLIB (__libc_write, write, 3)
 ret
 PSEUDO_END(__libc_write)
 
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h	2013-09-23 20:39:09.258221877 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h	2013-09-23 20:39:32.986222863 -0400
@@ -21,6 +21,7 @@
 #define _BITS_PTHREADTYPES_H	1
 
 #include <bits/wordsize.h>
+#include <schedule_defsP.h>
 
 #if __WORDSIZE == 64
 # define __SIZEOF_PTHREAD_ATTR_T 56
@@ -100,6 +101,7 @@
 #endif
   } __data;
   char __size[__SIZEOF_PTHREAD_MUTEX_T];
+  struct __sclib_mutex sclib_mutex;
   long int __align;
 } pthread_mutex_t;
 
@@ -126,6 +128,7 @@
     unsigned int __broadcast_seq;
   } __data;
   char __size[__SIZEOF_PTHREAD_COND_T];
+  struct __sclib_cond sclib_cond;
   __extension__ long long int __align;
 } pthread_cond_t;
 
@@ -185,6 +188,7 @@
   } __data;
 # endif
   char __size[__SIZEOF_PTHREAD_RWLOCK_T];
+  struct __sclib_rwlock sclib_rwlock;
   long int __align;
 } pthread_rwlock_t;
 
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/bits/semaphore.h uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/bits/semaphore.h
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/bits/semaphore.h	2013-09-23 20:39:09.258221877 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/bits/semaphore.h	2013-09-23 20:39:32.986222863 -0400
@@ -23,6 +23,8 @@
 
 #include <bits/wordsize.h>
 
+#include <schedule_defsP.h>
+
 #if __WORDSIZE == 64
 # define __SIZEOF_SEM_T	32
 #else
@@ -37,5 +39,6 @@
 typedef union
 {
   char __size[__SIZEOF_SEM_T];
+  struct __sclib_sem sclib_sem;
   long int __align;
 } sem_t;
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/cancellation.S uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/cancellation.S
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/cancellation.S	2013-09-23 20:39:09.258221877 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/cancellation.S	2013-09-23 20:39:32.986222863 -0400
@@ -1,4 +1,5 @@
 /* Copyright (C) 2009 Free Software Foundation, Inc.
+   Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2009.
 
@@ -25,10 +26,12 @@
 #ifdef IS_IN_libpthread
 # ifdef SHARED
 #  define __pthread_unwind __GI___pthread_unwind
+#  define __sclib_futex_wait __GI___sclib_futex_wait
 # endif
 #else
 # ifndef SHARED
 	.weak __pthread_unwind
+	.weak __sclib_futex_wait
 # endif
 #endif
 
@@ -55,26 +58,31 @@
 
 	.hidden __pthread_enable_asynccancel
 ENTRY(__pthread_enable_asynccancel)
-	movl	%fs:CANCELHANDLING, %eax
+	ret
+	pushq	%rdi
+	movq	%fs:CURRENT_TLS, %rdi
+	movl	CANCELHANDLING(%rdi), %eax
 2:	movl	%eax, %r11d
 	orl	$TCB_CANCELTYPE_BITMASK, %r11d
 	cmpl	%eax, %r11d
 	je	1f
 
 	lock
-	cmpxchgl %r11d, %fs:CANCELHANDLING
+	cmpxchgl %r11d, CANCELHANDLING(%rdi)
 	jnz	2b
 
 	andl	$(TCB_CANCELSTATE_BITMASK|TCB_CANCELTYPE_BITMASK|TCB_CANCELED_BITMASK|TCB_EXITING_BITMASK|TCB_CANCEL_RESTMASK|TCB_TERMINATED_BITMASK), %r11d
 	cmpl	$(TCB_CANCELTYPE_BITMASK|TCB_CANCELED_BITMASK), %r11d
 	je	3f
 
-1:	ret
+1:	popq	%rdi
+	ret
 
-3:	movq	$TCB_PTHREAD_CANCELED, %fs:RESULT
+3:	popq	%rax
+	movq	$TCB_PTHREAD_CANCELED, RESULT(%rdi)
 	lock
-	orl	$TCB_EXITING_BITMASK, %fs:CANCELHANDLING
-	movq	%fs:CLEANUP_JMP_BUF, %rdi
+	orl	$TCB_EXITING_BITMASK, CANCELHANDLING(%rdi)
+	movq	CLEANUP_JMP_BUF(%rdi), %rdi
 #ifdef SHARED
 	call	__pthread_unwind@PLT
 #else
@@ -86,31 +94,35 @@
 
 	.hidden __pthread_disable_asynccancel
 ENTRY(__pthread_disable_asynccancel)
+	ret
 	testl	$TCB_CANCELTYPE_BITMASK, %edi
 	jnz	1f
 
-	movl	%fs:CANCELHANDLING, %eax
+	movq	%fs:CURRENT_TLS, %rdi
+	movl	CANCELHANDLING(%rdi), %eax
 2:	movl	%eax, %r11d
 	andl	$~TCB_CANCELTYPE_BITMASK, %r11d
 	lock
-	cmpxchgl %r11d, %fs:CANCELHANDLING
+	cmpxchgl %r11d, CANCELHANDLING(%rdi)
 	jnz	2b
 
-	movl	%r11d, %eax
-3:	andl	$(TCB_CANCELING_BITMASK|TCB_CANCELED_BITMASK), %eax
-	cmpl	$TCB_CANCELING_BITMASK, %eax
+	movl	%r11d, %esi
+3:	andl	$(TCB_CANCELING_BITMASK|TCB_CANCELED_BITMASK), %esi
+	cmpl	$TCB_CANCELING_BITMASK, %esi
 	je	4f
 1:	ret
 
 	/* Performance doesn't matter in this loop.  We will
 	   delay until the thread is canceled.  And we will unlikely
 	   enter the loop twice.  */
-4:	movq	%fs:0, %rdi
-	movl	$__NR_futex, %eax
-	xorq	%r10, %r10
-	addq	$CANCELHANDLING, %rdi
-	LOAD_PRIVATE_FUTEX_WAIT (%esi)
-	syscall
-	movl	%fs:CANCELHANDLING, %eax
+4:	pushq	%rdi
+	leaq	CANCELHANDLING(%rdi), %rdi
+#ifdef SHARED
+	call	__sclib_futex_wait@PLT
+#else
+	call	__sclib_futex_wait
+#endif
+	popq	%rdi
+	movl	CANCELHANDLING(%rdi), %esi
 	jmp	3b
 END(__pthread_disable_asynccancel)
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/clone.S uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/clone.S
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/clone.S	2013-09-23 20:39:09.242221878 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/clone.S	2013-09-23 20:39:32.986222863 -0400
@@ -1,3 +1,6 @@
 #include <tcb-offsets.h>
+#include <sysdep.h>
 #define RESET_PID
+#define __CLONE_CALL(x) JUMPTARGET(x)
+#define CLONE_NOWRAPPER
 #include <libc/sysdeps/linux/x86_64/clone.S>
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/fork.c uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/fork.c
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/fork.c	2013-09-23 20:39:09.258221877 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/fork.c	2013-09-23 20:39:32.986222863 -0400
@@ -1,4 +1,5 @@
 /* Copyright (C) 2003 Free Software Foundation, Inc.
+   Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
 
@@ -21,11 +22,22 @@
 #include <signal.h>
 #include <sysdep.h>
 #include <tls.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <semaphore.h>
+#include <string.h>
+#include <sys/eventfd.h>
+
+#include <bits/sclib.h>
+#include <bits/sclib_syscalls.h>
+
+static inline long __ARCH_FORK(void)
+{
+	long ret = __internal_sys_fork();
+	SCLIB_ERR_RET(ret);
+	return ret;
+}
 
-
-#define ARCH_FORK() \
-  INLINE_SYSCALL (clone, 4,						      \
-		  CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID | SIGCHLD, 0,     \
-		  NULL, &THREAD_SELF->tid)
+#define ARCH_FORK __ARCH_FORK
 
 #include "../fork.c"
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h	2013-09-23 20:39:09.262221878 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h	2013-09-23 20:39:32.986222863 -0400
@@ -1,4 +1,5 @@
 /* Copyright (C) 2002-2004, 2006-2008, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -26,6 +27,9 @@
 # include <bits/pthreadtypes.h>
 # include <bits/kernel-features.h>
 # include <tcb-offsets.h>
+# include <scheduleP.h>
+
+typedef struct __sclib_mutex_auto lll_lock_t;
 
 # ifndef LOCK_INSTR
 #  ifdef UP
@@ -97,7 +101,7 @@
 #endif
 
 /* Initializer for lock.  */
-#define LLL_LOCK_INITIALIZER		(0)
+#define LLL_LOCK_INITIALIZER		{ 0, 0, 0, 0 }
 #define LLL_LOCK_INITIALIZER_LOCKED	(1)
 #define LLL_LOCK_INITIALIZER_WAITERS	(2)
 
@@ -203,11 +207,13 @@
 LLL_STUB_UNWIND_INFO_END
 
 
-#define lll_futex_wait(futex, val, private) \
-  lll_futex_timed_wait(futex, val, NULL, private)
+#define lll_futex_wait(futex, val, private)	\
+	__sclib_futex_wait((int *) (futex), (val))
 
+#define lll_real_futex_wait(futex, val, private)	\
+  lll_real_futex_timed_wait(futex, val, NULL, private)
 
-#define lll_futex_timed_wait(futex, val, timeout, private) \
+#define lll_real_futex_timed_wait(futex, val, timeout, private) \
   ({									      \
     register const struct timespec *__to __asm__ ("r10") = timeout;	      \
     int __status;							      \
@@ -222,7 +228,10 @@
   })
 
 
-#define lll_futex_wake(futex, nr, private) \
+#define lll_futex_wake(futex, nr, private)	\
+	__sclib_futex_wake((int *) (futex), (nr))
+
+#define lll_real_futex_wake(futex, nr, private) \
   do {									      \
     int __ignore;							      \
     register __typeof (nr) _nr __asm__ ("edx") = (nr);			      \
@@ -252,6 +261,10 @@
 #endif
 
 #define lll_trylock(futex) \
+	__sclib_mutex_auto_trylock(&(futex))
+
+/*
+#define lll_trylock(futex) \
   ({ int ret;								      \
      __asm__ __volatile__ (__lll_trylock_asm				      \
 		       : "=a" (ret), "=m" (futex)			      \
@@ -259,6 +272,7 @@
 			 "0" (LLL_LOCK_INITIALIZER)			      \
 		       : "memory");					      \
      ret; })
+*/
 
 #define lll_robust_trylock(futex, id) \
   ({ int ret;								      \
@@ -268,6 +282,7 @@
 		       : "memory");					      \
      ret; })
 
+/*
 #define lll_cond_trylock(futex) \
   ({ int ret;								      \
      __asm__ __volatile__ (LOCK_INSTR "cmpxchgl %2, %1"			      \
@@ -276,6 +291,7 @@
 			 "m" (futex), "0" (LLL_LOCK_INITIALIZER)	      \
 		       : "memory");					      \
      ret; })
+*/
 
 #if defined NOT_IN_libc || defined UP
 # define __lll_lock_asm_start LOCK_INSTR "cmpxchgl %4, %2\n\t"		      \
@@ -291,6 +307,14 @@
 #endif
 
 #define lll_lock(futex, private) \
+	__sclib_mutex_auto_lock(&(futex))
+
+#define lll_unlock(futex, private) \
+	__sclib_mutex_auto_unlock(&(futex))
+
+#if 0
+
+#define lll_lock(futex, private) \
   (void)								      \
     ({ int ignore1, ignore2, ignore3;					      \
        if (__builtin_constant_p (private) && (private) == LLL_PRIVATE)	      \
@@ -353,6 +377,7 @@
 		      : "cx", "r11", "cc", "memory");			      \
     __ret; })
 
+
 #define lll_cond_lock(futex, private) \
   (void)								      \
     ({ int ignore1, ignore2, ignore3;					      \
@@ -538,6 +563,8 @@
     }									      \
   while (0)
 
+#endif
+
 /* Returns non-zero if error happened, zero if success.  */
 #define lll_futex_requeue(ftx, nr_wake, nr_move, mutex, val, private) \
   ({ int __res;								      \
@@ -553,6 +580,7 @@
 		       : "cx", "r11", "cc", "memory");			      \
      __res < 0; })
 
+#if 0
 #define lll_islocked(futex) \
   (futex != LLL_LOCK_INITIALIZER)
 
@@ -592,6 +620,7 @@
 	  __ret = __lll_timedwait_tid (&tid, abstime);		      \
       }									      \
     __ret; })
+#endif
 
 #endif  /* !__ASSEMBLER__ */
 
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/Makefile.arch uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/Makefile.arch
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/Makefile.arch	2013-09-23 20:39:09.258221877 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/Makefile.arch	2013-09-23 20:39:32.986222863 -0400
@@ -6,15 +6,11 @@
 #
 
 libpthread_linux_arch_SSRC = pt-vfork.S clone.S pthread_once.S \
-	lowlevellock.S pthread_barrier_wait.S pthread_cond_signal.S pthread_cond_broadcast.S \
-	sem_post.S sem_timedwait.S lowlevelrobustlock.S \
-	sem_trywait.S sem_wait.S pthread_rwlock_rdlock.S pthread_rwlock_wrlock.S \
-	pthread_rwlock_timedrdlock.S pthread_rwlock_timedwrlock.S pthread_rwlock_unlock.S \
-	pthread_spin_unlock.S cancellation.S pthread_cond_timedwait.S pthread_cond_wait.S
+	pthread_spin_unlock.S cancellation.S
 libpthread_linux_arch_CSRC = pthread_spin_init.c pt-__syscall_error.c
 
 libc_linux_arch_CSRC = fork.c
-libc_linux_arch_SSRC = clone.S vfork.S libc-cancellation.S libc-lowlevellock.S
+libc_linux_arch_SSRC = clone.S vfork.S libc-cancellation.S
 libc_linux_arch_SSRC-OMIT = waitpid.S
 librt_linux_arch_SSRC = librt-cancellation.S
 
@@ -22,15 +18,11 @@
 
 CFLAGS-pt-__syscall_error.c =  -DNOT_IN_libc -DIS_IN_libpthread
 ASFLAGS-pt-vfork.S = -DNOT_IN_libc -DIS_IN_libpthread -D_LIBC_REENTRANT
-ASFLAGS-lowlevellock.S = -DNOT_IN_libc -DIS_IN_libpthread -D_LIBC_REENTRANT
 ASFLAGS-pthread_once.S = -DNOT_IN_libc -DIS_IN_libpthread -D_LIBC_REENTRANT
 ASFLAGS-cancellation.S = -DNOT_IN_libc -DIS_IN_libpthread -D_LIBC_REENTRANT
-ASFLAGS-pthread_cond_timedwait.S = -D_LIBC_REENTRANT
-ASFLAGS-pthread_cond_wait.S = -D_LIBC_REENTRANT
 
 ASFLAGS-clone.S = -D_LIBC_REENTRANT
 ASFLAGS-vfork.S = -D_LIBC_REENTRANT
-ASFLAGS-libc-lowlevellock.S = -D_LIBC_REENTRANT
 ASFLAGS-libc-cancellation.S = -D_LIBC_REENTRANT
 ifeq ($(UCLIBC_HAS_STDIO_FUTEXES),y)
 CFLAGS-fork.c = -D__USE_STDIO_FUTEXES__
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_barrier_wait.S uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_barrier_wait.S
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_barrier_wait.S	2013-09-23 20:39:09.262221878 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_barrier_wait.S	2013-09-23 20:39:32.986222863 -0400
@@ -136,7 +136,7 @@
 1:	movl	PRIVATE(%rdi), %esi
 	addq	$MUTEX, %rdi
 	xorl	$LLL_SHARED, %esi
-	callq	__lll_lock_wait
+	callq	__sclib_futex_wait
 	subq	$MUTEX, %rdi
 	jmp	2b
 
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S	2013-09-23 20:39:09.242221878 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S	2013-09-23 20:39:32.986222863 -0400
@@ -1,4 +1,5 @@
 /* Copyright (C) 2002, 2003, 2005, 2007, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -22,6 +23,17 @@
 #include <tcb-offsets.h>
 #include <lowlevellock.h>
 
+#ifdef IS_IN_libpthread
+# ifdef SHARED
+#  define __sclib_futex_wake __GI___sclib_futex_wake
+#  define __sclib_futex_wait __GI___sclib_futex_wait
+# endif
+#else
+# ifndef SHARED
+	.weak __sclib_futex_wake
+	.weak __sclib_futex_wait
+# endif
+#endif
 
 	.comm	__fork_generation, 4, 4
 
@@ -43,23 +55,22 @@
 	/* Preserve the function pointer.  */
 1:	pushq	%rsi
 	cfi_adjust_cfa_offset(8)
-	xorq	%r10, %r10
 
 	/* Not yet initialized or initialization in progress.
 	   Get the fork generation counter now.  */
 6:	movl	(%rdi), %eax
 
-5:	movl	%eax, %edx
+5:	movl	%eax, %esi
 
 	testl	$2, %eax
 	jnz	4f
 
-	andl	$3, %edx
-	orl	__fork_generation(%rip), %edx
-	orl	$1, %edx
+	andl	$3, %esi
+	orl	__fork_generation(%rip), %esi
+	orl	$1, %esi
 
 	LOCK
-	cmpxchgl %edx, (%rdi)
+	cmpxchgl %esi, (%rdi)
 	jnz	5b
 
 	/* Check whether another thread already runs the initializer.  */
@@ -68,23 +79,15 @@
 
 	/* Check whether the initializer execution was interrupted
 	   by a fork.  */
-	xorl	%edx, %eax
+	xorl	%esi, %eax
 	testl	$0xfffffffc, %eax
 	jnz	3f	/* Different for generation -> run initializer.  */
 
-	/* Somebody else got here first.  Wait.  */
-#ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_WAIT|FUTEX_PRIVATE_FLAG, %esi
+#ifdef SHARED
+	call	__sclib_futex_wait@PLT
 #else
-# if FUTEX_WAIT == 0
-	movl	%fs:PRIVATE_FUTEX, %esi
-# else
-	movl	$FUTEX_WAIT, %esi
-	orl	%fs:PRIVATE_FUTEX, %esi
-# endif
+	call	__sclib_futex_wait
 #endif
-	movl	$SYS_futex, %eax
-	syscall
 	jmp	6b
 
 	/* Preserve the pointer to the control variable.  */
@@ -109,15 +112,12 @@
 	cfi_adjust_cfa_offset(-8)
 
 	/* Wake up all other threads.  */
-	movl	$0x7fffffff, %edx
-#ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_WAKE|FUTEX_PRIVATE_FLAG, %esi
+	movl	$0x7fffffff, %esi
+#ifdef SHARED
+	call	__sclib_futex_wake@PLT
 #else
-	movl	$FUTEX_WAKE, %esi
-	orl	%fs:PRIVATE_FUTEX, %esi
+	call	__sclib_futex_wake
 #endif
-	movl	$SYS_futex, %eax
-	syscall
 
 4:	addq	$8, %rsp
 	cfi_adjust_cfa_offset(-8)
@@ -141,15 +141,12 @@
 	movq	%rax, %r8
 	movl	$0, (%rdi)
 
-	movl	$0x7fffffff, %edx
-#ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_WAKE|FUTEX_PRIVATE_FLAG, %esi
+	movl	$0x7fffffff, %esi
+#ifdef SHARED
+	call	__sclib_futex_wake@PLT
 #else
-	movl	$FUTEX_WAKE, %esi
-	orl	%fs:PRIVATE_FUTEX, %esi
+	call	__sclib_futex_wake
 #endif
-	movl	$SYS_futex, %eax
-	syscall
 
 	movq	%r8, %rdi
 .LcallUR:
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/pt-vfork.S uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/pt-vfork.S
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/pt-vfork.S	2013-09-23 20:39:09.262221878 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/pt-vfork.S	2013-09-23 20:39:32.986222863 -0400
@@ -17,6 +17,7 @@
    02111-1307 USA.  */
 
 #include <tcb-offsets.h>
+#include <sysdep.h>
 
 #define SAVE_PID \
 	movl	%fs:PID, %esi;						      \
@@ -30,4 +31,6 @@
 	movl	%esi, %fs:PID;						      \
 1:
 
+#define __VFORK_CALL(x) JUMPTARGET(x)
+
 #include <../../../../../../../libc/sysdeps/linux/x86_64/vfork.S>
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/sysdep-cancel.h uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/sysdep-cancel.h
--- uClibc-0.9.33/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/sysdep-cancel.h	2013-09-23 20:39:09.242221878 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/unix/sysv/linux/x86_64/sysdep-cancel.h	2013-09-23 20:39:32.986222863 -0400
@@ -1,4 +1,5 @@
 /* Copyright (C) 2002-2006, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
    This file is part of the GNU C Library.
    Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
 
@@ -30,7 +31,16 @@
    and %r11 if they return.  Therefore we don't have to preserve other
    registers around these calls.  */
 # undef PSEUDO
-# define PSEUDO(name, syscall_name, args)				      \
+# undef PSEUDO_SCLIB
+# undef PSEUDO_MACRO
+
+# define PSEUDO(name, syscall_name, args)	\
+	PSEUDO_MACRO(name, syscall_name, args, DO_CALL)
+
+# define PSEUDO_SCLIB(name, syscall_name, args)	\
+	PSEUDO_MACRO(name, syscall_name, args, DO_SCLIB_CALL)
+
+# define PSEUDO_MACRO(name, syscall_name, args, docall)				      \
   .text;								      \
   ENTRY (name)								      \
     SINGLE_THREAD_P;							      \
@@ -38,7 +48,7 @@
   .type __##syscall_name##_nocancel,@function;				      \
   .globl __##syscall_name##_nocancel;					      \
   __##syscall_name##_nocancel:						      \
-    DO_CALL (syscall_name, args);					      \
+    docall (syscall_name, args);					      \
     cmpq $-4095, %rax;							      \
     jae SYSCALL_ERROR_LABEL;						      \
     ret;								      \
@@ -49,7 +59,7 @@
     CENABLE								      \
     /* The return value from CENABLE is argument for CDISABLE.  */	      \
     movq %rax, (%rsp);							      \
-    DO_CALL (syscall_name, args);					      \
+    docall (syscall_name, args);					      \
     movq (%rsp), %rdi;							      \
     /* Save %rax since it's the error code from the syscall.  */	      \
     movq %rax, %rdx;							      \
@@ -92,7 +102,8 @@
   __builtin_expect (THREAD_GETMEM (THREAD_SELF, \
 				   header.multiple_threads) == 0, 1)
 #  else
-#   define SINGLE_THREAD_P cmpl $0, %fs:MULTIPLE_THREADS_OFFSET
+#   define SINGLE_THREAD_P movq %fs:CURRENT_TLS, %rax; \
+						   cmpl $0, MULTIPLE_THREADS_OFFSET(%rax)
 #  endif
 
 # endif
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/x86_64/tcb-offsets.sym uClibc-0.9.33-new/libpthread/nptl/sysdeps/x86_64/tcb-offsets.sym
--- uClibc-0.9.33/libpthread/nptl/sysdeps/x86_64/tcb-offsets.sym	2013-09-23 20:39:09.366221882 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/x86_64/tcb-offsets.sym	2013-09-23 20:39:32.986222863 -0400
@@ -2,9 +2,10 @@
 #include <tls.h>
 
 RESULT			offsetof (struct pthread, result)
-TID			offsetof (struct pthread, tid)
-PID			offsetof (struct pthread, pid)
+TID			offsetof (struct kpthread, ktid)
+PID			offsetof (struct kpthread, pid)
 CANCELHANDLING		offsetof (struct pthread, cancelhandling)
+CURRENT_TLS	offsetof (struct kpthread, header.tcb)
 CLEANUP_JMP_BUF		offsetof (struct pthread, cleanup_jmp_buf)
 CLEANUP			offsetof (struct pthread, cleanup)
 CLEANUP_PREV		offsetof (struct _pthread_cleanup_buffer, __prev)
diff -urN uClibc-0.9.33/libpthread/nptl/sysdeps/x86_64/tls.h uClibc-0.9.33-new/libpthread/nptl/sysdeps/x86_64/tls.h
--- uClibc-0.9.33/libpthread/nptl/sysdeps/x86_64/tls.h	2013-09-23 20:39:09.366221882 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/sysdeps/x86_64/tls.h	2013-09-23 20:39:32.986222863 -0400
@@ -1,5 +1,6 @@
 /* Definition for thread-local data handling.  nptl/x86_64 version.
    Copyright (C) 2002-2007, 2008, 2009 Free Software Foundation, Inc.
+   Copyright (C) 2013 Ruslan Nikolaev <rnikola@vt.edu>
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -119,6 +120,8 @@
 /* This is the size of the TCB.  */
 # define TLS_TCB_SIZE sizeof (struct pthread)
 
+# define TLS_KTCB_SIZE sizeof (struct kpthread)
+
 /* Alignment requirements for the TCB.  */
 //# define TLS_TCB_ALIGN __alignof__ (struct pthread)
 // Normally the above would be correct  But we have to store post-AVX
@@ -139,7 +142,7 @@
 
 /* Install new dtv for current thread.  */
 # define INSTALL_NEW_DTV(dtvp) \
-  ({ struct pthread *__pd;						      \
+  ({ struct pthread *__pd = THREAD_SELF;		    \
      THREAD_SETMEM (__pd, header.dtv, (dtvp)); })
 
 /* Return dtv of given thread descriptor.  */
@@ -147,26 +150,17 @@
   (((tcbhead_t *) (descr))->dtv)
 
 
-/* Macros to load from and store into segment registers.  */
-# define TLS_GET_FS() \
-  ({ int __seg; __asm__ ("movl %%fs, %0" : "=q" (__seg)); __seg; })
-# define TLS_SET_FS(val) \
-  __asm__ ("movl %0, %%fs" :: "q" (val))
-
-
 /* Code to initially initialize the thread pointer.  This might need
    special attention since 'errno' is not yet available and if the
    operation can cause a failure 'errno' must not be touched.
 
    We have to make the syscall for both uses of the macro since the
    address might be (and probably is) different.  */
-# define TLS_INIT_TP(thrdescr, secondcall) \
+# define TLS_INIT_KTP(thrdescr, secondcall) \
   ({ void *_thrdescr = (thrdescr);					      \
      tcbhead_t *_head = _thrdescr;					      \
      int _result;							      \
 									      \
-     _head->tcb = _thrdescr;						      \
-     /* For now the thread descriptor is at the same address.  */	      \
      _head->self = _thrdescr;						      \
 									      \
      /* It is a simple syscall to set the %fs value for the thread.  */	      \
@@ -180,10 +174,22 @@
     _result ? "cannot set %fs base address for thread-local storage" : 0;     \
   })
 
+# define TLS_INIT_TP(thrdescr, secondcall) \
+  ({ void *_thrdescr = (thrdescr);					      \
+     tcbhead_t *_head = _thrdescr;					      \
+	 struct kpthread *__kpd;	\
+									      \
+     _head->tcb = _thrdescr;						      \
+     /* For now the thread descriptor is at the same address.  */	      \
+     _head->self = _thrdescr;						      \
+									      \
+	 KTHREAD_SETMEM(__kpd, header.tcb, _thrdescr);		\
+    0;     \
+  })
 
 /* Return the address of the dtv for the current thread.  */
 # define THREAD_DTV() \
-  ({ struct pthread *__pd;						      \
+  ({ struct pthread *__pd = THREAD_SELF;		      \
      THREAD_GETMEM (__pd, header.dtv); })
 
 
@@ -193,27 +199,31 @@
    assignments like
 	pthread_descr self = thread_self();
    do not get optimized away.  */
-# define THREAD_SELF \
-  ({ struct pthread *__self;						      \
+# define KTHREAD_SELF \
+  ({ struct kpthread *__self;						      \
      __asm__ ("movq %%fs:%c1,%q0" : "=r" (__self)				      \
-	  : "i" (offsetof (struct pthread, header.self)));	 	      \
+	  : "i" (offsetof (struct kpthread, header.self)));	 	      \
      __self;})
 
+# define THREAD_SELF \
+  ({ struct kpthread *__kpd;		      \
+     (struct pthread *) (KTHREAD_GETMEM (__kpd, header.tcb)); })
+
 /* Magic for libthread_db to know how to do THREAD_SELF.  */
 # define DB_THREAD_SELF_INCLUDE  <sys/reg.h> /* For the FS constant.  */
 # define DB_THREAD_SELF CONST_THREAD_AREA (64, FS)
 
 /* Read member of the thread descriptor directly.  */
-# define THREAD_GETMEM(descr, member) \
+# define KTHREAD_GETMEM(descr, member) \
   ({ __typeof (descr->member) __value;					      \
      if (sizeof (__value) == 1)						      \
        __asm__ __volatile__ ("movb %%fs:%P2,%b0"				      \
 		     : "=q" (__value)					      \
-		     : "0" (0), "i" (offsetof (struct pthread, member)));     \
+		     : "0" (0), "i" (offsetof (struct kpthread, member)));     \
      else if (sizeof (__value) == 4)					      \
        __asm__ __volatile__ ("movl %%fs:%P1,%0"					      \
 		     : "=r" (__value)					      \
-		     : "i" (offsetof (struct pthread, member)));	      \
+		     : "i" (offsetof (struct kpthread, member)));	      \
      else								      \
        {								      \
 	 if (sizeof (__value) != 8)					      \
@@ -223,23 +233,24 @@
 									      \
 	 __asm__ __volatile__ ("movq %%fs:%P1,%q0"				      \
 		       : "=r" (__value)					      \
-		       : "i" (offsetof (struct pthread, member)));	      \
+		       : "i" (offsetof (struct kpthread, member)));	      \
        }								      \
      __value; })
 
+# define THREAD_GETMEM(descr, member)	descr->member
 
 /* Same as THREAD_GETMEM, but the member offset can be non-constant.  */
-# define THREAD_GETMEM_NC(descr, member, idx) \
+# define KTHREAD_GETMEM_NC(descr, member, idx) \
   ({ __typeof (descr->member[0]) __value;				      \
      if (sizeof (__value) == 1)						      \
        __asm__ __volatile__ ("movb %%fs:%P2(%q3),%b0"				      \
 		     : "=q" (__value)					      \
-		     : "0" (0), "i" (offsetof (struct pthread, member[0])),   \
+		     : "0" (0), "i" (offsetof (struct kpthread, member[0])),   \
 		       "r" (idx));					      \
      else if (sizeof (__value) == 4)					      \
        __asm__ __volatile__ ("movl %%fs:%P1(,%q2,4),%0"				      \
 		     : "=r" (__value)					      \
-		     : "i" (offsetof (struct pthread, member[0])), "r" (idx));\
+		     : "i" (offsetof (struct kpthread, member[0])), "r" (idx));\
      else								      \
        {								      \
 	 if (sizeof (__value) != 8)					      \
@@ -249,11 +260,12 @@
 									      \
 	 __asm__ __volatile__ ("movq %%fs:%P1(,%q2,8),%q0"			      \
 		       : "=r" (__value)					      \
-		       : "i" (offsetof (struct pthread, member[0])),	      \
+		       : "i" (offsetof (struct kpthread, member[0])),	      \
 			 "r" (idx));					      \
        }								      \
      __value; })
 
+# define THREAD_GETMEM_NC(descr, member, idx)	descr->member[idx]
 
 /* Loading addresses of objects on x86-64 needs to be treated special
    when generating PIC code.  */
@@ -265,15 +277,15 @@
 
 
 /* Same as THREAD_SETMEM, but the member offset can be non-constant.  */
-# define THREAD_SETMEM(descr, member, value) \
+# define KTHREAD_SETMEM(descr, member, value) \
   ({ if (sizeof (descr->member) == 1)					      \
        __asm__ __volatile__ ("movb %b0,%%fs:%P1" :				      \
 		     : "iq" (value),					      \
-		       "i" (offsetof (struct pthread, member)));	      \
+		       "i" (offsetof (struct kpthread, member)));	      \
      else if (sizeof (descr->member) == 4)				      \
        __asm__ __volatile__ ("movl %0,%%fs:%P1" :				      \
 		     : IMM_MODE (value),				      \
-		       "i" (offsetof (struct pthread, member)));	      \
+		       "i" (offsetof (struct kpthread, member)));	      \
      else								      \
        {								      \
 	 if (sizeof (descr->member) != 8)				      \
@@ -283,21 +295,23 @@
 									      \
 	 __asm__ __volatile__ ("movq %q0,%%fs:%P1" :				      \
 		       : IMM_MODE ((unsigned long int) value),		      \
-			 "i" (offsetof (struct pthread, member)));	      \
+			 "i" (offsetof (struct kpthread, member)));	      \
        }})
 
+#define THREAD_SETMEM(descr, member, value) \
+  descr->member = (value)
 
 /* Set member of the thread descriptor directly.  */
-# define THREAD_SETMEM_NC(descr, member, idx, value) \
+# define KTHREAD_SETMEM_NC(descr, member, idx, value) \
   ({ if (sizeof (descr->member[0]) == 1)				      \
        __asm__ __volatile__ ("movb %b0,%%fs:%P1(%q2)" :				      \
 		     : "iq" (value),					      \
-		       "i" (offsetof (struct pthread, member[0])),	      \
+		       "i" (offsetof (struct kpthread, member[0])),	      \
 		       "r" (idx));					      \
      else if (sizeof (descr->member[0]) == 4)				      \
        __asm__ __volatile__ ("movl %0,%%fs:%P1(,%q2,4)" :			      \
 		     : IMM_MODE (value),				      \
-		       "i" (offsetof (struct pthread, member[0])),	      \
+		       "i" (offsetof (struct kpthread, member[0])),	      \
 		       "r" (idx));					      \
      else								      \
        {								      \
@@ -308,20 +322,22 @@
 									      \
 	 __asm__ __volatile__ ("movq %q0,%%fs:%P1(,%q2,8)" :			      \
 		       : IMM_MODE ((unsigned long int) value),		      \
-			 "i" (offsetof (struct pthread, member[0])),	      \
+			 "i" (offsetof (struct kpthread, member[0])),	      \
 			 "r" (idx));					      \
        }})
 
+#define THREAD_SETMEM_NC(descr, member, idx, value) \
+  descr->member[idx] = (value)
 
 /* Atomic compare and exchange on TLS, returning old value.  */
-# define THREAD_ATOMIC_CMPXCHG_VAL(descr, member, newval, oldval) \
+# define KTHREAD_ATOMIC_CMPXCHG_VAL(descr, member, newval, oldval) \
   ({ __typeof (descr->member) __ret;					      \
      __typeof (oldval) __old = (oldval);				      \
      if (sizeof (descr->member) == 4)					      \
        __asm__ __volatile__ (LOCK_PREFIX "cmpxchgl %2, %%fs:%P3"		      \
 		     : "=a" (__ret)					      \
 		     : "0" (__old), "r" (newval),			      \
-		       "i" (offsetof (struct pthread, member)));	      \
+		       "i" (offsetof (struct kpthread, member)));	      \
      else								      \
        /* Not necessary for other sizes in the moment.  */		      \
        abort ();							      \
@@ -329,10 +345,10 @@
 
 
 /* Atomic logical and.  */
-# define THREAD_ATOMIC_AND(descr, member, val) \
+# define KTHREAD_ATOMIC_AND(descr, member, val) \
   (void) ({ if (sizeof ((descr)->member) == 4)				      \
 	      __asm__ __volatile__ (LOCK_PREFIX "andl %1, %%fs:%P0"		      \
-			    :: "i" (offsetof (struct pthread, member)),	      \
+			    :: "i" (offsetof (struct kpthread, member)),	      \
 			       "ir" (val));				      \
 	    else							      \
 	      /* Not necessary for other sizes in the moment.  */	      \
@@ -340,23 +356,23 @@
 
 
 /* Atomic set bit.  */
-# define THREAD_ATOMIC_BIT_SET(descr, member, bit) \
+# define KTHREAD_ATOMIC_BIT_SET(descr, member, bit) \
   (void) ({ if (sizeof ((descr)->member) == 4)				      \
 	      __asm__ __volatile__ (LOCK_PREFIX "orl %1, %%fs:%P0"		      \
-			    :: "i" (offsetof (struct pthread, member)),	      \
+			    :: "i" (offsetof (struct kpthread, member)),	      \
 			       "ir" (1 << (bit)));			      \
 	    else							      \
 	      /* Not necessary for other sizes in the moment.  */	      \
 	      abort (); })
 
 
-# define CALL_THREAD_FCT(descr) \
+# define CALL_KTHREAD_FCT(descr) \
   ({ void *__res;							      \
      __asm__ __volatile__ ("movq %%fs:%P2, %%rdi\n\t"				      \
 		   "callq *%%fs:%P1"					      \
 		   : "=a" (__res)					      \
-		   : "i" (offsetof (struct pthread, start_routine)),	      \
-		     "i" (offsetof (struct pthread, arg))		      \
+		   : "i" (offsetof (struct kpthread, start_routine)),	      \
+		     "i" (offsetof (struct kpthread, arg))		      \
 		   : "di", "si", "cx", "dx", "r8", "r9", "r10", "r11",	      \
 		     "memory", "cc");					      \
      __res; })
@@ -377,17 +393,41 @@
   ((descr)->header.pointer_guard					      \
    = THREAD_GETMEM (THREAD_SELF, header.pointer_guard))
 
+/* Set the stack guard field in TCB head.  */
+# define KTHREAD_SET_STACK_GUARD(value) \
+    KTHREAD_SETMEM (KTHREAD_SELF, header.stack_guard, value)
+# define KTHREAD_COPY_STACK_GUARD(descr) \
+    ((descr)->header.stack_guard					      \
+     = KTHREAD_GETMEM (KTHREAD_SELF, header.stack_guard))
+
+
+/* Set the pointer guard field in the TCB head.  */
+# define KTHREAD_SET_POINTER_GUARD(value) \
+  KTHREAD_SETMEM (KTHREAD_SELF, header.pointer_guard, value)
+# define KTHREAD_COPY_POINTER_GUARD(descr) \
+  ((descr)->header.pointer_guard					      \
+   = KTHREAD_GETMEM (KTHREAD_SELF, header.pointer_guard))
+
 
 /* Get and set the global scope generation counter in the TCB head.  */
 # define THREAD_GSCOPE_FLAG_UNUSED 0
 # define THREAD_GSCOPE_FLAG_USED   1
 # define THREAD_GSCOPE_FLAG_WAIT   2
 # define THREAD_GSCOPE_RESET_FLAG() \
+  do									     \
+    { int __res								     \
+	= atomic_exchange_rel (&THREAD_SELF->header.gscope_flag,	     \
+			       THREAD_GSCOPE_FLAG_UNUSED);		     \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				     \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1, LLL_PRIVATE);   \
+    }									     \
+  while (0)
+# define KTHREAD_GSCOPE_RESET_FLAG() \
   do									      \
     { int __res;							      \
       __asm__ __volatile__ ("xchgl %0, %%fs:%P1"				      \
 		    : "=r" (__res)					      \
-		    : "i" (offsetof (struct pthread, header.gscope_flag)),    \
+		    : "i" (offsetof (struct kpthread, header.gscope_flag)),    \
 		      "0" (THREAD_GSCOPE_FLAG_UNUSED));			      \
       if (__res == THREAD_GSCOPE_FLAG_WAIT)				      \
 	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1, LLL_PRIVATE);    \
diff -urN uClibc-0.9.33/libpthread/nptl/version.c uClibc-0.9.33-new/libpthread/nptl/version.c
--- uClibc-0.9.33/libpthread/nptl/version.c	2013-09-23 20:39:09.382221883 -0400
+++ uClibc-0.9.33-new/libpthread/nptl/version.c	2013-09-23 20:39:32.986222863 -0400
@@ -20,6 +20,8 @@
 #include <unistd.h>
 #include <sysdep.h>
 
+#include <bits/sclib.h>
+#include <bits/sclib_syscalls.h>
 
 static const char banner[] =
 #include "banner.h"
@@ -37,8 +39,7 @@
 void
 __nptl_main (void)
 {
-  INTERNAL_SYSCALL_DECL (err);
-  INTERNAL_SYSCALL (write, err, 3, STDOUT_FILENO, (const char *) banner,
+  __internal_sys_write (STDOUT_FILENO, (const char *) banner,
 		    sizeof banner - 1);
 
   _exit (0);
diff -urN uClibc-0.9.33/Rules.mak uClibc-0.9.33-new/Rules.mak
--- uClibc-0.9.33/Rules.mak	2013-09-23 20:39:08.814221855 -0400
+++ uClibc-0.9.33-new/Rules.mak	2013-09-23 20:39:32.986222863 -0400
@@ -707,7 +707,7 @@
 ifeq ($(UCLIBC_HAS_THREADS),y)
 ifeq ($(UCLIBC_HAS_THREADS_NATIVE),y)
 	PTNAME := nptl
-	CFLAGS += -DHAVE_FORCED_UNWIND
+#	CFLAGS += -DHAVE_FORCED_UNWIND
 else
 ifeq ($(LINUXTHREADS_OLD),y)
 	PTNAME := linuxthreads.old
